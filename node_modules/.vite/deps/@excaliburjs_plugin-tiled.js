import {
  __commonJS,
  __toCommonJS,
  excalibur_exports,
  init_excalibur
} from "./chunk-W6WAA5UW.js";

// browser-external:jsdom
var require_jsdom = __commonJS({
  "browser-external:jsdom"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "jsdom" has been externalized for browser compatibility. Cannot access "jsdom.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@excaliburjs/plugin-tiled/dist/excalibur-tiled.min.js
var require_excalibur_tiled_min = __commonJS({
  "node_modules/@excaliburjs/plugin-tiled/dist/excalibur-tiled.min.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "object" == typeof module ? module.exports = t(function() {
        try {
          return require_jsdom();
        } catch (e2) {
        }
      }(), (init_excalibur(), __toCommonJS(excalibur_exports))) : "function" == typeof define && define.amd ? define(["jsdom", "excalibur"], t) : "object" == typeof exports ? exports.ex = t(function() {
        try {
          return require_jsdom();
        } catch (e2) {
        }
      }(), (init_excalibur(), __toCommonJS(excalibur_exports))) : (e.ex = e.ex || {}, e.ex.Plugin = e.ex.Plugin || {}, e.ex.Plugin.Tiled = t(e.jsdom, e.ex));
    }(self, (e, t) => (() => {
      var i = { "./node_modules/compare-versions/lib/esm/compare.js": (e2, t2, i2) => {
        "use strict";
        i2.r(t2), i2.d(t2, { compare: () => s2 });
        var A2 = i2("./node_modules/compare-versions/lib/esm/compareVersions.js");
        const s2 = (e3, t3, i3) => {
          o(i3);
          const s3 = (0, A2.compareVersions)(e3, t3);
          return r2[i3].includes(s3);
        }, r2 = { ">": [1], ">=": [0, 1], "=": [0], "<=": [-1, 0], "<": [-1], "!=": [-1, 1] }, a = Object.keys(r2), o = (e3) => {
          if ("string" != typeof e3)
            throw new TypeError("Invalid operator type, expected string but got " + typeof e3);
          if (-1 === a.indexOf(e3))
            throw new Error(`Invalid operator, expected one of ${a.join("|")}`);
        };
      }, "./node_modules/compare-versions/lib/esm/compareVersions.js": (e2, t2, i2) => {
        "use strict";
        i2.r(t2), i2.d(t2, { compareVersions: () => s2 });
        var A2 = i2("./node_modules/compare-versions/lib/esm/utils.js");
        const s2 = (e3, t3) => {
          const i3 = (0, A2.validateAndParse)(e3), s3 = (0, A2.validateAndParse)(t3), r2 = i3.pop(), a = s3.pop(), o = (0, A2.compareSegments)(i3, s3);
          return 0 !== o ? o : r2 && a ? (0, A2.compareSegments)(r2.split("."), a.split(".")) : r2 || a ? r2 ? -1 : 1 : 0;
        };
      }, "./node_modules/compare-versions/lib/esm/utils.js": (e2, t2, i2) => {
        "use strict";
        i2.r(t2), i2.d(t2, { compareSegments: () => n, semver: () => A2, validateAndParse: () => s2 });
        const A2 = /^[v^~<>=]*?(\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+))?(?:-([\da-z\-]+(?:\.[\da-z\-]+)*))?(?:\+[\da-z\-]+(?:\.[\da-z\-]+)*)?)?)?$/i, s2 = (e3) => {
          if ("string" != typeof e3)
            throw new TypeError("Invalid argument expected string");
          const t3 = e3.match(A2);
          if (!t3)
            throw new Error(`Invalid argument not valid semver ('${e3}' received)`);
          return t3.shift(), t3;
        }, r2 = (e3) => "*" === e3 || "x" === e3 || "X" === e3, a = (e3) => {
          const t3 = parseInt(e3, 10);
          return isNaN(t3) ? e3 : t3;
        }, o = (e3, t3) => {
          if (r2(e3) || r2(t3))
            return 0;
          const [i3, A3] = ((e4, t4) => typeof e4 != typeof t4 ? [String(e4), String(t4)] : [e4, t4])(a(e3), a(t3));
          return i3 > A3 ? 1 : i3 < A3 ? -1 : 0;
        }, n = (e3, t3) => {
          for (let i3 = 0; i3 < Math.max(e3.length, t3.length); i3++) {
            const A3 = o(e3[i3] || "0", t3[i3] || "0");
            if (0 !== A3)
              return A3;
          }
          return 0;
        };
      }, "./node_modules/fast-xml-parser/src/json2xml.js": (e2, t2, i2) => {
        "use strict";
        const A2 = i2("./node_modules/fast-xml-parser/src/util.js").buildOptions, s2 = { attributeNamePrefix: "@_", attrNodeName: false, textNodeName: "#text", ignoreAttributes: true, cdataTagName: false, cdataPositionChar: "\\c", format: false, indentBy: "  ", supressEmptyNode: false, tagValueProcessor: function(e3) {
          return e3;
        }, attrValueProcessor: function(e3) {
          return e3;
        } }, r2 = ["attributeNamePrefix", "attrNodeName", "textNodeName", "ignoreAttributes", "cdataTagName", "cdataPositionChar", "format", "indentBy", "supressEmptyNode", "tagValueProcessor", "attrValueProcessor", "rootNodeName"];
        function a(e3) {
          this.options = A2(e3, s2, r2), this.options.ignoreAttributes || this.options.attrNodeName ? this.isAttribute = function() {
            return false;
          } : (this.attrPrefixLen = this.options.attributeNamePrefix.length, this.isAttribute = p), this.options.cdataTagName ? this.isCDATA = I : this.isCDATA = function() {
            return false;
          }, this.replaceCDATAstr = n, this.replaceCDATAarr = l, this.processTextOrObjNode = o, this.options.format ? (this.indentate = u, this.tagEndChar = ">\n", this.newLine = "\n") : (this.indentate = function() {
            return "";
          }, this.tagEndChar = ">", this.newLine = ""), this.options.supressEmptyNode ? (this.buildTextNode = h, this.buildObjNode = c) : (this.buildTextNode = g, this.buildObjNode = d), this.buildTextValNode = g, this.buildObjectNode = d;
        }
        function o(e3, t3, i3) {
          const A3 = this.j2x(e3, i3 + 1);
          return void 0 !== e3[this.options.textNodeName] && 1 === Object.keys(e3).length ? this.buildTextNode(A3.val, t3, A3.attrStr, i3) : this.buildObjNode(A3.val, t3, A3.attrStr, i3);
        }
        function n(e3, t3) {
          return e3 = this.options.tagValueProcessor("" + e3), "" === this.options.cdataPositionChar || "" === e3 ? e3 + "<![CDATA[" + t3 + "]]" + this.tagEndChar : e3.replace(this.options.cdataPositionChar, "<![CDATA[" + t3 + "]]" + this.tagEndChar);
        }
        function l(e3, t3) {
          if (e3 = this.options.tagValueProcessor("" + e3), "" === this.options.cdataPositionChar || "" === e3)
            return e3 + "<![CDATA[" + t3.join("]]><![CDATA[") + "]]" + this.tagEndChar;
          for (let i3 in t3)
            e3 = e3.replace(this.options.cdataPositionChar, "<![CDATA[" + t3[i3] + "]]>");
          return e3 + this.newLine;
        }
        function d(e3, t3, i3, A3) {
          return i3 && -1 === e3.indexOf("<") ? this.indentate(A3) + "<" + t3 + i3 + ">" + e3 + "</" + t3 + this.tagEndChar : this.indentate(A3) + "<" + t3 + i3 + this.tagEndChar + e3 + this.indentate(A3) + "</" + t3 + this.tagEndChar;
        }
        function c(e3, t3, i3, A3) {
          return "" !== e3 ? this.buildObjectNode(e3, t3, i3, A3) : this.indentate(A3) + "<" + t3 + i3 + "/" + this.tagEndChar;
        }
        function g(e3, t3, i3, A3) {
          return this.indentate(A3) + "<" + t3 + i3 + ">" + this.options.tagValueProcessor(e3) + "</" + t3 + this.tagEndChar;
        }
        function h(e3, t3, i3, A3) {
          return "" !== e3 ? this.buildTextValNode(e3, t3, i3, A3) : this.indentate(A3) + "<" + t3 + i3 + "/" + this.tagEndChar;
        }
        function u(e3) {
          return this.options.indentBy.repeat(e3);
        }
        function p(e3) {
          return !!e3.startsWith(this.options.attributeNamePrefix) && e3.substr(this.attrPrefixLen);
        }
        function I(e3) {
          return e3 === this.options.cdataTagName;
        }
        a.prototype.parse = function(e3) {
          return Array.isArray(e3) && this.options.rootNodeName && this.options.rootNodeName.length > 1 && (e3 = { [this.options.rootNodeName]: e3 }), this.j2x(e3, 0).val;
        }, a.prototype.j2x = function(e3, t3) {
          let i3 = "", A3 = "";
          for (let s3 in e3)
            if (void 0 === e3[s3])
              ;
            else if (null === e3[s3])
              A3 += this.indentate(t3) + "<" + s3 + "/" + this.tagEndChar;
            else if (e3[s3] instanceof Date)
              A3 += this.buildTextNode(e3[s3], s3, "", t3);
            else if ("object" != typeof e3[s3]) {
              const r3 = this.isAttribute(s3);
              r3 ? i3 += " " + r3 + '="' + this.options.attrValueProcessor("" + e3[s3]) + '"' : this.isCDATA(s3) ? e3[this.options.textNodeName] ? A3 += this.replaceCDATAstr(e3[this.options.textNodeName], e3[s3]) : A3 += this.replaceCDATAstr("", e3[s3]) : s3 === this.options.textNodeName ? e3[this.options.cdataTagName] || (A3 += this.options.tagValueProcessor("" + e3[s3])) : A3 += this.buildTextNode(e3[s3], s3, "", t3);
            } else if (Array.isArray(e3[s3]))
              if (this.isCDATA(s3))
                A3 += this.indentate(t3), e3[this.options.textNodeName] ? A3 += this.replaceCDATAarr(e3[this.options.textNodeName], e3[s3]) : A3 += this.replaceCDATAarr("", e3[s3]);
              else {
                const i4 = e3[s3].length;
                for (let r3 = 0; r3 < i4; r3++) {
                  const i5 = e3[s3][r3];
                  void 0 === i5 || (A3 += null === i5 ? this.indentate(t3) + "<" + s3 + "/" + this.tagEndChar : "object" == typeof i5 ? this.processTextOrObjNode(i5, s3, t3) : this.buildTextNode(i5, s3, "", t3));
                }
              }
            else if (this.options.attrNodeName && s3 === this.options.attrNodeName) {
              const t4 = Object.keys(e3[s3]), A4 = t4.length;
              for (let r3 = 0; r3 < A4; r3++)
                i3 += " " + t4[r3] + '="' + this.options.attrValueProcessor("" + e3[s3][t4[r3]]) + '"';
            } else
              A3 += this.processTextOrObjNode(e3[s3], s3, t3);
          return { attrStr: i3, val: A3 };
        }, e2.exports = a;
      }, "./node_modules/fast-xml-parser/src/nimndata.js": (e2, t2, i2) => {
        "use strict";
        const A2 = function(e3) {
          return String.fromCharCode(e3);
        }, s2 = { nilChar: A2(176), missingChar: A2(201), nilPremitive: A2(175), missingPremitive: A2(200), emptyChar: A2(178), emptyValue: A2(177), boundryChar: A2(179), objStart: A2(198), arrStart: A2(204), arrayEnd: A2(185) }, r2 = [s2.nilChar, s2.nilPremitive, s2.missingChar, s2.missingPremitive, s2.boundryChar, s2.emptyChar, s2.emptyValue, s2.arrayEnd, s2.objStart, s2.arrStart], a = function(e3, t3, i3) {
          if ("string" == typeof t3)
            return e3 && e3[0] && void 0 !== e3[0].val ? o(e3[0].val, t3) : o(e3, t3);
          {
            const r3 = void 0 === (A3 = e3) ? s2.missingChar : null === A3 ? s2.nilChar : !(A3.child && 0 === Object.keys(A3.child).length && (!A3.attrsMap || 0 === Object.keys(A3.attrsMap).length)) || s2.emptyChar;
            if (true === r3) {
              let A4 = "";
              if (Array.isArray(t3)) {
                A4 += s2.arrStart;
                const r4 = t3[0], l2 = e3.length;
                if ("string" == typeof r4)
                  for (let t4 = 0; t4 < l2; t4++) {
                    const i4 = o(e3[t4].val, r4);
                    A4 = n(A4, i4);
                  }
                else
                  for (let t4 = 0; t4 < l2; t4++) {
                    const s3 = a(e3[t4], r4, i3);
                    A4 = n(A4, s3);
                  }
                A4 += s2.arrayEnd;
              } else {
                A4 += s2.objStart;
                const r4 = Object.keys(t3);
                Array.isArray(e3) && (e3 = e3[0]);
                for (let s3 in r4) {
                  const o2 = r4[s3];
                  let l2;
                  l2 = !i3.ignoreAttributes && e3.attrsMap && e3.attrsMap[o2] ? a(e3.attrsMap[o2], t3[o2], i3) : o2 === i3.textNodeName ? a(e3.val, t3[o2], i3) : a(e3.child[o2], t3[o2], i3), A4 = n(A4, l2);
                }
              }
              return A4;
            }
            return r3;
          }
          var A3;
        }, o = function(e3) {
          switch (e3) {
            case void 0:
              return s2.missingPremitive;
            case null:
              return s2.nilPremitive;
            case "":
              return s2.emptyValue;
            default:
              return e3;
          }
        }, n = function(e3, t3) {
          return l(t3[0]) || l(e3[e3.length - 1]) || (e3 += s2.boundryChar), e3 + t3;
        }, l = function(e3) {
          return -1 !== r2.indexOf(e3);
        }, d = i2("./node_modules/fast-xml-parser/src/xmlstr2xmlnode.js"), c = i2("./node_modules/fast-xml-parser/src/util.js").buildOptions;
        t2.convert2nimn = function(e3, t3, i3) {
          return i3 = c(i3, d.defaultOptions, d.props), a(e3, t3, i3);
        };
      }, "./node_modules/fast-xml-parser/src/node2json.js": (e2, t2, i2) => {
        "use strict";
        const A2 = i2("./node_modules/fast-xml-parser/src/util.js"), s2 = function(e3, t3, i3) {
          const r2 = {};
          if (!t3.alwaysCreateTextNode && (!e3.child || A2.isEmptyObject(e3.child)) && (!e3.attrsMap || A2.isEmptyObject(e3.attrsMap)))
            return A2.isExist(e3.val) ? e3.val : "";
          if (A2.isExist(e3.val) && ("string" != typeof e3.val || "" !== e3.val && e3.val !== t3.cdataPositionChar)) {
            const s3 = A2.isTagNameInArrayMode(e3.tagname, t3.arrayMode, i3);
            r2[t3.textNodeName] = s3 ? [e3.val] : e3.val;
          }
          A2.merge(r2, e3.attrsMap, t3.arrayMode);
          const a = Object.keys(e3.child);
          for (let o = 0; o < a.length; o++) {
            const n = a[o];
            if (e3.child[n] && e3.child[n].length > 1) {
              r2[n] = [];
              for (let i4 in e3.child[n])
                e3.child[n].hasOwnProperty(i4) && r2[n].push(s2(e3.child[n][i4], t3, n));
            } else {
              const a2 = s2(e3.child[n][0], t3, n), o2 = true === t3.arrayMode && "object" == typeof a2 || A2.isTagNameInArrayMode(n, t3.arrayMode, i3);
              r2[n] = o2 ? [a2] : a2;
            }
          }
          return r2;
        };
        t2.convertToJson = s2;
      }, "./node_modules/fast-xml-parser/src/node2json_str.js": (e2, t2, i2) => {
        "use strict";
        const A2 = i2("./node_modules/fast-xml-parser/src/util.js"), s2 = i2("./node_modules/fast-xml-parser/src/util.js").buildOptions, r2 = i2("./node_modules/fast-xml-parser/src/xmlstr2xmlnode.js"), a = function(e3, t3, i3) {
          let s3 = "{";
          const r3 = Object.keys(e3.child);
          for (let i4 = 0; i4 < r3.length; i4++) {
            const A3 = r3[i4];
            if (e3.child[A3] && e3.child[A3].length > 1) {
              s3 += '"' + A3 + '" : [ ';
              for (let i5 in e3.child[A3])
                s3 += a(e3.child[A3][i5], t3) + " , ";
              s3 = s3.substr(0, s3.length - 1) + " ] ";
            } else
              s3 += '"' + A3 + '" : ' + a(e3.child[A3][0], t3) + " ,";
          }
          return A2.merge(s3, e3.attrsMap), A2.isEmptyObject(s3) ? A2.isExist(e3.val) ? e3.val : "" : (A2.isExist(e3.val) && ("string" != typeof e3.val || "" !== e3.val && e3.val !== t3.cdataPositionChar) && (s3 += '"' + t3.textNodeName + '" : ' + (true !== (o = e3.val) && false !== o && isNaN(o) ? '"' + o + '"' : o)), "," === s3[s3.length - 1] && (s3 = s3.substr(0, s3.length - 2)), s3 + "}");
          var o;
        };
        t2.convertToJsonString = function(e3, t3) {
          return (t3 = s2(t3, r2.defaultOptions, r2.props)).indentBy = t3.indentBy || "", a(e3, t3, 0);
        };
      }, "./node_modules/fast-xml-parser/src/parser.js": (e2, t2, i2) => {
        "use strict";
        const A2 = i2("./node_modules/fast-xml-parser/src/node2json.js"), s2 = i2("./node_modules/fast-xml-parser/src/xmlstr2xmlnode.js"), r2 = i2("./node_modules/fast-xml-parser/src/xmlstr2xmlnode.js"), a = i2("./node_modules/fast-xml-parser/src/util.js").buildOptions, o = i2("./node_modules/fast-xml-parser/src/validator.js");
        t2.parse = function(e3, t3 = {}, i3) {
          if (i3) {
            true === i3 && (i3 = {});
            const t4 = o.validate(e3, i3);
            if (true !== t4)
              throw Error(t4.err.msg);
          }
          t3.parseTrueNumberOnly && false !== t3.parseNodeValue && !t3.numParseOptions && (t3.numParseOptions = { leadingZeros: false });
          let n = a(t3, r2.defaultOptions, r2.props);
          const l = s2.getTraversalObj(e3, n);
          return A2.convertToJson(l, n);
        }, t2.convertTonimn = i2("./node_modules/fast-xml-parser/src/nimndata.js").convert2nimn, t2.getTraversalObj = s2.getTraversalObj, t2.convertToJson = A2.convertToJson, t2.convertToJsonString = i2("./node_modules/fast-xml-parser/src/node2json_str.js").convertToJsonString, t2.validate = o.validate, t2.j2xParser = i2("./node_modules/fast-xml-parser/src/json2xml.js"), t2.parseToNimn = function(e3, i3, A3) {
          return t2.convertTonimn(t2.getTraversalObj(e3, A3), i3, A3);
        };
      }, "./node_modules/fast-xml-parser/src/util.js": (e2, t2) => {
        "use strict";
        const i2 = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", A2 = "[" + i2 + "][" + i2 + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*", s2 = new RegExp("^" + A2 + "$");
        t2.isExist = function(e3) {
          return void 0 !== e3;
        }, t2.isEmptyObject = function(e3) {
          return 0 === Object.keys(e3).length;
        }, t2.merge = function(e3, t3, i3) {
          if (t3) {
            const A3 = Object.keys(t3), s3 = A3.length;
            for (let r2 = 0; r2 < s3; r2++)
              e3[A3[r2]] = "strict" === i3 ? [t3[A3[r2]]] : t3[A3[r2]];
          }
        }, t2.getValue = function(e3) {
          return t2.isExist(e3) ? e3 : "";
        }, t2.buildOptions = function(e3, t3, i3) {
          let A3 = {};
          if (!e3)
            return t3;
          for (let s3 = 0; s3 < i3.length; s3++)
            void 0 !== e3[i3[s3]] ? A3[i3[s3]] = e3[i3[s3]] : A3[i3[s3]] = t3[i3[s3]];
          return A3;
        }, t2.isTagNameInArrayMode = function(e3, t3, i3) {
          return false !== t3 && (t3 instanceof RegExp ? t3.test(e3) : "function" == typeof t3 ? !!t3(e3, i3) : "strict" === t3);
        }, t2.isName = function(e3) {
          return !(null == s2.exec(e3));
        }, t2.getAllMatches = function(e3, t3) {
          const i3 = [];
          let A3 = t3.exec(e3);
          for (; A3; ) {
            const s3 = [];
            s3.startIndex = t3.lastIndex - A3[0].length;
            const r2 = A3.length;
            for (let e4 = 0; e4 < r2; e4++)
              s3.push(A3[e4]);
            i3.push(s3), A3 = t3.exec(e3);
          }
          return i3;
        }, t2.nameRegexp = A2;
      }, "./node_modules/fast-xml-parser/src/validator.js": (e2, t2, i2) => {
        "use strict";
        const A2 = i2("./node_modules/fast-xml-parser/src/util.js"), s2 = { allowBooleanAttributes: false }, r2 = ["allowBooleanAttributes"];
        function a(e3, t3) {
          const i3 = t3;
          for (; t3 < e3.length; t3++)
            if ("?" != e3[t3] && " " != e3[t3])
              ;
            else {
              const A3 = e3.substr(i3, t3 - i3);
              if (t3 > 5 && "xml" === A3)
                return u("InvalidXml", "XML declaration allowed only at the start of the document.", I(e3, t3));
              if ("?" == e3[t3] && ">" == e3[t3 + 1]) {
                t3++;
                break;
              }
            }
          return t3;
        }
        function o(e3, t3) {
          if (e3.length > t3 + 5 && "-" === e3[t3 + 1] && "-" === e3[t3 + 2]) {
            for (t3 += 3; t3 < e3.length; t3++)
              if ("-" === e3[t3] && "-" === e3[t3 + 1] && ">" === e3[t3 + 2]) {
                t3 += 2;
                break;
              }
          } else if (e3.length > t3 + 8 && "D" === e3[t3 + 1] && "O" === e3[t3 + 2] && "C" === e3[t3 + 3] && "T" === e3[t3 + 4] && "Y" === e3[t3 + 5] && "P" === e3[t3 + 6] && "E" === e3[t3 + 7]) {
            let i3 = 1;
            for (t3 += 8; t3 < e3.length; t3++)
              if ("<" === e3[t3])
                i3++;
              else if (">" === e3[t3] && (i3--, 0 === i3))
                break;
          } else if (e3.length > t3 + 9 && "[" === e3[t3 + 1] && "C" === e3[t3 + 2] && "D" === e3[t3 + 3] && "A" === e3[t3 + 4] && "T" === e3[t3 + 5] && "A" === e3[t3 + 6] && "[" === e3[t3 + 7]) {
            for (t3 += 8; t3 < e3.length; t3++)
              if ("]" === e3[t3] && "]" === e3[t3 + 1] && ">" === e3[t3 + 2]) {
                t3 += 2;
                break;
              }
          }
          return t3;
        }
        t2.validate = function(e3, t3) {
          t3 = A2.buildOptions(t3, s2, r2);
          const i3 = [];
          let n2 = false, l2 = false;
          "\uFEFF" === e3[0] && (e3 = e3.substr(1));
          for (let s3 = 0; s3 < e3.length; s3++)
            if ("<" === e3[s3] && "?" === e3[s3 + 1]) {
              if (s3 += 2, s3 = a(e3, s3), s3.err)
                return s3;
            } else {
              if ("<" !== e3[s3]) {
                if (" " === e3[s3] || "	" === e3[s3] || "\n" === e3[s3] || "\r" === e3[s3])
                  continue;
                return u("InvalidChar", "char '" + e3[s3] + "' is not expected.", I(e3, s3));
              }
              {
                let r3 = s3;
                if (s3++, "!" === e3[s3]) {
                  s3 = o(e3, s3);
                  continue;
                }
                {
                  let p2 = false;
                  "/" === e3[s3] && (p2 = true, s3++);
                  let f2 = "";
                  for (; s3 < e3.length && ">" !== e3[s3] && " " !== e3[s3] && "	" !== e3[s3] && "\n" !== e3[s3] && "\r" !== e3[s3]; s3++)
                    f2 += e3[s3];
                  if (f2 = f2.trim(), "/" === f2[f2.length - 1] && (f2 = f2.substring(0, f2.length - 1), s3--), c2 = f2, !A2.isName(c2)) {
                    let t4;
                    return t4 = 0 === f2.trim().length ? "Invalid space after '<'." : "Tag '" + f2 + "' is an invalid name.", u("InvalidTag", t4, I(e3, s3));
                  }
                  const C = d(e3, s3);
                  if (false === C)
                    return u("InvalidAttr", "Attributes for '" + f2 + "' have open quote.", I(e3, s3));
                  let m = C.value;
                  if (s3 = C.index, "/" === m[m.length - 1]) {
                    const i4 = s3 - m.length;
                    m = m.substring(0, m.length - 1);
                    const A3 = g(m, t3);
                    if (true !== A3)
                      return u(A3.err.code, A3.err.msg, I(e3, i4 + A3.err.line));
                    n2 = true;
                  } else if (p2) {
                    if (!C.tagClosed)
                      return u("InvalidTag", "Closing tag '" + f2 + "' doesn't have proper closing.", I(e3, s3));
                    if (m.trim().length > 0)
                      return u("InvalidTag", "Closing tag '" + f2 + "' can't have attributes or invalid starting.", I(e3, r3));
                    {
                      const t4 = i3.pop();
                      if (f2 !== t4.tagName) {
                        let i4 = I(e3, t4.tagStartPos);
                        return u("InvalidTag", "Expected closing tag '" + t4.tagName + "' (opened in line " + i4.line + ", col " + i4.col + ") instead of closing tag '" + f2 + "'.", I(e3, r3));
                      }
                      0 == i3.length && (l2 = true);
                    }
                  } else {
                    const A3 = g(m, t3);
                    if (true !== A3)
                      return u(A3.err.code, A3.err.msg, I(e3, s3 - m.length + A3.err.line));
                    if (true === l2)
                      return u("InvalidXml", "Multiple possible root nodes found.", I(e3, s3));
                    i3.push({ tagName: f2, tagStartPos: r3 }), n2 = true;
                  }
                  for (s3++; s3 < e3.length; s3++)
                    if ("<" === e3[s3]) {
                      if ("!" === e3[s3 + 1]) {
                        s3++, s3 = o(e3, s3);
                        continue;
                      }
                      if ("?" !== e3[s3 + 1])
                        break;
                      if (s3 = a(e3, ++s3), s3.err)
                        return s3;
                    } else if ("&" === e3[s3]) {
                      const t4 = h(e3, s3);
                      if (-1 == t4)
                        return u("InvalidChar", "char '&' is not expected.", I(e3, s3));
                      s3 = t4;
                    }
                  "<" === e3[s3] && s3--;
                }
              }
            }
          var c2;
          return n2 ? 1 == i3.length ? u("InvalidTag", "Unclosed tag '" + i3[0].tagName + "'.", I(e3, i3[0].tagStartPos)) : !(i3.length > 0) || u("InvalidXml", "Invalid '" + JSON.stringify(i3.map((e4) => e4.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 }) : u("InvalidXml", "Start tag expected.", 1);
        };
        const n = '"', l = "'";
        function d(e3, t3) {
          let i3 = "", A3 = "", s3 = false;
          for (; t3 < e3.length; t3++) {
            if (e3[t3] === n || e3[t3] === l)
              "" === A3 ? A3 = e3[t3] : A3 !== e3[t3] || (A3 = "");
            else if (">" === e3[t3] && "" === A3) {
              s3 = true;
              break;
            }
            i3 += e3[t3];
          }
          return "" === A3 && { value: i3, index: t3, tagClosed: s3 };
        }
        const c = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
        function g(e3, t3) {
          const i3 = A2.getAllMatches(e3, c), s3 = {};
          for (let e4 = 0; e4 < i3.length; e4++) {
            if (0 === i3[e4][1].length)
              return u("InvalidAttr", "Attribute '" + i3[e4][2] + "' has no space in starting.", f(i3[e4]));
            if (void 0 === i3[e4][3] && !t3.allowBooleanAttributes)
              return u("InvalidAttr", "boolean attribute '" + i3[e4][2] + "' is not allowed.", f(i3[e4]));
            const A3 = i3[e4][2];
            if (!p(A3))
              return u("InvalidAttr", "Attribute '" + A3 + "' is an invalid name.", f(i3[e4]));
            if (s3.hasOwnProperty(A3))
              return u("InvalidAttr", "Attribute '" + A3 + "' is repeated.", f(i3[e4]));
            s3[A3] = 1;
          }
          return true;
        }
        function h(e3, t3) {
          if (";" === e3[++t3])
            return -1;
          if ("#" === e3[t3])
            return function(e4, t4) {
              let i4 = /\d/;
              for ("x" === e4[t4] && (t4++, i4 = /[\da-fA-F]/); t4 < e4.length; t4++) {
                if (";" === e4[t4])
                  return t4;
                if (!e4[t4].match(i4))
                  break;
              }
              return -1;
            }(e3, ++t3);
          let i3 = 0;
          for (; t3 < e3.length; t3++, i3++)
            if (!(e3[t3].match(/\w/) && i3 < 20)) {
              if (";" === e3[t3])
                break;
              return -1;
            }
          return t3;
        }
        function u(e3, t3, i3) {
          return { err: { code: e3, msg: t3, line: i3.line || i3, col: i3.col } };
        }
        function p(e3) {
          return A2.isName(e3);
        }
        function I(e3, t3) {
          const i3 = e3.substring(0, t3).split(/\r?\n/);
          return { line: i3.length, col: i3[i3.length - 1].length + 1 };
        }
        function f(e3) {
          return e3.startIndex + e3[1].length;
        }
      }, "./node_modules/fast-xml-parser/src/xmlNode.js": (e2) => {
        "use strict";
        e2.exports = function(e3, t2, i2) {
          this.tagname = e3, this.parent = t2, this.child = {}, this.attrsMap = {}, this.val = i2, this.addChild = function(e4) {
            Array.isArray(this.child[e4.tagname]) ? this.child[e4.tagname].push(e4) : this.child[e4.tagname] = [e4];
          };
        };
      }, "./node_modules/fast-xml-parser/src/xmlstr2xmlnode.js": (e2, t2, i2) => {
        "use strict";
        const A2 = i2("./node_modules/fast-xml-parser/src/util.js"), s2 = i2("./node_modules/fast-xml-parser/src/util.js").buildOptions, r2 = i2("./node_modules/fast-xml-parser/src/xmlNode.js"), a = i2("./node_modules/strnum/strnum.js");
        "<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)".replace(/NAME/g, A2.nameRegexp), !Number.parseInt && window.parseInt && (Number.parseInt = window.parseInt), !Number.parseFloat && window.parseFloat && (Number.parseFloat = window.parseFloat);
        const o = { attributeNamePrefix: "@_", attrNodeName: false, textNodeName: "#text", ignoreAttributes: true, ignoreNameSpace: false, allowBooleanAttributes: false, parseNodeValue: true, parseAttributeValue: false, arrayMode: false, trimValues: true, cdataTagName: false, cdataPositionChar: "\\c", numParseOptions: { hex: true, leadingZeros: true }, tagValueProcessor: function(e3, t3) {
          return e3;
        }, attrValueProcessor: function(e3, t3) {
          return e3;
        }, stopNodes: [], alwaysCreateTextNode: false };
        t2.defaultOptions = o;
        const n = ["attributeNamePrefix", "attrNodeName", "textNodeName", "ignoreAttributes", "ignoreNameSpace", "allowBooleanAttributes", "parseNodeValue", "parseAttributeValue", "arrayMode", "trimValues", "cdataTagName", "cdataPositionChar", "tagValueProcessor", "attrValueProcessor", "parseTrueNumberOnly", "numParseOptions", "stopNodes", "alwaysCreateTextNode"];
        function l(e3, t3, i3) {
          return t3 && (i3.trimValues && (t3 = t3.trim()), t3 = c(t3 = i3.tagValueProcessor(t3, e3), i3.parseNodeValue, i3.numParseOptions)), t3;
        }
        function d(e3, t3) {
          if (t3.ignoreNameSpace) {
            const t4 = e3.split(":"), i3 = "/" === e3.charAt(0) ? "/" : "";
            if ("xmlns" === t4[0])
              return "";
            2 === t4.length && (e3 = i3 + t4[1]);
          }
          return e3;
        }
        function c(e3, t3, i3) {
          if (t3 && "string" == typeof e3) {
            const t4 = e3.trim();
            return "true" === t4 || "false" !== t4 && a(e3, i3);
          }
          return A2.isExist(e3) ? e3 : "";
        }
        t2.props = n;
        const g = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])(.*?)\\3)?`, "g");
        function h(e3, t3) {
          if (!t3.ignoreAttributes && "string" == typeof e3) {
            e3 = e3.replace(/\r?\n/g, " ");
            const i3 = A2.getAllMatches(e3, g), s3 = i3.length, r3 = {};
            for (let e4 = 0; e4 < s3; e4++) {
              const A3 = d(i3[e4][1], t3);
              A3.length && (void 0 !== i3[e4][4] ? (t3.trimValues && (i3[e4][4] = i3[e4][4].trim()), i3[e4][4] = t3.attrValueProcessor(i3[e4][4], A3), r3[t3.attributeNamePrefix + A3] = c(i3[e4][4], t3.parseAttributeValue, t3.numParseOptions)) : t3.allowBooleanAttributes && (r3[t3.attributeNamePrefix + A3] = true));
            }
            if (!Object.keys(r3).length)
              return;
            if (t3.attrNodeName) {
              const e4 = {};
              return e4[t3.attrNodeName] = r3, e4;
            }
            return r3;
          }
        }
        function u(e3, t3) {
          let i3, A3 = "";
          for (let s3 = t3; s3 < e3.length; s3++) {
            let t4 = e3[s3];
            if (i3)
              t4 === i3 && (i3 = "");
            else if ('"' === t4 || "'" === t4)
              i3 = t4;
            else {
              if (">" === t4)
                return { data: A3, index: s3 };
              "	" === t4 && (t4 = " ");
            }
            A3 += t4;
          }
        }
        function p(e3, t3, i3, A3) {
          const s3 = e3.indexOf(t3, i3);
          if (-1 === s3)
            throw new Error(A3);
          return s3 + t3.length - 1;
        }
        t2.getTraversalObj = function(e3, t3) {
          e3 = e3.replace(/\r\n?/g, "\n"), t3 = s2(t3, o, n);
          const i3 = new r2("!xml");
          let a2 = i3, d2 = "";
          for (let i4 = 0; i4 < e3.length; i4++)
            if ("<" === e3[i4])
              if ("/" === e3[i4 + 1]) {
                const s3 = p(e3, ">", i4, "Closing Tag is not closed.");
                let r3 = e3.substring(i4 + 2, s3).trim();
                if (t3.ignoreNameSpace) {
                  const e4 = r3.indexOf(":");
                  -1 !== e4 && (r3 = r3.substr(e4 + 1));
                }
                a2 && (a2.val ? a2.val = A2.getValue(a2.val) + "" + l(r3, d2, t3) : a2.val = l(r3, d2, t3)), t3.stopNodes.length && t3.stopNodes.includes(a2.tagname) && (a2.child = [], null == a2.attrsMap && (a2.attrsMap = {}), a2.val = e3.substr(a2.startIndex + 1, i4 - a2.startIndex - 1)), a2 = a2.parent, d2 = "", i4 = s3;
              } else if ("?" === e3[i4 + 1])
                i4 = p(e3, "?>", i4, "Pi Tag is not closed.");
              else if ("!--" === e3.substr(i4 + 1, 3))
                i4 = p(e3, "-->", i4, "Comment is not closed.");
              else if ("!D" === e3.substr(i4 + 1, 2)) {
                const t4 = p(e3, ">", i4, "DOCTYPE is not closed.");
                i4 = e3.substring(i4, t4).indexOf("[") >= 0 ? e3.indexOf("]>", i4) + 1 : t4;
              } else if ("![" === e3.substr(i4 + 1, 2)) {
                const s3 = p(e3, "]]>", i4, "CDATA is not closed.") - 2, o2 = e3.substring(i4 + 9, s3);
                if (d2 && (a2.val = A2.getValue(a2.val) + "" + l(a2.tagname, d2, t3), d2 = ""), t3.cdataTagName) {
                  const e4 = new r2(t3.cdataTagName, a2, o2);
                  a2.addChild(e4), a2.val = A2.getValue(a2.val) + t3.cdataPositionChar, o2 && (e4.val = o2);
                } else
                  a2.val = (a2.val || "") + (o2 || "");
                i4 = s3 + 2;
              } else {
                const s3 = u(e3, i4 + 1);
                let o2 = s3.data;
                const n2 = s3.index, c2 = o2.indexOf(" ");
                let g2 = o2, p2 = true;
                if (-1 !== c2 && (g2 = o2.substr(0, c2).replace(/\s\s*$/, ""), o2 = o2.substr(c2 + 1)), t3.ignoreNameSpace) {
                  const e4 = g2.indexOf(":");
                  -1 !== e4 && (g2 = g2.substr(e4 + 1), p2 = g2 !== s3.data.substr(e4 + 1));
                }
                if (a2 && d2 && "!xml" !== a2.tagname && (a2.val = A2.getValue(a2.val) + "" + l(a2.tagname, d2, t3)), o2.length > 0 && o2.lastIndexOf("/") === o2.length - 1) {
                  "/" === g2[g2.length - 1] ? (g2 = g2.substr(0, g2.length - 1), o2 = g2) : o2 = o2.substr(0, o2.length - 1);
                  const e4 = new r2(g2, a2, "");
                  g2 !== o2 && (e4.attrsMap = h(o2, t3)), a2.addChild(e4);
                } else {
                  const e4 = new r2(g2, a2);
                  t3.stopNodes.length && t3.stopNodes.includes(e4.tagname) && (e4.startIndex = n2), g2 !== o2 && p2 && (e4.attrsMap = h(o2, t3)), a2.addChild(e4), a2 = e4;
                }
                d2 = "", i4 = n2;
              }
            else
              d2 += e3[i4];
          return i3;
        };
      }, "./node_modules/pako/index.js": (e2, t2, i2) => {
        "use strict";
        var A2 = {};
        (0, i2("./node_modules/pako/lib/utils/common.js").assign)(A2, i2("./node_modules/pako/lib/deflate.js"), i2("./node_modules/pako/lib/inflate.js"), i2("./node_modules/pako/lib/zlib/constants.js")), e2.exports = A2;
      }, "./node_modules/pako/lib/deflate.js": (e2, t2, i2) => {
        "use strict";
        var A2 = i2("./node_modules/pako/lib/zlib/deflate.js"), s2 = i2("./node_modules/pako/lib/utils/common.js"), r2 = i2("./node_modules/pako/lib/utils/strings.js"), a = i2("./node_modules/pako/lib/zlib/messages.js"), o = i2("./node_modules/pako/lib/zlib/zstream.js"), n = Object.prototype.toString, l = 0, d = -1, c = 0, g = 8;
        function h(e3) {
          if (!(this instanceof h))
            return new h(e3);
          this.options = s2.assign({ level: d, method: g, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: c, to: "" }, e3 || {});
          var t3 = this.options;
          t3.raw && t3.windowBits > 0 ? t3.windowBits = -t3.windowBits : t3.gzip && t3.windowBits > 0 && t3.windowBits < 16 && (t3.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new o(), this.strm.avail_out = 0;
          var i3 = A2.deflateInit2(this.strm, t3.level, t3.method, t3.windowBits, t3.memLevel, t3.strategy);
          if (i3 !== l)
            throw new Error(a[i3]);
          if (t3.header && A2.deflateSetHeader(this.strm, t3.header), t3.dictionary) {
            var u2;
            if (u2 = "string" == typeof t3.dictionary ? r2.string2buf(t3.dictionary) : "[object ArrayBuffer]" === n.call(t3.dictionary) ? new Uint8Array(t3.dictionary) : t3.dictionary, (i3 = A2.deflateSetDictionary(this.strm, u2)) !== l)
              throw new Error(a[i3]);
            this._dict_set = true;
          }
        }
        function u(e3, t3) {
          var i3 = new h(t3);
          if (i3.push(e3, true), i3.err)
            throw i3.msg || a[i3.err];
          return i3.result;
        }
        h.prototype.push = function(e3, t3) {
          var i3, a2, o2 = this.strm, d2 = this.options.chunkSize;
          if (this.ended)
            return false;
          a2 = t3 === ~~t3 ? t3 : true === t3 ? 4 : 0, "string" == typeof e3 ? o2.input = r2.string2buf(e3) : "[object ArrayBuffer]" === n.call(e3) ? o2.input = new Uint8Array(e3) : o2.input = e3, o2.next_in = 0, o2.avail_in = o2.input.length;
          do {
            if (0 === o2.avail_out && (o2.output = new s2.Buf8(d2), o2.next_out = 0, o2.avail_out = d2), 1 !== (i3 = A2.deflate(o2, a2)) && i3 !== l)
              return this.onEnd(i3), this.ended = true, false;
            0 !== o2.avail_out && (0 !== o2.avail_in || 4 !== a2 && 2 !== a2) || ("string" === this.options.to ? this.onData(r2.buf2binstring(s2.shrinkBuf(o2.output, o2.next_out))) : this.onData(s2.shrinkBuf(o2.output, o2.next_out)));
          } while ((o2.avail_in > 0 || 0 === o2.avail_out) && 1 !== i3);
          return 4 === a2 ? (i3 = A2.deflateEnd(this.strm), this.onEnd(i3), this.ended = true, i3 === l) : 2 !== a2 || (this.onEnd(l), o2.avail_out = 0, true);
        }, h.prototype.onData = function(e3) {
          this.chunks.push(e3);
        }, h.prototype.onEnd = function(e3) {
          e3 === l && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = s2.flattenChunks(this.chunks)), this.chunks = [], this.err = e3, this.msg = this.strm.msg;
        }, t2.Deflate = h, t2.deflate = u, t2.deflateRaw = function(e3, t3) {
          return (t3 = t3 || {}).raw = true, u(e3, t3);
        }, t2.gzip = function(e3, t3) {
          return (t3 = t3 || {}).gzip = true, u(e3, t3);
        };
      }, "./node_modules/pako/lib/inflate.js": (e2, t2, i2) => {
        "use strict";
        var A2 = i2("./node_modules/pako/lib/zlib/inflate.js"), s2 = i2("./node_modules/pako/lib/utils/common.js"), r2 = i2("./node_modules/pako/lib/utils/strings.js"), a = i2("./node_modules/pako/lib/zlib/constants.js"), o = i2("./node_modules/pako/lib/zlib/messages.js"), n = i2("./node_modules/pako/lib/zlib/zstream.js"), l = i2("./node_modules/pako/lib/zlib/gzheader.js"), d = Object.prototype.toString;
        function c(e3) {
          if (!(this instanceof c))
            return new c(e3);
          this.options = s2.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e3 || {});
          var t3 = this.options;
          t3.raw && t3.windowBits >= 0 && t3.windowBits < 16 && (t3.windowBits = -t3.windowBits, 0 === t3.windowBits && (t3.windowBits = -15)), !(t3.windowBits >= 0 && t3.windowBits < 16) || e3 && e3.windowBits || (t3.windowBits += 32), t3.windowBits > 15 && t3.windowBits < 48 && 0 == (15 & t3.windowBits) && (t3.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new n(), this.strm.avail_out = 0;
          var i3 = A2.inflateInit2(this.strm, t3.windowBits);
          if (i3 !== a.Z_OK)
            throw new Error(o[i3]);
          if (this.header = new l(), A2.inflateGetHeader(this.strm, this.header), t3.dictionary && ("string" == typeof t3.dictionary ? t3.dictionary = r2.string2buf(t3.dictionary) : "[object ArrayBuffer]" === d.call(t3.dictionary) && (t3.dictionary = new Uint8Array(t3.dictionary)), t3.raw && (i3 = A2.inflateSetDictionary(this.strm, t3.dictionary)) !== a.Z_OK))
            throw new Error(o[i3]);
        }
        function g(e3, t3) {
          var i3 = new c(t3);
          if (i3.push(e3, true), i3.err)
            throw i3.msg || o[i3.err];
          return i3.result;
        }
        c.prototype.push = function(e3, t3) {
          var i3, o2, n2, l2, c2, g2 = this.strm, h = this.options.chunkSize, u = this.options.dictionary, p = false;
          if (this.ended)
            return false;
          o2 = t3 === ~~t3 ? t3 : true === t3 ? a.Z_FINISH : a.Z_NO_FLUSH, "string" == typeof e3 ? g2.input = r2.binstring2buf(e3) : "[object ArrayBuffer]" === d.call(e3) ? g2.input = new Uint8Array(e3) : g2.input = e3, g2.next_in = 0, g2.avail_in = g2.input.length;
          do {
            if (0 === g2.avail_out && (g2.output = new s2.Buf8(h), g2.next_out = 0, g2.avail_out = h), (i3 = A2.inflate(g2, a.Z_NO_FLUSH)) === a.Z_NEED_DICT && u && (i3 = A2.inflateSetDictionary(this.strm, u)), i3 === a.Z_BUF_ERROR && true === p && (i3 = a.Z_OK, p = false), i3 !== a.Z_STREAM_END && i3 !== a.Z_OK)
              return this.onEnd(i3), this.ended = true, false;
            g2.next_out && (0 !== g2.avail_out && i3 !== a.Z_STREAM_END && (0 !== g2.avail_in || o2 !== a.Z_FINISH && o2 !== a.Z_SYNC_FLUSH) || ("string" === this.options.to ? (n2 = r2.utf8border(g2.output, g2.next_out), l2 = g2.next_out - n2, c2 = r2.buf2string(g2.output, n2), g2.next_out = l2, g2.avail_out = h - l2, l2 && s2.arraySet(g2.output, g2.output, n2, l2, 0), this.onData(c2)) : this.onData(s2.shrinkBuf(g2.output, g2.next_out)))), 0 === g2.avail_in && 0 === g2.avail_out && (p = true);
          } while ((g2.avail_in > 0 || 0 === g2.avail_out) && i3 !== a.Z_STREAM_END);
          return i3 === a.Z_STREAM_END && (o2 = a.Z_FINISH), o2 === a.Z_FINISH ? (i3 = A2.inflateEnd(this.strm), this.onEnd(i3), this.ended = true, i3 === a.Z_OK) : o2 !== a.Z_SYNC_FLUSH || (this.onEnd(a.Z_OK), g2.avail_out = 0, true);
        }, c.prototype.onData = function(e3) {
          this.chunks.push(e3);
        }, c.prototype.onEnd = function(e3) {
          e3 === a.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = s2.flattenChunks(this.chunks)), this.chunks = [], this.err = e3, this.msg = this.strm.msg;
        }, t2.Inflate = c, t2.inflate = g, t2.inflateRaw = function(e3, t3) {
          return (t3 = t3 || {}).raw = true, g(e3, t3);
        }, t2.ungzip = g;
      }, "./node_modules/pako/lib/utils/common.js": (e2, t2) => {
        "use strict";
        var i2 = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
        function A2(e3, t3) {
          return Object.prototype.hasOwnProperty.call(e3, t3);
        }
        t2.assign = function(e3) {
          for (var t3 = Array.prototype.slice.call(arguments, 1); t3.length; ) {
            var i3 = t3.shift();
            if (i3) {
              if ("object" != typeof i3)
                throw new TypeError(i3 + "must be non-object");
              for (var s3 in i3)
                A2(i3, s3) && (e3[s3] = i3[s3]);
            }
          }
          return e3;
        }, t2.shrinkBuf = function(e3, t3) {
          return e3.length === t3 ? e3 : e3.subarray ? e3.subarray(0, t3) : (e3.length = t3, e3);
        };
        var s2 = { arraySet: function(e3, t3, i3, A3, s3) {
          if (t3.subarray && e3.subarray)
            e3.set(t3.subarray(i3, i3 + A3), s3);
          else
            for (var r3 = 0; r3 < A3; r3++)
              e3[s3 + r3] = t3[i3 + r3];
        }, flattenChunks: function(e3) {
          var t3, i3, A3, s3, r3, a;
          for (A3 = 0, t3 = 0, i3 = e3.length; t3 < i3; t3++)
            A3 += e3[t3].length;
          for (a = new Uint8Array(A3), s3 = 0, t3 = 0, i3 = e3.length; t3 < i3; t3++)
            r3 = e3[t3], a.set(r3, s3), s3 += r3.length;
          return a;
        } }, r2 = { arraySet: function(e3, t3, i3, A3, s3) {
          for (var r3 = 0; r3 < A3; r3++)
            e3[s3 + r3] = t3[i3 + r3];
        }, flattenChunks: function(e3) {
          return [].concat.apply([], e3);
        } };
        t2.setTyped = function(e3) {
          e3 ? (t2.Buf8 = Uint8Array, t2.Buf16 = Uint16Array, t2.Buf32 = Int32Array, t2.assign(t2, s2)) : (t2.Buf8 = Array, t2.Buf16 = Array, t2.Buf32 = Array, t2.assign(t2, r2));
        }, t2.setTyped(i2);
      }, "./node_modules/pako/lib/utils/strings.js": (e2, t2, i2) => {
        "use strict";
        var A2 = i2("./node_modules/pako/lib/utils/common.js"), s2 = true, r2 = true;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch (e3) {
          s2 = false;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch (e3) {
          r2 = false;
        }
        for (var a = new A2.Buf8(256), o = 0; o < 256; o++)
          a[o] = o >= 252 ? 6 : o >= 248 ? 5 : o >= 240 ? 4 : o >= 224 ? 3 : o >= 192 ? 2 : 1;
        function n(e3, t3) {
          if (t3 < 65534 && (e3.subarray && r2 || !e3.subarray && s2))
            return String.fromCharCode.apply(null, A2.shrinkBuf(e3, t3));
          for (var i3 = "", a2 = 0; a2 < t3; a2++)
            i3 += String.fromCharCode(e3[a2]);
          return i3;
        }
        a[254] = a[254] = 1, t2.string2buf = function(e3) {
          var t3, i3, s3, r3, a2, o2 = e3.length, n2 = 0;
          for (r3 = 0; r3 < o2; r3++)
            55296 == (64512 & (i3 = e3.charCodeAt(r3))) && r3 + 1 < o2 && 56320 == (64512 & (s3 = e3.charCodeAt(r3 + 1))) && (i3 = 65536 + (i3 - 55296 << 10) + (s3 - 56320), r3++), n2 += i3 < 128 ? 1 : i3 < 2048 ? 2 : i3 < 65536 ? 3 : 4;
          for (t3 = new A2.Buf8(n2), a2 = 0, r3 = 0; a2 < n2; r3++)
            55296 == (64512 & (i3 = e3.charCodeAt(r3))) && r3 + 1 < o2 && 56320 == (64512 & (s3 = e3.charCodeAt(r3 + 1))) && (i3 = 65536 + (i3 - 55296 << 10) + (s3 - 56320), r3++), i3 < 128 ? t3[a2++] = i3 : i3 < 2048 ? (t3[a2++] = 192 | i3 >>> 6, t3[a2++] = 128 | 63 & i3) : i3 < 65536 ? (t3[a2++] = 224 | i3 >>> 12, t3[a2++] = 128 | i3 >>> 6 & 63, t3[a2++] = 128 | 63 & i3) : (t3[a2++] = 240 | i3 >>> 18, t3[a2++] = 128 | i3 >>> 12 & 63, t3[a2++] = 128 | i3 >>> 6 & 63, t3[a2++] = 128 | 63 & i3);
          return t3;
        }, t2.buf2binstring = function(e3) {
          return n(e3, e3.length);
        }, t2.binstring2buf = function(e3) {
          for (var t3 = new A2.Buf8(e3.length), i3 = 0, s3 = t3.length; i3 < s3; i3++)
            t3[i3] = e3.charCodeAt(i3);
          return t3;
        }, t2.buf2string = function(e3, t3) {
          var i3, A3, s3, r3, o2 = t3 || e3.length, l = new Array(2 * o2);
          for (A3 = 0, i3 = 0; i3 < o2; )
            if ((s3 = e3[i3++]) < 128)
              l[A3++] = s3;
            else if ((r3 = a[s3]) > 4)
              l[A3++] = 65533, i3 += r3 - 1;
            else {
              for (s3 &= 2 === r3 ? 31 : 3 === r3 ? 15 : 7; r3 > 1 && i3 < o2; )
                s3 = s3 << 6 | 63 & e3[i3++], r3--;
              r3 > 1 ? l[A3++] = 65533 : s3 < 65536 ? l[A3++] = s3 : (s3 -= 65536, l[A3++] = 55296 | s3 >> 10 & 1023, l[A3++] = 56320 | 1023 & s3);
            }
          return n(l, A3);
        }, t2.utf8border = function(e3, t3) {
          var i3;
          for ((t3 = t3 || e3.length) > e3.length && (t3 = e3.length), i3 = t3 - 1; i3 >= 0 && 128 == (192 & e3[i3]); )
            i3--;
          return i3 < 0 || 0 === i3 ? t3 : i3 + a[e3[i3]] > t3 ? i3 : t3;
        };
      }, "./node_modules/pako/lib/zlib/adler32.js": (e2) => {
        "use strict";
        e2.exports = function(e3, t2, i2, A2) {
          for (var s2 = 65535 & e3 | 0, r2 = e3 >>> 16 & 65535 | 0, a = 0; 0 !== i2; ) {
            i2 -= a = i2 > 2e3 ? 2e3 : i2;
            do {
              r2 = r2 + (s2 = s2 + t2[A2++] | 0) | 0;
            } while (--a);
            s2 %= 65521, r2 %= 65521;
          }
          return s2 | r2 << 16 | 0;
        };
      }, "./node_modules/pako/lib/zlib/constants.js": (e2) => {
        "use strict";
        e2.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
      }, "./node_modules/pako/lib/zlib/crc32.js": (e2) => {
        "use strict";
        var t2 = function() {
          for (var e3, t3 = [], i2 = 0; i2 < 256; i2++) {
            e3 = i2;
            for (var A2 = 0; A2 < 8; A2++)
              e3 = 1 & e3 ? 3988292384 ^ e3 >>> 1 : e3 >>> 1;
            t3[i2] = e3;
          }
          return t3;
        }();
        e2.exports = function(e3, i2, A2, s2) {
          var r2 = t2, a = s2 + A2;
          e3 ^= -1;
          for (var o = s2; o < a; o++)
            e3 = e3 >>> 8 ^ r2[255 & (e3 ^ i2[o])];
          return -1 ^ e3;
        };
      }, "./node_modules/pako/lib/zlib/deflate.js": (e2, t2, i2) => {
        "use strict";
        var A2, s2 = i2("./node_modules/pako/lib/utils/common.js"), r2 = i2("./node_modules/pako/lib/zlib/trees.js"), a = i2("./node_modules/pako/lib/zlib/adler32.js"), o = i2("./node_modules/pako/lib/zlib/crc32.js"), n = i2("./node_modules/pako/lib/zlib/messages.js"), l = 0, d = 0, c = -2, g = 2, h = 8, u = 286, p = 30, I = 19, f = 2 * u + 1, C = 15, m = 3, B = 258, E = B + m + 1, y = 42, Q = 103, w = 113, b = 666;
        function _(e3, t3) {
          return e3.msg = n[t3], t3;
        }
        function v(e3) {
          return (e3 << 1) - (e3 > 4 ? 9 : 0);
        }
        function x(e3) {
          for (var t3 = e3.length; --t3 >= 0; )
            e3[t3] = 0;
        }
        function T(e3) {
          var t3 = e3.state, i3 = t3.pending;
          i3 > e3.avail_out && (i3 = e3.avail_out), 0 !== i3 && (s2.arraySet(e3.output, t3.pending_buf, t3.pending_out, i3, e3.next_out), e3.next_out += i3, t3.pending_out += i3, e3.total_out += i3, e3.avail_out -= i3, t3.pending -= i3, 0 === t3.pending && (t3.pending_out = 0));
        }
        function k(e3, t3) {
          r2._tr_flush_block(e3, e3.block_start >= 0 ? e3.block_start : -1, e3.strstart - e3.block_start, t3), e3.block_start = e3.strstart, T(e3.strm);
        }
        function D(e3, t3) {
          e3.pending_buf[e3.pending++] = t3;
        }
        function L(e3, t3) {
          e3.pending_buf[e3.pending++] = t3 >>> 8 & 255, e3.pending_buf[e3.pending++] = 255 & t3;
        }
        function N(e3, t3) {
          var i3, A3, s3 = e3.max_chain_length, r3 = e3.strstart, a2 = e3.prev_length, o2 = e3.nice_match, n2 = e3.strstart > e3.w_size - E ? e3.strstart - (e3.w_size - E) : 0, l2 = e3.window, d2 = e3.w_mask, c2 = e3.prev, g2 = e3.strstart + B, h2 = l2[r3 + a2 - 1], u2 = l2[r3 + a2];
          e3.prev_length >= e3.good_match && (s3 >>= 2), o2 > e3.lookahead && (o2 = e3.lookahead);
          do {
            if (l2[(i3 = t3) + a2] === u2 && l2[i3 + a2 - 1] === h2 && l2[i3] === l2[r3] && l2[++i3] === l2[r3 + 1]) {
              r3 += 2, i3++;
              do {
              } while (l2[++r3] === l2[++i3] && l2[++r3] === l2[++i3] && l2[++r3] === l2[++i3] && l2[++r3] === l2[++i3] && l2[++r3] === l2[++i3] && l2[++r3] === l2[++i3] && l2[++r3] === l2[++i3] && l2[++r3] === l2[++i3] && r3 < g2);
              if (A3 = B - (g2 - r3), r3 = g2 - B, A3 > a2) {
                if (e3.match_start = t3, a2 = A3, A3 >= o2)
                  break;
                h2 = l2[r3 + a2 - 1], u2 = l2[r3 + a2];
              }
            }
          } while ((t3 = c2[t3 & d2]) > n2 && 0 != --s3);
          return a2 <= e3.lookahead ? a2 : e3.lookahead;
        }
        function F(e3) {
          var t3, i3, A3, r3, n2, l2, d2, c2, g2, h2, u2 = e3.w_size;
          do {
            if (r3 = e3.window_size - e3.lookahead - e3.strstart, e3.strstart >= u2 + (u2 - E)) {
              s2.arraySet(e3.window, e3.window, u2, u2, 0), e3.match_start -= u2, e3.strstart -= u2, e3.block_start -= u2, t3 = i3 = e3.hash_size;
              do {
                A3 = e3.head[--t3], e3.head[t3] = A3 >= u2 ? A3 - u2 : 0;
              } while (--i3);
              t3 = i3 = u2;
              do {
                A3 = e3.prev[--t3], e3.prev[t3] = A3 >= u2 ? A3 - u2 : 0;
              } while (--i3);
              r3 += u2;
            }
            if (0 === e3.strm.avail_in)
              break;
            if (l2 = e3.strm, d2 = e3.window, c2 = e3.strstart + e3.lookahead, g2 = r3, h2 = void 0, (h2 = l2.avail_in) > g2 && (h2 = g2), i3 = 0 === h2 ? 0 : (l2.avail_in -= h2, s2.arraySet(d2, l2.input, l2.next_in, h2, c2), 1 === l2.state.wrap ? l2.adler = a(l2.adler, d2, h2, c2) : 2 === l2.state.wrap && (l2.adler = o(l2.adler, d2, h2, c2)), l2.next_in += h2, l2.total_in += h2, h2), e3.lookahead += i3, e3.lookahead + e3.insert >= m)
              for (n2 = e3.strstart - e3.insert, e3.ins_h = e3.window[n2], e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[n2 + 1]) & e3.hash_mask; e3.insert && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[n2 + m - 1]) & e3.hash_mask, e3.prev[n2 & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = n2, n2++, e3.insert--, !(e3.lookahead + e3.insert < m)); )
                ;
          } while (e3.lookahead < E && 0 !== e3.strm.avail_in);
        }
        function S(e3, t3) {
          for (var i3, A3; ; ) {
            if (e3.lookahead < E) {
              if (F(e3), e3.lookahead < E && t3 === l)
                return 1;
              if (0 === e3.lookahead)
                break;
            }
            if (i3 = 0, e3.lookahead >= m && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + m - 1]) & e3.hash_mask, i3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart), 0 !== i3 && e3.strstart - i3 <= e3.w_size - E && (e3.match_length = N(e3, i3)), e3.match_length >= m)
              if (A3 = r2._tr_tally(e3, e3.strstart - e3.match_start, e3.match_length - m), e3.lookahead -= e3.match_length, e3.match_length <= e3.max_lazy_match && e3.lookahead >= m) {
                e3.match_length--;
                do {
                  e3.strstart++, e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + m - 1]) & e3.hash_mask, i3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart;
                } while (0 != --e3.match_length);
                e3.strstart++;
              } else
                e3.strstart += e3.match_length, e3.match_length = 0, e3.ins_h = e3.window[e3.strstart], e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + 1]) & e3.hash_mask;
            else
              A3 = r2._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++;
            if (A3 && (k(e3, false), 0 === e3.strm.avail_out))
              return 1;
          }
          return e3.insert = e3.strstart < m - 1 ? e3.strstart : m - 1, 4 === t3 ? (k(e3, true), 0 === e3.strm.avail_out ? 3 : 4) : e3.last_lit && (k(e3, false), 0 === e3.strm.avail_out) ? 1 : 2;
        }
        function G(e3, t3) {
          for (var i3, A3, s3; ; ) {
            if (e3.lookahead < E) {
              if (F(e3), e3.lookahead < E && t3 === l)
                return 1;
              if (0 === e3.lookahead)
                break;
            }
            if (i3 = 0, e3.lookahead >= m && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + m - 1]) & e3.hash_mask, i3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart), e3.prev_length = e3.match_length, e3.prev_match = e3.match_start, e3.match_length = m - 1, 0 !== i3 && e3.prev_length < e3.max_lazy_match && e3.strstart - i3 <= e3.w_size - E && (e3.match_length = N(e3, i3), e3.match_length <= 5 && (1 === e3.strategy || e3.match_length === m && e3.strstart - e3.match_start > 4096) && (e3.match_length = m - 1)), e3.prev_length >= m && e3.match_length <= e3.prev_length) {
              s3 = e3.strstart + e3.lookahead - m, A3 = r2._tr_tally(e3, e3.strstart - 1 - e3.prev_match, e3.prev_length - m), e3.lookahead -= e3.prev_length - 1, e3.prev_length -= 2;
              do {
                ++e3.strstart <= s3 && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + m - 1]) & e3.hash_mask, i3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart);
              } while (0 != --e3.prev_length);
              if (e3.match_available = 0, e3.match_length = m - 1, e3.strstart++, A3 && (k(e3, false), 0 === e3.strm.avail_out))
                return 1;
            } else if (e3.match_available) {
              if ((A3 = r2._tr_tally(e3, 0, e3.window[e3.strstart - 1])) && k(e3, false), e3.strstart++, e3.lookahead--, 0 === e3.strm.avail_out)
                return 1;
            } else
              e3.match_available = 1, e3.strstart++, e3.lookahead--;
          }
          return e3.match_available && (A3 = r2._tr_tally(e3, 0, e3.window[e3.strstart - 1]), e3.match_available = 0), e3.insert = e3.strstart < m - 1 ? e3.strstart : m - 1, 4 === t3 ? (k(e3, true), 0 === e3.strm.avail_out ? 3 : 4) : e3.last_lit && (k(e3, false), 0 === e3.strm.avail_out) ? 1 : 2;
        }
        function j(e3, t3, i3, A3, s3) {
          this.good_length = e3, this.max_lazy = t3, this.nice_length = i3, this.max_chain = A3, this.func = s3;
        }
        function M() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = h, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new s2.Buf16(2 * f), this.dyn_dtree = new s2.Buf16(2 * (2 * p + 1)), this.bl_tree = new s2.Buf16(2 * (2 * I + 1)), x(this.dyn_ltree), x(this.dyn_dtree), x(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new s2.Buf16(C + 1), this.heap = new s2.Buf16(2 * u + 1), x(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new s2.Buf16(2 * u + 1), x(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        function R(e3) {
          var t3;
          return e3 && e3.state ? (e3.total_in = e3.total_out = 0, e3.data_type = g, (t3 = e3.state).pending = 0, t3.pending_out = 0, t3.wrap < 0 && (t3.wrap = -t3.wrap), t3.status = t3.wrap ? y : w, e3.adler = 2 === t3.wrap ? 0 : 1, t3.last_flush = l, r2._tr_init(t3), d) : _(e3, c);
        }
        function O(e3) {
          var t3, i3 = R(e3);
          return i3 === d && ((t3 = e3.state).window_size = 2 * t3.w_size, x(t3.head), t3.max_lazy_match = A2[t3.level].max_lazy, t3.good_match = A2[t3.level].good_length, t3.nice_match = A2[t3.level].nice_length, t3.max_chain_length = A2[t3.level].max_chain, t3.strstart = 0, t3.block_start = 0, t3.lookahead = 0, t3.insert = 0, t3.match_length = t3.prev_length = m - 1, t3.match_available = 0, t3.ins_h = 0), i3;
        }
        function z(e3, t3, i3, A3, r3, a2) {
          if (!e3)
            return c;
          var o2 = 1;
          if (-1 === t3 && (t3 = 6), A3 < 0 ? (o2 = 0, A3 = -A3) : A3 > 15 && (o2 = 2, A3 -= 16), r3 < 1 || r3 > 9 || i3 !== h || A3 < 8 || A3 > 15 || t3 < 0 || t3 > 9 || a2 < 0 || a2 > 4)
            return _(e3, c);
          8 === A3 && (A3 = 9);
          var n2 = new M();
          return e3.state = n2, n2.strm = e3, n2.wrap = o2, n2.gzhead = null, n2.w_bits = A3, n2.w_size = 1 << n2.w_bits, n2.w_mask = n2.w_size - 1, n2.hash_bits = r3 + 7, n2.hash_size = 1 << n2.hash_bits, n2.hash_mask = n2.hash_size - 1, n2.hash_shift = ~~((n2.hash_bits + m - 1) / m), n2.window = new s2.Buf8(2 * n2.w_size), n2.head = new s2.Buf16(n2.hash_size), n2.prev = new s2.Buf16(n2.w_size), n2.lit_bufsize = 1 << r3 + 6, n2.pending_buf_size = 4 * n2.lit_bufsize, n2.pending_buf = new s2.Buf8(n2.pending_buf_size), n2.d_buf = 1 * n2.lit_bufsize, n2.l_buf = 3 * n2.lit_bufsize, n2.level = t3, n2.strategy = a2, n2.method = i3, O(e3);
        }
        A2 = [new j(0, 0, 0, 0, function(e3, t3) {
          var i3 = 65535;
          for (i3 > e3.pending_buf_size - 5 && (i3 = e3.pending_buf_size - 5); ; ) {
            if (e3.lookahead <= 1) {
              if (F(e3), 0 === e3.lookahead && t3 === l)
                return 1;
              if (0 === e3.lookahead)
                break;
            }
            e3.strstart += e3.lookahead, e3.lookahead = 0;
            var A3 = e3.block_start + i3;
            if ((0 === e3.strstart || e3.strstart >= A3) && (e3.lookahead = e3.strstart - A3, e3.strstart = A3, k(e3, false), 0 === e3.strm.avail_out))
              return 1;
            if (e3.strstart - e3.block_start >= e3.w_size - E && (k(e3, false), 0 === e3.strm.avail_out))
              return 1;
          }
          return e3.insert = 0, 4 === t3 ? (k(e3, true), 0 === e3.strm.avail_out ? 3 : 4) : (e3.strstart > e3.block_start && (k(e3, false), e3.strm.avail_out), 1);
        }), new j(4, 4, 8, 4, S), new j(4, 5, 16, 8, S), new j(4, 6, 32, 32, S), new j(4, 4, 16, 16, G), new j(8, 16, 32, 32, G), new j(8, 16, 128, 128, G), new j(8, 32, 128, 256, G), new j(32, 128, 258, 1024, G), new j(32, 258, 258, 4096, G)], t2.deflateInit = function(e3, t3) {
          return z(e3, t3, h, 15, 8, 0);
        }, t2.deflateInit2 = z, t2.deflateReset = O, t2.deflateResetKeep = R, t2.deflateSetHeader = function(e3, t3) {
          return e3 && e3.state ? 2 !== e3.state.wrap ? c : (e3.state.gzhead = t3, d) : c;
        }, t2.deflate = function(e3, t3) {
          var i3, s3, a2, n2;
          if (!e3 || !e3.state || t3 > 5 || t3 < 0)
            return e3 ? _(e3, c) : c;
          if (s3 = e3.state, !e3.output || !e3.input && 0 !== e3.avail_in || s3.status === b && 4 !== t3)
            return _(e3, 0 === e3.avail_out ? -5 : c);
          if (s3.strm = e3, i3 = s3.last_flush, s3.last_flush = t3, s3.status === y)
            if (2 === s3.wrap)
              e3.adler = 0, D(s3, 31), D(s3, 139), D(s3, 8), s3.gzhead ? (D(s3, (s3.gzhead.text ? 1 : 0) + (s3.gzhead.hcrc ? 2 : 0) + (s3.gzhead.extra ? 4 : 0) + (s3.gzhead.name ? 8 : 0) + (s3.gzhead.comment ? 16 : 0)), D(s3, 255 & s3.gzhead.time), D(s3, s3.gzhead.time >> 8 & 255), D(s3, s3.gzhead.time >> 16 & 255), D(s3, s3.gzhead.time >> 24 & 255), D(s3, 9 === s3.level ? 2 : s3.strategy >= 2 || s3.level < 2 ? 4 : 0), D(s3, 255 & s3.gzhead.os), s3.gzhead.extra && s3.gzhead.extra.length && (D(s3, 255 & s3.gzhead.extra.length), D(s3, s3.gzhead.extra.length >> 8 & 255)), s3.gzhead.hcrc && (e3.adler = o(e3.adler, s3.pending_buf, s3.pending, 0)), s3.gzindex = 0, s3.status = 69) : (D(s3, 0), D(s3, 0), D(s3, 0), D(s3, 0), D(s3, 0), D(s3, 9 === s3.level ? 2 : s3.strategy >= 2 || s3.level < 2 ? 4 : 0), D(s3, 3), s3.status = w);
            else {
              var g2 = h + (s3.w_bits - 8 << 4) << 8;
              g2 |= (s3.strategy >= 2 || s3.level < 2 ? 0 : s3.level < 6 ? 1 : 6 === s3.level ? 2 : 3) << 6, 0 !== s3.strstart && (g2 |= 32), g2 += 31 - g2 % 31, s3.status = w, L(s3, g2), 0 !== s3.strstart && (L(s3, e3.adler >>> 16), L(s3, 65535 & e3.adler)), e3.adler = 1;
            }
          if (69 === s3.status)
            if (s3.gzhead.extra) {
              for (a2 = s3.pending; s3.gzindex < (65535 & s3.gzhead.extra.length) && (s3.pending !== s3.pending_buf_size || (s3.gzhead.hcrc && s3.pending > a2 && (e3.adler = o(e3.adler, s3.pending_buf, s3.pending - a2, a2)), T(e3), a2 = s3.pending, s3.pending !== s3.pending_buf_size)); )
                D(s3, 255 & s3.gzhead.extra[s3.gzindex]), s3.gzindex++;
              s3.gzhead.hcrc && s3.pending > a2 && (e3.adler = o(e3.adler, s3.pending_buf, s3.pending - a2, a2)), s3.gzindex === s3.gzhead.extra.length && (s3.gzindex = 0, s3.status = 73);
            } else
              s3.status = 73;
          if (73 === s3.status)
            if (s3.gzhead.name) {
              a2 = s3.pending;
              do {
                if (s3.pending === s3.pending_buf_size && (s3.gzhead.hcrc && s3.pending > a2 && (e3.adler = o(e3.adler, s3.pending_buf, s3.pending - a2, a2)), T(e3), a2 = s3.pending, s3.pending === s3.pending_buf_size)) {
                  n2 = 1;
                  break;
                }
                n2 = s3.gzindex < s3.gzhead.name.length ? 255 & s3.gzhead.name.charCodeAt(s3.gzindex++) : 0, D(s3, n2);
              } while (0 !== n2);
              s3.gzhead.hcrc && s3.pending > a2 && (e3.adler = o(e3.adler, s3.pending_buf, s3.pending - a2, a2)), 0 === n2 && (s3.gzindex = 0, s3.status = 91);
            } else
              s3.status = 91;
          if (91 === s3.status)
            if (s3.gzhead.comment) {
              a2 = s3.pending;
              do {
                if (s3.pending === s3.pending_buf_size && (s3.gzhead.hcrc && s3.pending > a2 && (e3.adler = o(e3.adler, s3.pending_buf, s3.pending - a2, a2)), T(e3), a2 = s3.pending, s3.pending === s3.pending_buf_size)) {
                  n2 = 1;
                  break;
                }
                n2 = s3.gzindex < s3.gzhead.comment.length ? 255 & s3.gzhead.comment.charCodeAt(s3.gzindex++) : 0, D(s3, n2);
              } while (0 !== n2);
              s3.gzhead.hcrc && s3.pending > a2 && (e3.adler = o(e3.adler, s3.pending_buf, s3.pending - a2, a2)), 0 === n2 && (s3.status = Q);
            } else
              s3.status = Q;
          if (s3.status === Q && (s3.gzhead.hcrc ? (s3.pending + 2 > s3.pending_buf_size && T(e3), s3.pending + 2 <= s3.pending_buf_size && (D(s3, 255 & e3.adler), D(s3, e3.adler >> 8 & 255), e3.adler = 0, s3.status = w)) : s3.status = w), 0 !== s3.pending) {
            if (T(e3), 0 === e3.avail_out)
              return s3.last_flush = -1, d;
          } else if (0 === e3.avail_in && v(t3) <= v(i3) && 4 !== t3)
            return _(e3, -5);
          if (s3.status === b && 0 !== e3.avail_in)
            return _(e3, -5);
          if (0 !== e3.avail_in || 0 !== s3.lookahead || t3 !== l && s3.status !== b) {
            var u2 = 2 === s3.strategy ? function(e4, t4) {
              for (var i4; ; ) {
                if (0 === e4.lookahead && (F(e4), 0 === e4.lookahead)) {
                  if (t4 === l)
                    return 1;
                  break;
                }
                if (e4.match_length = 0, i4 = r2._tr_tally(e4, 0, e4.window[e4.strstart]), e4.lookahead--, e4.strstart++, i4 && (k(e4, false), 0 === e4.strm.avail_out))
                  return 1;
              }
              return e4.insert = 0, 4 === t4 ? (k(e4, true), 0 === e4.strm.avail_out ? 3 : 4) : e4.last_lit && (k(e4, false), 0 === e4.strm.avail_out) ? 1 : 2;
            }(s3, t3) : 3 === s3.strategy ? function(e4, t4) {
              for (var i4, A3, s4, a3, o2 = e4.window; ; ) {
                if (e4.lookahead <= B) {
                  if (F(e4), e4.lookahead <= B && t4 === l)
                    return 1;
                  if (0 === e4.lookahead)
                    break;
                }
                if (e4.match_length = 0, e4.lookahead >= m && e4.strstart > 0 && (A3 = o2[s4 = e4.strstart - 1]) === o2[++s4] && A3 === o2[++s4] && A3 === o2[++s4]) {
                  a3 = e4.strstart + B;
                  do {
                  } while (A3 === o2[++s4] && A3 === o2[++s4] && A3 === o2[++s4] && A3 === o2[++s4] && A3 === o2[++s4] && A3 === o2[++s4] && A3 === o2[++s4] && A3 === o2[++s4] && s4 < a3);
                  e4.match_length = B - (a3 - s4), e4.match_length > e4.lookahead && (e4.match_length = e4.lookahead);
                }
                if (e4.match_length >= m ? (i4 = r2._tr_tally(e4, 1, e4.match_length - m), e4.lookahead -= e4.match_length, e4.strstart += e4.match_length, e4.match_length = 0) : (i4 = r2._tr_tally(e4, 0, e4.window[e4.strstart]), e4.lookahead--, e4.strstart++), i4 && (k(e4, false), 0 === e4.strm.avail_out))
                  return 1;
              }
              return e4.insert = 0, 4 === t4 ? (k(e4, true), 0 === e4.strm.avail_out ? 3 : 4) : e4.last_lit && (k(e4, false), 0 === e4.strm.avail_out) ? 1 : 2;
            }(s3, t3) : A2[s3.level].func(s3, t3);
            if (3 !== u2 && 4 !== u2 || (s3.status = b), 1 === u2 || 3 === u2)
              return 0 === e3.avail_out && (s3.last_flush = -1), d;
            if (2 === u2 && (1 === t3 ? r2._tr_align(s3) : 5 !== t3 && (r2._tr_stored_block(s3, 0, 0, false), 3 === t3 && (x(s3.head), 0 === s3.lookahead && (s3.strstart = 0, s3.block_start = 0, s3.insert = 0))), T(e3), 0 === e3.avail_out))
              return s3.last_flush = -1, d;
          }
          return 4 !== t3 ? d : s3.wrap <= 0 ? 1 : (2 === s3.wrap ? (D(s3, 255 & e3.adler), D(s3, e3.adler >> 8 & 255), D(s3, e3.adler >> 16 & 255), D(s3, e3.adler >> 24 & 255), D(s3, 255 & e3.total_in), D(s3, e3.total_in >> 8 & 255), D(s3, e3.total_in >> 16 & 255), D(s3, e3.total_in >> 24 & 255)) : (L(s3, e3.adler >>> 16), L(s3, 65535 & e3.adler)), T(e3), s3.wrap > 0 && (s3.wrap = -s3.wrap), 0 !== s3.pending ? d : 1);
        }, t2.deflateEnd = function(e3) {
          var t3;
          return e3 && e3.state ? (t3 = e3.state.status) !== y && 69 !== t3 && 73 !== t3 && 91 !== t3 && t3 !== Q && t3 !== w && t3 !== b ? _(e3, c) : (e3.state = null, t3 === w ? _(e3, -3) : d) : c;
        }, t2.deflateSetDictionary = function(e3, t3) {
          var i3, A3, r3, o2, n2, l2, g2, h2, u2 = t3.length;
          if (!e3 || !e3.state)
            return c;
          if (2 === (o2 = (i3 = e3.state).wrap) || 1 === o2 && i3.status !== y || i3.lookahead)
            return c;
          for (1 === o2 && (e3.adler = a(e3.adler, t3, u2, 0)), i3.wrap = 0, u2 >= i3.w_size && (0 === o2 && (x(i3.head), i3.strstart = 0, i3.block_start = 0, i3.insert = 0), h2 = new s2.Buf8(i3.w_size), s2.arraySet(h2, t3, u2 - i3.w_size, i3.w_size, 0), t3 = h2, u2 = i3.w_size), n2 = e3.avail_in, l2 = e3.next_in, g2 = e3.input, e3.avail_in = u2, e3.next_in = 0, e3.input = t3, F(i3); i3.lookahead >= m; ) {
            A3 = i3.strstart, r3 = i3.lookahead - (m - 1);
            do {
              i3.ins_h = (i3.ins_h << i3.hash_shift ^ i3.window[A3 + m - 1]) & i3.hash_mask, i3.prev[A3 & i3.w_mask] = i3.head[i3.ins_h], i3.head[i3.ins_h] = A3, A3++;
            } while (--r3);
            i3.strstart = A3, i3.lookahead = m - 1, F(i3);
          }
          return i3.strstart += i3.lookahead, i3.block_start = i3.strstart, i3.insert = i3.lookahead, i3.lookahead = 0, i3.match_length = i3.prev_length = m - 1, i3.match_available = 0, e3.next_in = l2, e3.input = g2, e3.avail_in = n2, i3.wrap = o2, d;
        }, t2.deflateInfo = "pako deflate (from Nodeca project)";
      }, "./node_modules/pako/lib/zlib/gzheader.js": (e2) => {
        "use strict";
        e2.exports = function() {
          this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
        };
      }, "./node_modules/pako/lib/zlib/inffast.js": (e2) => {
        "use strict";
        e2.exports = function(e3, t2) {
          var i2, A2, s2, r2, a, o, n, l, d, c, g, h, u, p, I, f, C, m, B, E, y, Q, w, b, _;
          i2 = e3.state, A2 = e3.next_in, b = e3.input, s2 = A2 + (e3.avail_in - 5), r2 = e3.next_out, _ = e3.output, a = r2 - (t2 - e3.avail_out), o = r2 + (e3.avail_out - 257), n = i2.dmax, l = i2.wsize, d = i2.whave, c = i2.wnext, g = i2.window, h = i2.hold, u = i2.bits, p = i2.lencode, I = i2.distcode, f = (1 << i2.lenbits) - 1, C = (1 << i2.distbits) - 1;
          e:
            do {
              u < 15 && (h += b[A2++] << u, u += 8, h += b[A2++] << u, u += 8), m = p[h & f];
              t:
                for (; ; ) {
                  if (h >>>= B = m >>> 24, u -= B, 0 == (B = m >>> 16 & 255))
                    _[r2++] = 65535 & m;
                  else {
                    if (!(16 & B)) {
                      if (0 == (64 & B)) {
                        m = p[(65535 & m) + (h & (1 << B) - 1)];
                        continue t;
                      }
                      if (32 & B) {
                        i2.mode = 12;
                        break e;
                      }
                      e3.msg = "invalid literal/length code", i2.mode = 30;
                      break e;
                    }
                    E = 65535 & m, (B &= 15) && (u < B && (h += b[A2++] << u, u += 8), E += h & (1 << B) - 1, h >>>= B, u -= B), u < 15 && (h += b[A2++] << u, u += 8, h += b[A2++] << u, u += 8), m = I[h & C];
                    i:
                      for (; ; ) {
                        if (h >>>= B = m >>> 24, u -= B, !(16 & (B = m >>> 16 & 255))) {
                          if (0 == (64 & B)) {
                            m = I[(65535 & m) + (h & (1 << B) - 1)];
                            continue i;
                          }
                          e3.msg = "invalid distance code", i2.mode = 30;
                          break e;
                        }
                        if (y = 65535 & m, u < (B &= 15) && (h += b[A2++] << u, (u += 8) < B && (h += b[A2++] << u, u += 8)), (y += h & (1 << B) - 1) > n) {
                          e3.msg = "invalid distance too far back", i2.mode = 30;
                          break e;
                        }
                        if (h >>>= B, u -= B, y > (B = r2 - a)) {
                          if ((B = y - B) > d && i2.sane) {
                            e3.msg = "invalid distance too far back", i2.mode = 30;
                            break e;
                          }
                          if (Q = 0, w = g, 0 === c) {
                            if (Q += l - B, B < E) {
                              E -= B;
                              do {
                                _[r2++] = g[Q++];
                              } while (--B);
                              Q = r2 - y, w = _;
                            }
                          } else if (c < B) {
                            if (Q += l + c - B, (B -= c) < E) {
                              E -= B;
                              do {
                                _[r2++] = g[Q++];
                              } while (--B);
                              if (Q = 0, c < E) {
                                E -= B = c;
                                do {
                                  _[r2++] = g[Q++];
                                } while (--B);
                                Q = r2 - y, w = _;
                              }
                            }
                          } else if (Q += c - B, B < E) {
                            E -= B;
                            do {
                              _[r2++] = g[Q++];
                            } while (--B);
                            Q = r2 - y, w = _;
                          }
                          for (; E > 2; )
                            _[r2++] = w[Q++], _[r2++] = w[Q++], _[r2++] = w[Q++], E -= 3;
                          E && (_[r2++] = w[Q++], E > 1 && (_[r2++] = w[Q++]));
                        } else {
                          Q = r2 - y;
                          do {
                            _[r2++] = _[Q++], _[r2++] = _[Q++], _[r2++] = _[Q++], E -= 3;
                          } while (E > 2);
                          E && (_[r2++] = _[Q++], E > 1 && (_[r2++] = _[Q++]));
                        }
                        break;
                      }
                  }
                  break;
                }
            } while (A2 < s2 && r2 < o);
          A2 -= E = u >> 3, h &= (1 << (u -= E << 3)) - 1, e3.next_in = A2, e3.next_out = r2, e3.avail_in = A2 < s2 ? s2 - A2 + 5 : 5 - (A2 - s2), e3.avail_out = r2 < o ? o - r2 + 257 : 257 - (r2 - o), i2.hold = h, i2.bits = u;
        };
      }, "./node_modules/pako/lib/zlib/inflate.js": (e2, t2, i2) => {
        "use strict";
        var A2 = i2("./node_modules/pako/lib/utils/common.js"), s2 = i2("./node_modules/pako/lib/zlib/adler32.js"), r2 = i2("./node_modules/pako/lib/zlib/crc32.js"), a = i2("./node_modules/pako/lib/zlib/inffast.js"), o = i2("./node_modules/pako/lib/zlib/inftrees.js"), n = 0, l = -2, d = 1, c = 12, g = 30, h = 852, u = 592;
        function p(e3) {
          return (e3 >>> 24 & 255) + (e3 >>> 8 & 65280) + ((65280 & e3) << 8) + ((255 & e3) << 24);
        }
        function I() {
          this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new A2.Buf16(320), this.work = new A2.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
        }
        function f(e3) {
          var t3;
          return e3 && e3.state ? (t3 = e3.state, e3.total_in = e3.total_out = t3.total = 0, e3.msg = "", t3.wrap && (e3.adler = 1 & t3.wrap), t3.mode = d, t3.last = 0, t3.havedict = 0, t3.dmax = 32768, t3.head = null, t3.hold = 0, t3.bits = 0, t3.lencode = t3.lendyn = new A2.Buf32(h), t3.distcode = t3.distdyn = new A2.Buf32(u), t3.sane = 1, t3.back = -1, n) : l;
        }
        function C(e3) {
          var t3;
          return e3 && e3.state ? ((t3 = e3.state).wsize = 0, t3.whave = 0, t3.wnext = 0, f(e3)) : l;
        }
        function m(e3, t3) {
          var i3, A3;
          return e3 && e3.state ? (A3 = e3.state, t3 < 0 ? (i3 = 0, t3 = -t3) : (i3 = 1 + (t3 >> 4), t3 < 48 && (t3 &= 15)), t3 && (t3 < 8 || t3 > 15) ? l : (null !== A3.window && A3.wbits !== t3 && (A3.window = null), A3.wrap = i3, A3.wbits = t3, C(e3))) : l;
        }
        function B(e3, t3) {
          var i3, A3;
          return e3 ? (A3 = new I(), e3.state = A3, A3.window = null, (i3 = m(e3, t3)) !== n && (e3.state = null), i3) : l;
        }
        var E, y, Q = true;
        function w(e3) {
          if (Q) {
            var t3;
            for (E = new A2.Buf32(512), y = new A2.Buf32(32), t3 = 0; t3 < 144; )
              e3.lens[t3++] = 8;
            for (; t3 < 256; )
              e3.lens[t3++] = 9;
            for (; t3 < 280; )
              e3.lens[t3++] = 7;
            for (; t3 < 288; )
              e3.lens[t3++] = 8;
            for (o(1, e3.lens, 0, 288, E, 0, e3.work, { bits: 9 }), t3 = 0; t3 < 32; )
              e3.lens[t3++] = 5;
            o(2, e3.lens, 0, 32, y, 0, e3.work, { bits: 5 }), Q = false;
          }
          e3.lencode = E, e3.lenbits = 9, e3.distcode = y, e3.distbits = 5;
        }
        function b(e3, t3, i3, s3) {
          var r3, a2 = e3.state;
          return null === a2.window && (a2.wsize = 1 << a2.wbits, a2.wnext = 0, a2.whave = 0, a2.window = new A2.Buf8(a2.wsize)), s3 >= a2.wsize ? (A2.arraySet(a2.window, t3, i3 - a2.wsize, a2.wsize, 0), a2.wnext = 0, a2.whave = a2.wsize) : ((r3 = a2.wsize - a2.wnext) > s3 && (r3 = s3), A2.arraySet(a2.window, t3, i3 - s3, r3, a2.wnext), (s3 -= r3) ? (A2.arraySet(a2.window, t3, i3 - s3, s3, 0), a2.wnext = s3, a2.whave = a2.wsize) : (a2.wnext += r3, a2.wnext === a2.wsize && (a2.wnext = 0), a2.whave < a2.wsize && (a2.whave += r3))), 0;
        }
        t2.inflateReset = C, t2.inflateReset2 = m, t2.inflateResetKeep = f, t2.inflateInit = function(e3) {
          return B(e3, 15);
        }, t2.inflateInit2 = B, t2.inflate = function(e3, t3) {
          var i3, h2, u2, I2, f2, C2, m2, B2, E2, y2, Q2, _, v, x, T, k, D, L, N, F, S, G, j, M, R = 0, O = new A2.Buf8(4), z = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
          if (!e3 || !e3.state || !e3.output || !e3.input && 0 !== e3.avail_in)
            return l;
          (i3 = e3.state).mode === c && (i3.mode = 13), f2 = e3.next_out, u2 = e3.output, m2 = e3.avail_out, I2 = e3.next_in, h2 = e3.input, C2 = e3.avail_in, B2 = i3.hold, E2 = i3.bits, y2 = C2, Q2 = m2, G = n;
          e:
            for (; ; )
              switch (i3.mode) {
                case d:
                  if (0 === i3.wrap) {
                    i3.mode = 13;
                    break;
                  }
                  for (; E2 < 16; ) {
                    if (0 === C2)
                      break e;
                    C2--, B2 += h2[I2++] << E2, E2 += 8;
                  }
                  if (2 & i3.wrap && 35615 === B2) {
                    i3.check = 0, O[0] = 255 & B2, O[1] = B2 >>> 8 & 255, i3.check = r2(i3.check, O, 2, 0), B2 = 0, E2 = 0, i3.mode = 2;
                    break;
                  }
                  if (i3.flags = 0, i3.head && (i3.head.done = false), !(1 & i3.wrap) || (((255 & B2) << 8) + (B2 >> 8)) % 31) {
                    e3.msg = "incorrect header check", i3.mode = g;
                    break;
                  }
                  if (8 != (15 & B2)) {
                    e3.msg = "unknown compression method", i3.mode = g;
                    break;
                  }
                  if (E2 -= 4, S = 8 + (15 & (B2 >>>= 4)), 0 === i3.wbits)
                    i3.wbits = S;
                  else if (S > i3.wbits) {
                    e3.msg = "invalid window size", i3.mode = g;
                    break;
                  }
                  i3.dmax = 1 << S, e3.adler = i3.check = 1, i3.mode = 512 & B2 ? 10 : c, B2 = 0, E2 = 0;
                  break;
                case 2:
                  for (; E2 < 16; ) {
                    if (0 === C2)
                      break e;
                    C2--, B2 += h2[I2++] << E2, E2 += 8;
                  }
                  if (i3.flags = B2, 8 != (255 & i3.flags)) {
                    e3.msg = "unknown compression method", i3.mode = g;
                    break;
                  }
                  if (57344 & i3.flags) {
                    e3.msg = "unknown header flags set", i3.mode = g;
                    break;
                  }
                  i3.head && (i3.head.text = B2 >> 8 & 1), 512 & i3.flags && (O[0] = 255 & B2, O[1] = B2 >>> 8 & 255, i3.check = r2(i3.check, O, 2, 0)), B2 = 0, E2 = 0, i3.mode = 3;
                case 3:
                  for (; E2 < 32; ) {
                    if (0 === C2)
                      break e;
                    C2--, B2 += h2[I2++] << E2, E2 += 8;
                  }
                  i3.head && (i3.head.time = B2), 512 & i3.flags && (O[0] = 255 & B2, O[1] = B2 >>> 8 & 255, O[2] = B2 >>> 16 & 255, O[3] = B2 >>> 24 & 255, i3.check = r2(i3.check, O, 4, 0)), B2 = 0, E2 = 0, i3.mode = 4;
                case 4:
                  for (; E2 < 16; ) {
                    if (0 === C2)
                      break e;
                    C2--, B2 += h2[I2++] << E2, E2 += 8;
                  }
                  i3.head && (i3.head.xflags = 255 & B2, i3.head.os = B2 >> 8), 512 & i3.flags && (O[0] = 255 & B2, O[1] = B2 >>> 8 & 255, i3.check = r2(i3.check, O, 2, 0)), B2 = 0, E2 = 0, i3.mode = 5;
                case 5:
                  if (1024 & i3.flags) {
                    for (; E2 < 16; ) {
                      if (0 === C2)
                        break e;
                      C2--, B2 += h2[I2++] << E2, E2 += 8;
                    }
                    i3.length = B2, i3.head && (i3.head.extra_len = B2), 512 & i3.flags && (O[0] = 255 & B2, O[1] = B2 >>> 8 & 255, i3.check = r2(i3.check, O, 2, 0)), B2 = 0, E2 = 0;
                  } else
                    i3.head && (i3.head.extra = null);
                  i3.mode = 6;
                case 6:
                  if (1024 & i3.flags && ((_ = i3.length) > C2 && (_ = C2), _ && (i3.head && (S = i3.head.extra_len - i3.length, i3.head.extra || (i3.head.extra = new Array(i3.head.extra_len)), A2.arraySet(i3.head.extra, h2, I2, _, S)), 512 & i3.flags && (i3.check = r2(i3.check, h2, _, I2)), C2 -= _, I2 += _, i3.length -= _), i3.length))
                    break e;
                  i3.length = 0, i3.mode = 7;
                case 7:
                  if (2048 & i3.flags) {
                    if (0 === C2)
                      break e;
                    _ = 0;
                    do {
                      S = h2[I2 + _++], i3.head && S && i3.length < 65536 && (i3.head.name += String.fromCharCode(S));
                    } while (S && _ < C2);
                    if (512 & i3.flags && (i3.check = r2(i3.check, h2, _, I2)), C2 -= _, I2 += _, S)
                      break e;
                  } else
                    i3.head && (i3.head.name = null);
                  i3.length = 0, i3.mode = 8;
                case 8:
                  if (4096 & i3.flags) {
                    if (0 === C2)
                      break e;
                    _ = 0;
                    do {
                      S = h2[I2 + _++], i3.head && S && i3.length < 65536 && (i3.head.comment += String.fromCharCode(S));
                    } while (S && _ < C2);
                    if (512 & i3.flags && (i3.check = r2(i3.check, h2, _, I2)), C2 -= _, I2 += _, S)
                      break e;
                  } else
                    i3.head && (i3.head.comment = null);
                  i3.mode = 9;
                case 9:
                  if (512 & i3.flags) {
                    for (; E2 < 16; ) {
                      if (0 === C2)
                        break e;
                      C2--, B2 += h2[I2++] << E2, E2 += 8;
                    }
                    if (B2 !== (65535 & i3.check)) {
                      e3.msg = "header crc mismatch", i3.mode = g;
                      break;
                    }
                    B2 = 0, E2 = 0;
                  }
                  i3.head && (i3.head.hcrc = i3.flags >> 9 & 1, i3.head.done = true), e3.adler = i3.check = 0, i3.mode = c;
                  break;
                case 10:
                  for (; E2 < 32; ) {
                    if (0 === C2)
                      break e;
                    C2--, B2 += h2[I2++] << E2, E2 += 8;
                  }
                  e3.adler = i3.check = p(B2), B2 = 0, E2 = 0, i3.mode = 11;
                case 11:
                  if (0 === i3.havedict)
                    return e3.next_out = f2, e3.avail_out = m2, e3.next_in = I2, e3.avail_in = C2, i3.hold = B2, i3.bits = E2, 2;
                  e3.adler = i3.check = 1, i3.mode = c;
                case c:
                  if (5 === t3 || 6 === t3)
                    break e;
                case 13:
                  if (i3.last) {
                    B2 >>>= 7 & E2, E2 -= 7 & E2, i3.mode = 27;
                    break;
                  }
                  for (; E2 < 3; ) {
                    if (0 === C2)
                      break e;
                    C2--, B2 += h2[I2++] << E2, E2 += 8;
                  }
                  switch (i3.last = 1 & B2, E2 -= 1, 3 & (B2 >>>= 1)) {
                    case 0:
                      i3.mode = 14;
                      break;
                    case 1:
                      if (w(i3), i3.mode = 20, 6 === t3) {
                        B2 >>>= 2, E2 -= 2;
                        break e;
                      }
                      break;
                    case 2:
                      i3.mode = 17;
                      break;
                    case 3:
                      e3.msg = "invalid block type", i3.mode = g;
                  }
                  B2 >>>= 2, E2 -= 2;
                  break;
                case 14:
                  for (B2 >>>= 7 & E2, E2 -= 7 & E2; E2 < 32; ) {
                    if (0 === C2)
                      break e;
                    C2--, B2 += h2[I2++] << E2, E2 += 8;
                  }
                  if ((65535 & B2) != (B2 >>> 16 ^ 65535)) {
                    e3.msg = "invalid stored block lengths", i3.mode = g;
                    break;
                  }
                  if (i3.length = 65535 & B2, B2 = 0, E2 = 0, i3.mode = 15, 6 === t3)
                    break e;
                case 15:
                  i3.mode = 16;
                case 16:
                  if (_ = i3.length) {
                    if (_ > C2 && (_ = C2), _ > m2 && (_ = m2), 0 === _)
                      break e;
                    A2.arraySet(u2, h2, I2, _, f2), C2 -= _, I2 += _, m2 -= _, f2 += _, i3.length -= _;
                    break;
                  }
                  i3.mode = c;
                  break;
                case 17:
                  for (; E2 < 14; ) {
                    if (0 === C2)
                      break e;
                    C2--, B2 += h2[I2++] << E2, E2 += 8;
                  }
                  if (i3.nlen = 257 + (31 & B2), B2 >>>= 5, E2 -= 5, i3.ndist = 1 + (31 & B2), B2 >>>= 5, E2 -= 5, i3.ncode = 4 + (15 & B2), B2 >>>= 4, E2 -= 4, i3.nlen > 286 || i3.ndist > 30) {
                    e3.msg = "too many length or distance symbols", i3.mode = g;
                    break;
                  }
                  i3.have = 0, i3.mode = 18;
                case 18:
                  for (; i3.have < i3.ncode; ) {
                    for (; E2 < 3; ) {
                      if (0 === C2)
                        break e;
                      C2--, B2 += h2[I2++] << E2, E2 += 8;
                    }
                    i3.lens[z[i3.have++]] = 7 & B2, B2 >>>= 3, E2 -= 3;
                  }
                  for (; i3.have < 19; )
                    i3.lens[z[i3.have++]] = 0;
                  if (i3.lencode = i3.lendyn, i3.lenbits = 7, j = { bits: i3.lenbits }, G = o(0, i3.lens, 0, 19, i3.lencode, 0, i3.work, j), i3.lenbits = j.bits, G) {
                    e3.msg = "invalid code lengths set", i3.mode = g;
                    break;
                  }
                  i3.have = 0, i3.mode = 19;
                case 19:
                  for (; i3.have < i3.nlen + i3.ndist; ) {
                    for (; k = (R = i3.lencode[B2 & (1 << i3.lenbits) - 1]) >>> 16 & 255, D = 65535 & R, !((T = R >>> 24) <= E2); ) {
                      if (0 === C2)
                        break e;
                      C2--, B2 += h2[I2++] << E2, E2 += 8;
                    }
                    if (D < 16)
                      B2 >>>= T, E2 -= T, i3.lens[i3.have++] = D;
                    else {
                      if (16 === D) {
                        for (M = T + 2; E2 < M; ) {
                          if (0 === C2)
                            break e;
                          C2--, B2 += h2[I2++] << E2, E2 += 8;
                        }
                        if (B2 >>>= T, E2 -= T, 0 === i3.have) {
                          e3.msg = "invalid bit length repeat", i3.mode = g;
                          break;
                        }
                        S = i3.lens[i3.have - 1], _ = 3 + (3 & B2), B2 >>>= 2, E2 -= 2;
                      } else if (17 === D) {
                        for (M = T + 3; E2 < M; ) {
                          if (0 === C2)
                            break e;
                          C2--, B2 += h2[I2++] << E2, E2 += 8;
                        }
                        E2 -= T, S = 0, _ = 3 + (7 & (B2 >>>= T)), B2 >>>= 3, E2 -= 3;
                      } else {
                        for (M = T + 7; E2 < M; ) {
                          if (0 === C2)
                            break e;
                          C2--, B2 += h2[I2++] << E2, E2 += 8;
                        }
                        E2 -= T, S = 0, _ = 11 + (127 & (B2 >>>= T)), B2 >>>= 7, E2 -= 7;
                      }
                      if (i3.have + _ > i3.nlen + i3.ndist) {
                        e3.msg = "invalid bit length repeat", i3.mode = g;
                        break;
                      }
                      for (; _--; )
                        i3.lens[i3.have++] = S;
                    }
                  }
                  if (i3.mode === g)
                    break;
                  if (0 === i3.lens[256]) {
                    e3.msg = "invalid code -- missing end-of-block", i3.mode = g;
                    break;
                  }
                  if (i3.lenbits = 9, j = { bits: i3.lenbits }, G = o(1, i3.lens, 0, i3.nlen, i3.lencode, 0, i3.work, j), i3.lenbits = j.bits, G) {
                    e3.msg = "invalid literal/lengths set", i3.mode = g;
                    break;
                  }
                  if (i3.distbits = 6, i3.distcode = i3.distdyn, j = { bits: i3.distbits }, G = o(2, i3.lens, i3.nlen, i3.ndist, i3.distcode, 0, i3.work, j), i3.distbits = j.bits, G) {
                    e3.msg = "invalid distances set", i3.mode = g;
                    break;
                  }
                  if (i3.mode = 20, 6 === t3)
                    break e;
                case 20:
                  i3.mode = 21;
                case 21:
                  if (C2 >= 6 && m2 >= 258) {
                    e3.next_out = f2, e3.avail_out = m2, e3.next_in = I2, e3.avail_in = C2, i3.hold = B2, i3.bits = E2, a(e3, Q2), f2 = e3.next_out, u2 = e3.output, m2 = e3.avail_out, I2 = e3.next_in, h2 = e3.input, C2 = e3.avail_in, B2 = i3.hold, E2 = i3.bits, i3.mode === c && (i3.back = -1);
                    break;
                  }
                  for (i3.back = 0; k = (R = i3.lencode[B2 & (1 << i3.lenbits) - 1]) >>> 16 & 255, D = 65535 & R, !((T = R >>> 24) <= E2); ) {
                    if (0 === C2)
                      break e;
                    C2--, B2 += h2[I2++] << E2, E2 += 8;
                  }
                  if (k && 0 == (240 & k)) {
                    for (L = T, N = k, F = D; k = (R = i3.lencode[F + ((B2 & (1 << L + N) - 1) >> L)]) >>> 16 & 255, D = 65535 & R, !(L + (T = R >>> 24) <= E2); ) {
                      if (0 === C2)
                        break e;
                      C2--, B2 += h2[I2++] << E2, E2 += 8;
                    }
                    B2 >>>= L, E2 -= L, i3.back += L;
                  }
                  if (B2 >>>= T, E2 -= T, i3.back += T, i3.length = D, 0 === k) {
                    i3.mode = 26;
                    break;
                  }
                  if (32 & k) {
                    i3.back = -1, i3.mode = c;
                    break;
                  }
                  if (64 & k) {
                    e3.msg = "invalid literal/length code", i3.mode = g;
                    break;
                  }
                  i3.extra = 15 & k, i3.mode = 22;
                case 22:
                  if (i3.extra) {
                    for (M = i3.extra; E2 < M; ) {
                      if (0 === C2)
                        break e;
                      C2--, B2 += h2[I2++] << E2, E2 += 8;
                    }
                    i3.length += B2 & (1 << i3.extra) - 1, B2 >>>= i3.extra, E2 -= i3.extra, i3.back += i3.extra;
                  }
                  i3.was = i3.length, i3.mode = 23;
                case 23:
                  for (; k = (R = i3.distcode[B2 & (1 << i3.distbits) - 1]) >>> 16 & 255, D = 65535 & R, !((T = R >>> 24) <= E2); ) {
                    if (0 === C2)
                      break e;
                    C2--, B2 += h2[I2++] << E2, E2 += 8;
                  }
                  if (0 == (240 & k)) {
                    for (L = T, N = k, F = D; k = (R = i3.distcode[F + ((B2 & (1 << L + N) - 1) >> L)]) >>> 16 & 255, D = 65535 & R, !(L + (T = R >>> 24) <= E2); ) {
                      if (0 === C2)
                        break e;
                      C2--, B2 += h2[I2++] << E2, E2 += 8;
                    }
                    B2 >>>= L, E2 -= L, i3.back += L;
                  }
                  if (B2 >>>= T, E2 -= T, i3.back += T, 64 & k) {
                    e3.msg = "invalid distance code", i3.mode = g;
                    break;
                  }
                  i3.offset = D, i3.extra = 15 & k, i3.mode = 24;
                case 24:
                  if (i3.extra) {
                    for (M = i3.extra; E2 < M; ) {
                      if (0 === C2)
                        break e;
                      C2--, B2 += h2[I2++] << E2, E2 += 8;
                    }
                    i3.offset += B2 & (1 << i3.extra) - 1, B2 >>>= i3.extra, E2 -= i3.extra, i3.back += i3.extra;
                  }
                  if (i3.offset > i3.dmax) {
                    e3.msg = "invalid distance too far back", i3.mode = g;
                    break;
                  }
                  i3.mode = 25;
                case 25:
                  if (0 === m2)
                    break e;
                  if (_ = Q2 - m2, i3.offset > _) {
                    if ((_ = i3.offset - _) > i3.whave && i3.sane) {
                      e3.msg = "invalid distance too far back", i3.mode = g;
                      break;
                    }
                    _ > i3.wnext ? (_ -= i3.wnext, v = i3.wsize - _) : v = i3.wnext - _, _ > i3.length && (_ = i3.length), x = i3.window;
                  } else
                    x = u2, v = f2 - i3.offset, _ = i3.length;
                  _ > m2 && (_ = m2), m2 -= _, i3.length -= _;
                  do {
                    u2[f2++] = x[v++];
                  } while (--_);
                  0 === i3.length && (i3.mode = 21);
                  break;
                case 26:
                  if (0 === m2)
                    break e;
                  u2[f2++] = i3.length, m2--, i3.mode = 21;
                  break;
                case 27:
                  if (i3.wrap) {
                    for (; E2 < 32; ) {
                      if (0 === C2)
                        break e;
                      C2--, B2 |= h2[I2++] << E2, E2 += 8;
                    }
                    if (Q2 -= m2, e3.total_out += Q2, i3.total += Q2, Q2 && (e3.adler = i3.check = i3.flags ? r2(i3.check, u2, Q2, f2 - Q2) : s2(i3.check, u2, Q2, f2 - Q2)), Q2 = m2, (i3.flags ? B2 : p(B2)) !== i3.check) {
                      e3.msg = "incorrect data check", i3.mode = g;
                      break;
                    }
                    B2 = 0, E2 = 0;
                  }
                  i3.mode = 28;
                case 28:
                  if (i3.wrap && i3.flags) {
                    for (; E2 < 32; ) {
                      if (0 === C2)
                        break e;
                      C2--, B2 += h2[I2++] << E2, E2 += 8;
                    }
                    if (B2 !== (4294967295 & i3.total)) {
                      e3.msg = "incorrect length check", i3.mode = g;
                      break;
                    }
                    B2 = 0, E2 = 0;
                  }
                  i3.mode = 29;
                case 29:
                  G = 1;
                  break e;
                case g:
                  G = -3;
                  break e;
                case 31:
                  return -4;
                default:
                  return l;
              }
          return e3.next_out = f2, e3.avail_out = m2, e3.next_in = I2, e3.avail_in = C2, i3.hold = B2, i3.bits = E2, (i3.wsize || Q2 !== e3.avail_out && i3.mode < g && (i3.mode < 27 || 4 !== t3)) && b(e3, e3.output, e3.next_out, Q2 - e3.avail_out) ? (i3.mode = 31, -4) : (y2 -= e3.avail_in, Q2 -= e3.avail_out, e3.total_in += y2, e3.total_out += Q2, i3.total += Q2, i3.wrap && Q2 && (e3.adler = i3.check = i3.flags ? r2(i3.check, u2, Q2, e3.next_out - Q2) : s2(i3.check, u2, Q2, e3.next_out - Q2)), e3.data_type = i3.bits + (i3.last ? 64 : 0) + (i3.mode === c ? 128 : 0) + (20 === i3.mode || 15 === i3.mode ? 256 : 0), (0 === y2 && 0 === Q2 || 4 === t3) && G === n && (G = -5), G);
        }, t2.inflateEnd = function(e3) {
          if (!e3 || !e3.state)
            return l;
          var t3 = e3.state;
          return t3.window && (t3.window = null), e3.state = null, n;
        }, t2.inflateGetHeader = function(e3, t3) {
          var i3;
          return e3 && e3.state ? 0 == (2 & (i3 = e3.state).wrap) ? l : (i3.head = t3, t3.done = false, n) : l;
        }, t2.inflateSetDictionary = function(e3, t3) {
          var i3, A3 = t3.length;
          return e3 && e3.state ? 0 !== (i3 = e3.state).wrap && 11 !== i3.mode ? l : 11 === i3.mode && s2(1, t3, A3, 0) !== i3.check ? -3 : b(e3, t3, A3, A3) ? (i3.mode = 31, -4) : (i3.havedict = 1, n) : l;
        }, t2.inflateInfo = "pako inflate (from Nodeca project)";
      }, "./node_modules/pako/lib/zlib/inftrees.js": (e2, t2, i2) => {
        "use strict";
        var A2 = i2("./node_modules/pako/lib/utils/common.js"), s2 = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], r2 = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], a = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], o = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
        e2.exports = function(e3, t3, i3, n, l, d, c, g) {
          var h, u, p, I, f, C, m, B, E, y = g.bits, Q = 0, w = 0, b = 0, _ = 0, v = 0, x = 0, T = 0, k = 0, D = 0, L = 0, N = null, F = 0, S = new A2.Buf16(16), G = new A2.Buf16(16), j = null, M = 0;
          for (Q = 0; Q <= 15; Q++)
            S[Q] = 0;
          for (w = 0; w < n; w++)
            S[t3[i3 + w]]++;
          for (v = y, _ = 15; _ >= 1 && 0 === S[_]; _--)
            ;
          if (v > _ && (v = _), 0 === _)
            return l[d++] = 20971520, l[d++] = 20971520, g.bits = 1, 0;
          for (b = 1; b < _ && 0 === S[b]; b++)
            ;
          for (v < b && (v = b), k = 1, Q = 1; Q <= 15; Q++)
            if (k <<= 1, (k -= S[Q]) < 0)
              return -1;
          if (k > 0 && (0 === e3 || 1 !== _))
            return -1;
          for (G[1] = 0, Q = 1; Q < 15; Q++)
            G[Q + 1] = G[Q] + S[Q];
          for (w = 0; w < n; w++)
            0 !== t3[i3 + w] && (c[G[t3[i3 + w]]++] = w);
          if (0 === e3 ? (N = j = c, C = 19) : 1 === e3 ? (N = s2, F -= 257, j = r2, M -= 257, C = 256) : (N = a, j = o, C = -1), L = 0, w = 0, Q = b, f = d, x = v, T = 0, p = -1, I = (D = 1 << v) - 1, 1 === e3 && D > 852 || 2 === e3 && D > 592)
            return 1;
          for (; ; ) {
            m = Q - T, c[w] < C ? (B = 0, E = c[w]) : c[w] > C ? (B = j[M + c[w]], E = N[F + c[w]]) : (B = 96, E = 0), h = 1 << Q - T, b = u = 1 << x;
            do {
              l[f + (L >> T) + (u -= h)] = m << 24 | B << 16 | E | 0;
            } while (0 !== u);
            for (h = 1 << Q - 1; L & h; )
              h >>= 1;
            if (0 !== h ? (L &= h - 1, L += h) : L = 0, w++, 0 == --S[Q]) {
              if (Q === _)
                break;
              Q = t3[i3 + c[w]];
            }
            if (Q > v && (L & I) !== p) {
              for (0 === T && (T = v), f += b, k = 1 << (x = Q - T); x + T < _ && !((k -= S[x + T]) <= 0); )
                x++, k <<= 1;
              if (D += 1 << x, 1 === e3 && D > 852 || 2 === e3 && D > 592)
                return 1;
              l[p = L & I] = v << 24 | x << 16 | f - d | 0;
            }
          }
          return 0 !== L && (l[f + L] = Q - T << 24 | 64 << 16 | 0), g.bits = v, 0;
        };
      }, "./node_modules/pako/lib/zlib/messages.js": (e2) => {
        "use strict";
        e2.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
      }, "./node_modules/pako/lib/zlib/trees.js": (e2, t2, i2) => {
        "use strict";
        var A2 = i2("./node_modules/pako/lib/utils/common.js");
        function s2(e3) {
          for (var t3 = e3.length; --t3 >= 0; )
            e3[t3] = 0;
        }
        var r2 = 256, a = 286, o = 30, n = 15, l = 16, d = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], c = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], g = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], h = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], u = new Array(576);
        s2(u);
        var p = new Array(60);
        s2(p);
        var I = new Array(512);
        s2(I);
        var f = new Array(256);
        s2(f);
        var C = new Array(29);
        s2(C);
        var m, B, E, y = new Array(o);
        function Q(e3, t3, i3, A3, s3) {
          this.static_tree = e3, this.extra_bits = t3, this.extra_base = i3, this.elems = A3, this.max_length = s3, this.has_stree = e3 && e3.length;
        }
        function w(e3, t3) {
          this.dyn_tree = e3, this.max_code = 0, this.stat_desc = t3;
        }
        function b(e3) {
          return e3 < 256 ? I[e3] : I[256 + (e3 >>> 7)];
        }
        function _(e3, t3) {
          e3.pending_buf[e3.pending++] = 255 & t3, e3.pending_buf[e3.pending++] = t3 >>> 8 & 255;
        }
        function v(e3, t3, i3) {
          e3.bi_valid > l - i3 ? (e3.bi_buf |= t3 << e3.bi_valid & 65535, _(e3, e3.bi_buf), e3.bi_buf = t3 >> l - e3.bi_valid, e3.bi_valid += i3 - l) : (e3.bi_buf |= t3 << e3.bi_valid & 65535, e3.bi_valid += i3);
        }
        function x(e3, t3, i3) {
          v(e3, i3[2 * t3], i3[2 * t3 + 1]);
        }
        function T(e3, t3) {
          var i3 = 0;
          do {
            i3 |= 1 & e3, e3 >>>= 1, i3 <<= 1;
          } while (--t3 > 0);
          return i3 >>> 1;
        }
        function k(e3, t3, i3) {
          var A3, s3, r3 = new Array(n + 1), a2 = 0;
          for (A3 = 1; A3 <= n; A3++)
            r3[A3] = a2 = a2 + i3[A3 - 1] << 1;
          for (s3 = 0; s3 <= t3; s3++) {
            var o2 = e3[2 * s3 + 1];
            0 !== o2 && (e3[2 * s3] = T(r3[o2]++, o2));
          }
        }
        function D(e3) {
          var t3;
          for (t3 = 0; t3 < a; t3++)
            e3.dyn_ltree[2 * t3] = 0;
          for (t3 = 0; t3 < o; t3++)
            e3.dyn_dtree[2 * t3] = 0;
          for (t3 = 0; t3 < 19; t3++)
            e3.bl_tree[2 * t3] = 0;
          e3.dyn_ltree[512] = 1, e3.opt_len = e3.static_len = 0, e3.last_lit = e3.matches = 0;
        }
        function L(e3) {
          e3.bi_valid > 8 ? _(e3, e3.bi_buf) : e3.bi_valid > 0 && (e3.pending_buf[e3.pending++] = e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0;
        }
        function N(e3, t3, i3, A3) {
          var s3 = 2 * t3, r3 = 2 * i3;
          return e3[s3] < e3[r3] || e3[s3] === e3[r3] && A3[t3] <= A3[i3];
        }
        function F(e3, t3, i3) {
          for (var A3 = e3.heap[i3], s3 = i3 << 1; s3 <= e3.heap_len && (s3 < e3.heap_len && N(t3, e3.heap[s3 + 1], e3.heap[s3], e3.depth) && s3++, !N(t3, A3, e3.heap[s3], e3.depth)); )
            e3.heap[i3] = e3.heap[s3], i3 = s3, s3 <<= 1;
          e3.heap[i3] = A3;
        }
        function S(e3, t3, i3) {
          var A3, s3, a2, o2, n2 = 0;
          if (0 !== e3.last_lit)
            do {
              A3 = e3.pending_buf[e3.d_buf + 2 * n2] << 8 | e3.pending_buf[e3.d_buf + 2 * n2 + 1], s3 = e3.pending_buf[e3.l_buf + n2], n2++, 0 === A3 ? x(e3, s3, t3) : (x(e3, (a2 = f[s3]) + r2 + 1, t3), 0 !== (o2 = d[a2]) && v(e3, s3 -= C[a2], o2), x(e3, a2 = b(--A3), i3), 0 !== (o2 = c[a2]) && v(e3, A3 -= y[a2], o2));
            } while (n2 < e3.last_lit);
          x(e3, 256, t3);
        }
        function G(e3, t3) {
          var i3, A3, s3, r3 = t3.dyn_tree, a2 = t3.stat_desc.static_tree, o2 = t3.stat_desc.has_stree, l2 = t3.stat_desc.elems, d2 = -1;
          for (e3.heap_len = 0, e3.heap_max = 573, i3 = 0; i3 < l2; i3++)
            0 !== r3[2 * i3] ? (e3.heap[++e3.heap_len] = d2 = i3, e3.depth[i3] = 0) : r3[2 * i3 + 1] = 0;
          for (; e3.heap_len < 2; )
            r3[2 * (s3 = e3.heap[++e3.heap_len] = d2 < 2 ? ++d2 : 0)] = 1, e3.depth[s3] = 0, e3.opt_len--, o2 && (e3.static_len -= a2[2 * s3 + 1]);
          for (t3.max_code = d2, i3 = e3.heap_len >> 1; i3 >= 1; i3--)
            F(e3, r3, i3);
          s3 = l2;
          do {
            i3 = e3.heap[1], e3.heap[1] = e3.heap[e3.heap_len--], F(e3, r3, 1), A3 = e3.heap[1], e3.heap[--e3.heap_max] = i3, e3.heap[--e3.heap_max] = A3, r3[2 * s3] = r3[2 * i3] + r3[2 * A3], e3.depth[s3] = (e3.depth[i3] >= e3.depth[A3] ? e3.depth[i3] : e3.depth[A3]) + 1, r3[2 * i3 + 1] = r3[2 * A3 + 1] = s3, e3.heap[1] = s3++, F(e3, r3, 1);
          } while (e3.heap_len >= 2);
          e3.heap[--e3.heap_max] = e3.heap[1], function(e4, t4) {
            var i4, A4, s4, r4, a3, o3, l3 = t4.dyn_tree, d3 = t4.max_code, c2 = t4.stat_desc.static_tree, g2 = t4.stat_desc.has_stree, h2 = t4.stat_desc.extra_bits, u2 = t4.stat_desc.extra_base, p2 = t4.stat_desc.max_length, I2 = 0;
            for (r4 = 0; r4 <= n; r4++)
              e4.bl_count[r4] = 0;
            for (l3[2 * e4.heap[e4.heap_max] + 1] = 0, i4 = e4.heap_max + 1; i4 < 573; i4++)
              (r4 = l3[2 * l3[2 * (A4 = e4.heap[i4]) + 1] + 1] + 1) > p2 && (r4 = p2, I2++), l3[2 * A4 + 1] = r4, A4 > d3 || (e4.bl_count[r4]++, a3 = 0, A4 >= u2 && (a3 = h2[A4 - u2]), o3 = l3[2 * A4], e4.opt_len += o3 * (r4 + a3), g2 && (e4.static_len += o3 * (c2[2 * A4 + 1] + a3)));
            if (0 !== I2) {
              do {
                for (r4 = p2 - 1; 0 === e4.bl_count[r4]; )
                  r4--;
                e4.bl_count[r4]--, e4.bl_count[r4 + 1] += 2, e4.bl_count[p2]--, I2 -= 2;
              } while (I2 > 0);
              for (r4 = p2; 0 !== r4; r4--)
                for (A4 = e4.bl_count[r4]; 0 !== A4; )
                  (s4 = e4.heap[--i4]) > d3 || (l3[2 * s4 + 1] !== r4 && (e4.opt_len += (r4 - l3[2 * s4 + 1]) * l3[2 * s4], l3[2 * s4 + 1] = r4), A4--);
            }
          }(e3, t3), k(r3, d2, e3.bl_count);
        }
        function j(e3, t3, i3) {
          var A3, s3, r3 = -1, a2 = t3[1], o2 = 0, n2 = 7, l2 = 4;
          for (0 === a2 && (n2 = 138, l2 = 3), t3[2 * (i3 + 1) + 1] = 65535, A3 = 0; A3 <= i3; A3++)
            s3 = a2, a2 = t3[2 * (A3 + 1) + 1], ++o2 < n2 && s3 === a2 || (o2 < l2 ? e3.bl_tree[2 * s3] += o2 : 0 !== s3 ? (s3 !== r3 && e3.bl_tree[2 * s3]++, e3.bl_tree[32]++) : o2 <= 10 ? e3.bl_tree[34]++ : e3.bl_tree[36]++, o2 = 0, r3 = s3, 0 === a2 ? (n2 = 138, l2 = 3) : s3 === a2 ? (n2 = 6, l2 = 3) : (n2 = 7, l2 = 4));
        }
        function M(e3, t3, i3) {
          var A3, s3, r3 = -1, a2 = t3[1], o2 = 0, n2 = 7, l2 = 4;
          for (0 === a2 && (n2 = 138, l2 = 3), A3 = 0; A3 <= i3; A3++)
            if (s3 = a2, a2 = t3[2 * (A3 + 1) + 1], !(++o2 < n2 && s3 === a2)) {
              if (o2 < l2)
                do {
                  x(e3, s3, e3.bl_tree);
                } while (0 != --o2);
              else
                0 !== s3 ? (s3 !== r3 && (x(e3, s3, e3.bl_tree), o2--), x(e3, 16, e3.bl_tree), v(e3, o2 - 3, 2)) : o2 <= 10 ? (x(e3, 17, e3.bl_tree), v(e3, o2 - 3, 3)) : (x(e3, 18, e3.bl_tree), v(e3, o2 - 11, 7));
              o2 = 0, r3 = s3, 0 === a2 ? (n2 = 138, l2 = 3) : s3 === a2 ? (n2 = 6, l2 = 3) : (n2 = 7, l2 = 4);
            }
        }
        s2(y);
        var R = false;
        function O(e3, t3, i3, s3) {
          v(e3, 0 + (s3 ? 1 : 0), 3), function(e4, t4, i4, s4) {
            L(e4), _(e4, i4), _(e4, ~i4), A2.arraySet(e4.pending_buf, e4.window, t4, i4, e4.pending), e4.pending += i4;
          }(e3, t3, i3);
        }
        t2._tr_init = function(e3) {
          R || (function() {
            var e4, t3, i3, A3, s3, r3 = new Array(n + 1);
            for (i3 = 0, A3 = 0; A3 < 28; A3++)
              for (C[A3] = i3, e4 = 0; e4 < 1 << d[A3]; e4++)
                f[i3++] = A3;
            for (f[i3 - 1] = A3, s3 = 0, A3 = 0; A3 < 16; A3++)
              for (y[A3] = s3, e4 = 0; e4 < 1 << c[A3]; e4++)
                I[s3++] = A3;
            for (s3 >>= 7; A3 < o; A3++)
              for (y[A3] = s3 << 7, e4 = 0; e4 < 1 << c[A3] - 7; e4++)
                I[256 + s3++] = A3;
            for (t3 = 0; t3 <= n; t3++)
              r3[t3] = 0;
            for (e4 = 0; e4 <= 143; )
              u[2 * e4 + 1] = 8, e4++, r3[8]++;
            for (; e4 <= 255; )
              u[2 * e4 + 1] = 9, e4++, r3[9]++;
            for (; e4 <= 279; )
              u[2 * e4 + 1] = 7, e4++, r3[7]++;
            for (; e4 <= 287; )
              u[2 * e4 + 1] = 8, e4++, r3[8]++;
            for (k(u, 287, r3), e4 = 0; e4 < o; e4++)
              p[2 * e4 + 1] = 5, p[2 * e4] = T(e4, 5);
            m = new Q(u, d, 257, a, n), B = new Q(p, c, 0, o, n), E = new Q(new Array(0), g, 0, 19, 7);
          }(), R = true), e3.l_desc = new w(e3.dyn_ltree, m), e3.d_desc = new w(e3.dyn_dtree, B), e3.bl_desc = new w(e3.bl_tree, E), e3.bi_buf = 0, e3.bi_valid = 0, D(e3);
        }, t2._tr_stored_block = O, t2._tr_flush_block = function(e3, t3, i3, A3) {
          var s3, a2, o2 = 0;
          e3.level > 0 ? (2 === e3.strm.data_type && (e3.strm.data_type = function(e4) {
            var t4, i4 = 4093624447;
            for (t4 = 0; t4 <= 31; t4++, i4 >>>= 1)
              if (1 & i4 && 0 !== e4.dyn_ltree[2 * t4])
                return 0;
            if (0 !== e4.dyn_ltree[18] || 0 !== e4.dyn_ltree[20] || 0 !== e4.dyn_ltree[26])
              return 1;
            for (t4 = 32; t4 < r2; t4++)
              if (0 !== e4.dyn_ltree[2 * t4])
                return 1;
            return 0;
          }(e3)), G(e3, e3.l_desc), G(e3, e3.d_desc), o2 = function(e4) {
            var t4;
            for (j(e4, e4.dyn_ltree, e4.l_desc.max_code), j(e4, e4.dyn_dtree, e4.d_desc.max_code), G(e4, e4.bl_desc), t4 = 18; t4 >= 3 && 0 === e4.bl_tree[2 * h[t4] + 1]; t4--)
              ;
            return e4.opt_len += 3 * (t4 + 1) + 5 + 5 + 4, t4;
          }(e3), s3 = e3.opt_len + 3 + 7 >>> 3, (a2 = e3.static_len + 3 + 7 >>> 3) <= s3 && (s3 = a2)) : s3 = a2 = i3 + 5, i3 + 4 <= s3 && -1 !== t3 ? O(e3, t3, i3, A3) : 4 === e3.strategy || a2 === s3 ? (v(e3, 2 + (A3 ? 1 : 0), 3), S(e3, u, p)) : (v(e3, 4 + (A3 ? 1 : 0), 3), function(e4, t4, i4, A4) {
            var s4;
            for (v(e4, t4 - 257, 5), v(e4, i4 - 1, 5), v(e4, A4 - 4, 4), s4 = 0; s4 < A4; s4++)
              v(e4, e4.bl_tree[2 * h[s4] + 1], 3);
            M(e4, e4.dyn_ltree, t4 - 1), M(e4, e4.dyn_dtree, i4 - 1);
          }(e3, e3.l_desc.max_code + 1, e3.d_desc.max_code + 1, o2 + 1), S(e3, e3.dyn_ltree, e3.dyn_dtree)), D(e3), A3 && L(e3);
        }, t2._tr_tally = function(e3, t3, i3) {
          return e3.pending_buf[e3.d_buf + 2 * e3.last_lit] = t3 >>> 8 & 255, e3.pending_buf[e3.d_buf + 2 * e3.last_lit + 1] = 255 & t3, e3.pending_buf[e3.l_buf + e3.last_lit] = 255 & i3, e3.last_lit++, 0 === t3 ? e3.dyn_ltree[2 * i3]++ : (e3.matches++, t3--, e3.dyn_ltree[2 * (f[i3] + r2 + 1)]++, e3.dyn_dtree[2 * b(t3)]++), e3.last_lit === e3.lit_bufsize - 1;
        }, t2._tr_align = function(e3) {
          v(e3, 2, 3), x(e3, 256, u), function(e4) {
            16 === e4.bi_valid ? (_(e4, e4.bi_buf), e4.bi_buf = 0, e4.bi_valid = 0) : e4.bi_valid >= 8 && (e4.pending_buf[e4.pending++] = 255 & e4.bi_buf, e4.bi_buf >>= 8, e4.bi_valid -= 8);
          }(e3);
        };
      }, "./node_modules/pako/lib/zlib/zstream.js": (e2) => {
        "use strict";
        e2.exports = function() {
          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
        };
      }, "./node_modules/strnum/strnum.js": (e2) => {
        const t2 = /^[-+]?0x[a-fA-F0-9]+$/, i2 = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
        !Number.parseInt && window.parseInt && (Number.parseInt = window.parseInt), !Number.parseFloat && window.parseFloat && (Number.parseFloat = window.parseFloat);
        const A2 = { hex: true, leadingZeros: true, decimalPoint: ".", eNotation: true };
        e2.exports = function(e3, s2 = {}) {
          if (s2 = Object.assign({}, A2, s2), !e3 || "string" != typeof e3)
            return e3;
          let r2 = e3.trim();
          if (void 0 !== s2.skipLike && s2.skipLike.test(r2))
            return e3;
          if (s2.hex && t2.test(r2))
            return Number.parseInt(r2, 16);
          {
            const t3 = i2.exec(r2);
            if (t3) {
              const i3 = t3[1], A3 = t3[2];
              let o = (a = t3[3]) && -1 !== a.indexOf(".") ? ("." === (a = a.replace(/0+$/, "")) ? a = "0" : "." === a[0] ? a = "0" + a : "." === a[a.length - 1] && (a = a.substr(0, a.length - 1)), a) : a;
              const n = t3[4] || t3[6];
              if (!s2.leadingZeros && A3.length > 0 && i3 && "." !== r2[2])
                return e3;
              if (!s2.leadingZeros && A3.length > 0 && !i3 && "." !== r2[1])
                return e3;
              {
                const t4 = Number(r2), a2 = "" + t4;
                return -1 !== a2.search(/[eE]/) || n ? s2.eNotation ? t4 : e3 : -1 !== r2.indexOf(".") ? "0" === a2 && "" === o || a2 === o || i3 && a2 === "-" + o ? t4 : e3 : A3 ? o === a2 || i3 + o === a2 ? t4 : e3 : r2 === a2 || r2 === i3 + a2 ? t4 : e3;
              }
            }
            return e3;
          }
          var a;
        };
      }, "./src/deprecated.ts": (e2, t2, i2) => {
        "use strict";
        i2.r(t2), i2.d(t2, { FLIPPED_DIAGONALLY_FLAG: () => A2.FLIPPED_DIAGONALLY_FLAG, FLIPPED_HORIZONTALLY_FLAG: () => A2.FLIPPED_HORIZONTALLY_FLAG, FLIPPED_VERTICALLY_FLAG: () => A2.FLIPPED_VERTICALLY_FLAG, TiledEntity: () => A2.TiledEntity, TiledLayer: () => A2.TiledLayer, TiledLayerComponent: () => A2.TiledLayerComponent, TiledMap: () => A2.TiledMap, TiledMapFormat: () => A2.TiledMapFormat, TiledMapResource: () => A2.TiledMapResource, TiledObject: () => A2.TiledObject, TiledObjectComponent: () => A2.TiledObjectComponent, TiledObjectGroup: () => A2.TiledObjectGroup, TiledTileset: () => A2.TiledTileset, TiledTilesetTile: () => A2.TiledTilesetTile, getCanonicalGid: () => A2.getCanonicalGid, getProperty: () => A2.getProperty, isFlippedDiagonally: () => A2.isFlippedDiagonally, isFlippedHorizontally: () => A2.isFlippedHorizontally, isFlippedVertically: () => A2.isFlippedVertically, parseExternalJson: () => A2.parseExternalJson, parseExternalTsx: () => A2.parseExternalTsx });
        var A2 = i2("./src/deprecated/index.ts");
      }, "./src/deprecated/index.ts": (e2, t2, i2) => {
        "use strict";
        i2.r(t2), i2.d(t2, { FLIPPED_DIAGONALLY_FLAG: () => a.FLIPPED_DIAGONALLY_FLAG, FLIPPED_HORIZONTALLY_FLAG: () => a.FLIPPED_HORIZONTALLY_FLAG, FLIPPED_VERTICALLY_FLAG: () => a.FLIPPED_VERTICALLY_FLAG, TiledEntity: () => r2.TiledEntity, TiledLayer: () => a.TiledLayer, TiledLayerComponent: () => d.TiledLayerComponent, TiledMap: () => s2.TiledMap, TiledMapFormat: () => A2.TiledMapFormat, TiledMapResource: () => A2.TiledMapResource, TiledObject: () => o.TiledObject, TiledObjectComponent: () => l.TiledObjectComponent, TiledObjectGroup: () => o.TiledObjectGroup, TiledTileset: () => n.TiledTileset, TiledTilesetTile: () => n.TiledTilesetTile, getCanonicalGid: () => a.getCanonicalGid, getProperty: () => r2.getProperty, isFlippedDiagonally: () => a.isFlippedDiagonally, isFlippedHorizontally: () => a.isFlippedHorizontally, isFlippedVertically: () => a.isFlippedVertically, parseExternalJson: () => n.parseExternalJson, parseExternalTsx: () => n.parseExternalTsx }), i2("./src/deprecated/tiled-types.ts");
        var A2 = i2("./src/deprecated/tiled-map-resource.ts"), s2 = i2("./src/deprecated/tiled-map-parser.ts"), r2 = i2("./src/deprecated/tiled-entity.ts"), a = i2("./src/deprecated/tiled-layer.ts"), o = i2("./src/deprecated/tiled-object.ts"), n = i2("./src/deprecated/tiled-tileset.ts"), l = i2("./src/deprecated/tiled-object-component.ts"), d = i2("./src/deprecated/tiled-layer-component.ts");
        i2("./src/deprecated/raw-tiled-layer.ts"), i2("./src/deprecated/raw-tiled-map.ts"), i2("./src/deprecated/raw-tiled-object.ts"), i2("./src/deprecated/raw-tiled-text.ts"), i2("./src/deprecated/raw-tiled-tileset.ts"), i2("./src/deprecated/raw-tileset-tile.ts");
      }, "./src/deprecated/raw-tiled-layer.ts": (e2, t2, i2) => {
        "use strict";
        i2.r(t2);
      }, "./src/deprecated/raw-tiled-map.ts": (e2, t2, i2) => {
        "use strict";
        i2.r(t2);
      }, "./src/deprecated/raw-tiled-object.ts": (e2, t2, i2) => {
        "use strict";
        i2.r(t2);
      }, "./src/deprecated/raw-tiled-text.ts": (e2, t2, i2) => {
        "use strict";
        i2.r(t2);
      }, "./src/deprecated/raw-tiled-tileset.ts": (e2, t2, i2) => {
        "use strict";
        i2.r(t2);
      }, "./src/deprecated/raw-tileset-tile.ts": (e2, t2, i2) => {
        "use strict";
        i2.r(t2);
      }, "./src/deprecated/tiled-entity.ts": (e2, t2, i2) => {
        "use strict";
        i2.r(t2), i2.d(t2, { TiledEntity: () => s2, getProperty: () => A2 });
        const A2 = (e3, t3) => {
          if (Array.isArray(e3))
            return null == e3 ? void 0 : e3.filter((e4) => {
              var i3;
              return (null === (i3 = e4.name) || void 0 === i3 ? void 0 : i3.toLocaleLowerCase()) === t3.toLocaleLowerCase();
            })[0];
        };
        class s2 {
          constructor() {
            this.properties = [];
          }
          getProperty(e3) {
            return A2(this.properties, e3);
          }
        }
      }, "./src/deprecated/tiled-layer-component.ts": (e2, t2, i2) => {
        "use strict";
        i2.r(t2), i2.d(t2, { TiledLayerComponent: () => s2 });
        var A2 = i2("excalibur");
        class s2 extends A2.Component {
          constructor(e3) {
            super(), this.layer = e3, this.type = "ex.tiledlayer";
          }
        }
      }, "./src/deprecated/tiled-layer.ts": (e2, t2, i2) => {
        "use strict";
        i2.r(t2), i2.d(t2, { FLIPPED_DIAGONALLY_FLAG: () => o, FLIPPED_HORIZONTALLY_FLAG: () => r2, FLIPPED_VERTICALLY_FLAG: () => a, TiledLayer: () => g, getCanonicalGid: () => c, isFlippedDiagonally: () => d, isFlippedHorizontally: () => n, isFlippedVertically: () => l });
        var A2 = i2("./src/deprecated/tiled-entity.ts"), s2 = i2("excalibur");
        const r2 = 2147483648, a = 1073741824, o = 536870912, n = (e3) => !!(e3 & r2), l = (e3) => !!(e3 & a), d = (e3) => !!(e3 & o), c = (e3) => e3 & ~(r2 | a | o);
        class g extends A2.TiledEntity {
          constructor() {
            super(...arguments), this.offset = s2.Vector.Zero, this.parallaxFactor = null, this.encoding = "csv";
          }
          static parse(e3) {
            var t3, i3, A3, r3, a2, o2;
            if ("tilelayer" !== e3.type)
              throw Error("Cannot parse a non tilelayer type layer");
            const n2 = new g();
            return n2.id = +e3.id, n2.name = e3.name, n2.data = e3.data, n2.offset = (0, s2.vec)(null !== (t3 = e3.offsetx) && void 0 !== t3 ? t3 : 0, null !== (i3 = e3.offsety) && void 0 !== i3 ? i3 : 0), n2.parallaxFactor = e3.parallaxx || e3.parallaxy ? (0, s2.vec)(null !== (A3 = e3.parallaxx) && void 0 !== A3 ? A3 : 1, null !== (r3 = e3.parallaxy) && void 0 !== r3 ? r3 : 1) : null, n2.width = e3.width, n2.height = e3.height, n2.encoding = null !== (a2 = e3.encoding) && void 0 !== a2 ? a2 : "csv", n2.compression = e3.compression, n2.order = e3.order, n2.properties = null !== (o2 = e3.properties) && void 0 !== o2 ? o2 : [], n2.rawLayer = e3, n2;
          }
        }
      }, "./src/deprecated/tiled-map-parser.ts": (e2, t2, i2) => {
        "use strict";
        i2.r(t2), i2.d(t2, { TiledMap: () => l });
        var A2 = i2("./node_modules/fast-xml-parser/src/parser.js"), s2 = i2("./node_modules/pako/index.js"), r2 = i2("./node_modules/zstddec/dist/zstddec.modern.js"), a = i2("./src/deprecated/tiled-layer.ts"), o = i2("./src/deprecated/tiled-object.ts"), n = i2("./src/deprecated/tiled-tileset.ts");
        class l {
          constructor() {
            this.layers = [], this.tileSets = [], this.objectGroups = [];
          }
          getExcaliburObjects() {
            return this.getObjectLayerByProperty("excalibur", true);
          }
          getObjects() {
            var e3;
            return null !== (e3 = this.objectGroups.filter((e4) => {
              var t3;
              return !(null === (t3 = e4.getProperty("excalibur-exclude")) || void 0 === t3 ? void 0 : t3.value);
            })) && void 0 !== e3 ? e3 : [];
          }
          getObjectLayerByName(e3) {
            return this.objectGroups.filter((t3) => t3.name === e3)[0];
          }
          getObjectLayerByProperty(e3, t3) {
            return this.objectGroups.filter((i3) => {
              var A3;
              return (null === (A3 = i3.getProperty(e3)) || void 0 === A3 ? void 0 : A3.value) === t3;
            });
          }
          getTileLayerByName(e3) {
            return this.layers.filter((t3) => t3.name === e3)[0];
          }
          getTileLayersByProperty(e3, t3) {
            return this.layers.filter((i3) => {
              var A3;
              return (null === (A3 = i3.getProperty(e3)) || void 0 === A3 ? void 0 : A3.value) === t3;
            });
          }
          static async fromTmx(e3) {
            var t3, i3, s3, r3, a2, o2, n2, d2, c2, g, h, u, p, I, f, C;
            const m = (e4, t4, i4 = false) => {
              e4[t4] ? (e4[t4 + (i4 ? "s" : "")] = Array.isArray(e4[t4]) ? e4[t4] : [e4[t4]], i4 && delete e4[t4]) : e4[t4 + (i4 ? "s" : "")] = [];
            }, B = A2.parse(e3, { attributeNamePrefix: "", textNodeName: "#text", ignoreAttributes: false, ignoreNameSpace: false, allowBooleanAttributes: true, parseNodeValue: true, parseAttributeValue: true, trimValues: true, parseTrueNumberOnly: false, arrayMode: false, stopNodes: ["parse-me-as-string"] }).map;
            m(B, "layer", true);
            for (let e4 of B.layers)
              e4.type = null !== (t3 = e4.type) && void 0 !== t3 ? t3 : "tilelayer", e4.encoding = e4.data.encoding, e4.compression = e4.data.compression, "csv" === e4.encoding ? e4.data = e4.data["#text"].split(",").map((e5) => +e5) : e4.data = e4.data["#text"], e4.properties = null !== (s3 = null === (i3 = e4.properties) || void 0 === i3 ? void 0 : i3.property) && void 0 !== s3 ? s3 : [], m(e4, "properties");
            B.objectgroup = null !== (r3 = B.objectgroup) && void 0 !== r3 ? r3 : [];
            let E = Array.isArray(B.objectgroup) ? B.objectgroup : [B.objectgroup];
            for (let e4 of E)
              if (e4.type = null !== (a2 = e4.type) && void 0 !== a2 ? a2 : "objectgroup", e4.properties = null !== (n2 = null === (o2 = e4.properties) || void 0 === o2 ? void 0 : o2.property) && void 0 !== n2 ? n2 : [], m(e4, "properties"), e4.object) {
                e4.objects = Array.isArray(e4.object) ? e4.object : [e4.object], e4.objects.forEach((e5) => {
                  var t4, i4;
                  return e5.properties = null !== (i4 = null === (t4 = e5.properties) || void 0 === t4 ? void 0 : t4.property) && void 0 !== i4 ? i4 : [];
                }), e4.objects.forEach((e5) => m(e5, "properties")), delete e4.object;
                for (let t4 of e4.objects)
                  t4.text && (t4.text.text = t4.text["#text"], t4.text.halign = null !== (d2 = t4.text.halign) && void 0 !== d2 ? d2 : "left", t4.text.valign = null !== (c2 = t4.text.valign) && void 0 !== c2 ? c2 : "top", t4.text.fontfamily = null !== (g = t4.text.fontfamily) && void 0 !== g ? g : "sans-serif", t4.text.pixelsize = +(null !== (h = t4.text.pixelsize) && void 0 !== h ? h : 16), t4.text.kerning = !!t4.text.kerning, t4.text.italic = !!t4.text.italic, t4.text.bold = !!t4.text.bold, t4.text.underline = !!t4.text.underline, t4.text.strikeout = !!t4.text.strikeout, t4.text.color = null !== (u = t4.text.color) && void 0 !== u ? u : "#000000"), "" === t4.point && (t4.point = true), "" === t4.ellipse && (t4.ellipse = true), t4.polyline && (t4.polyline = t4.polyline.points.split(" ").map((e5) => {
                    const t5 = e5.split(",");
                    return { x: +t5[0], y: +t5[1] };
                  })), t4.polygon && (t4.polygon = t4.polygon.points.split(" ").map((e5) => {
                    const t5 = e5.split(",");
                    return { x: +t5[0], y: +t5[1] };
                  }));
                B.layers.push(e4);
              }
            delete B.objectgroup, m(B, "imagelayer", true);
            for (let e4 of B.imagelayers)
              e4.type = null !== (p = e4.type) && void 0 !== p ? p : "imagelayer", e4.image = e4.image.source, e4.properties = null !== (f = null === (I = e4.properties) || void 0 === I ? void 0 : I.property) && void 0 !== f ? f : [], m(e4, "properties"), B.layers.push(e4);
            delete B.imagelayer, m(B, "tileset", true);
            for (let e4 of B.tilesets)
              e4.source || (e4.image && (e4.imagewidth = e4.image.width, e4.imageheight = e4.image.height, e4.image = e4.image.source), e4.objectalignment = null !== (C = e4.objectalignment) && void 0 !== C ? C : "unspecified", m(e4, "tile", true), e4.tiles.forEach((e5) => {
                var t4;
                (null === (t4 = e5.image) || void 0 === t4 ? void 0 : t4.source) && (e5.image = e5.image.source), e5.objectgroup && (e5.objectgroup.type = "objectgroup", m(e5.objectgroup, "object", true));
              }));
            return await l._fromRawTiledMap(B);
          }
          static async fromJson(e3) {
            return await l._fromRawTiledMap(e3);
          }
          static async _fromRawTiledMap(e3) {
            await l._decompresslayers(e3);
            const t3 = new l();
            t3.orientation = e3.orientation, t3.rawMap = e3, t3.width = +e3.width, t3.height = +e3.height, t3.tileWidth = +e3.tilewidth, t3.tileHeight = +e3.tileheight, d(e3);
            for (let i3 of e3.layers)
              "tilelayer" == i3.type && t3.layers.push(a.TiledLayer.parse(i3)), "objectgroup" == i3.type && t3.objectGroups.push(o.TiledObjectGroup.parse(i3));
            for (let i3 of e3.tilesets)
              i3.source || t3.tileSets.push(n.TiledTileset.parse(i3));
            return t3;
          }
          static async _decompresslayers(e3) {
            var t3;
            if (e3.layers)
              for (var i3 of e3.layers)
                "string" == typeof i3.data ? "base64" === i3.encoding && (i3.data = await c.decompressBase64(i3.data, i3.encoding, null !== (t3 = i3.compression) && void 0 !== t3 ? t3 : "")) : i3.data = c.decompressCsv(i3.data);
            return e3;
          }
        }
        const d = (e3) => {
          let t3 = 0;
          for (let i3 of e3.layers)
            i3.order = t3++;
        }, c = { decompressCsv: (e3) => e3, decompressBase64: (e3, t3, i3) => {
          var A3, a2, o2, n2, l2, d2;
          if (e3.length % 4 > 0)
            throw new Error("Invalid string. Length must be a multiple of 4");
          var c2 = "+".charCodeAt(0), g = "/".charCodeAt(0), h = "0".charCodeAt(0), u = "a".charCodeAt(0), p = "A".charCodeAt(0), I = "-".charCodeAt(0), f = "_".charCodeAt(0);
          function C(e4) {
            var t4 = e4.charCodeAt(0);
            if (t4 === c2 || t4 === I)
              return 62;
            if (t4 === g || t4 === f)
              return 63;
            if (t4 < h)
              return -1;
            if (t4 < h + 10)
              return t4 - h + 26 + 26;
            if (t4 < p + 26)
              return t4 - p;
            if (t4 < u + 26)
              return t4 - u + 26;
            throw Error("Could not decode elt");
          }
          var m = e3.length;
          l2 = "=" === e3.charAt(m - 2) ? 2 : "=" === e3.charAt(m - 1) ? 1 : 0, d2 = new Uint8Array(3 * e3.length / 4 - l2), o2 = l2 > 0 ? e3.length - 4 : e3.length;
          var B = 0;
          function E(e4) {
            d2[B++] = e4;
          }
          for (A3 = 0, a2 = 0; A3 < o2; A3 += 4, a2 += 3)
            E((16711680 & (n2 = C(e3.charAt(A3)) << 18 | C(e3.charAt(A3 + 1)) << 12 | C(e3.charAt(A3 + 2)) << 6 | C(e3.charAt(A3 + 3)))) >> 16), E((65280 & n2) >> 8), E(255 & n2);
          return 2 === l2 ? E(255 & (n2 = C(e3.charAt(A3)) << 2 | C(e3.charAt(A3 + 1)) >> 4)) : 1 === l2 && (E((n2 = C(e3.charAt(A3)) << 10 | C(e3.charAt(A3 + 1)) << 4 | C(e3.charAt(A3 + 2)) >> 2) >> 8 & 255), E(255 & n2)), new Promise((e4) => {
            const t4 = function(e5) {
              for (var t5 = 0, i4 = e5.length - 1; i4 >= 0; i4--)
                t5 = 256 * t5 + 1 * e5[i4];
              return t5;
            };
            if ("zlib" === i3 || "gzip" === i3) {
              var a3 = (d2 = (0, s2.inflate)(d2)).length / 4, o3 = new Array(a3);
              for (A3 = 0; A3 < a3; A3++)
                o3[A3] = t4(d2.slice(4 * A3, 4 * A3 + 4));
              e4(o3);
            }
            if ("zstd" === i3) {
              const i4 = new r2.ZSTDDecoder();
              i4.init().then(() => {
                var s3 = (d2 = i4.decode(d2)).length / 4, r3 = new Array(s3);
                for (A3 = 0; A3 < s3; A3++)
                  r3[A3] = t4(d2.slice(4 * A3, 4 * A3 + 4));
                e4(r3);
              });
            }
            if (!i3) {
              for (a3 = d2.length / 4, o3 = new Array(a3), A3 = 0; A3 < a3; A3++)
                o3[A3] = t4(d2.slice(4 * A3, 4 * A3 + 4));
              e4(o3);
            }
          });
        } };
      }, "./src/deprecated/tiled-map-resource.ts": (e2, t2, i2) => {
        "use strict";
        i2.r(t2), i2.d(t2, { TiledMapFormat: () => A2, TiledMapResource: () => c });
        var A2, s2 = i2("excalibur"), r2 = i2("./src/deprecated/tiled-map-parser.ts"), a = i2("./src/deprecated/tiled-tileset.ts"), o = i2("./src/deprecated/tiled-layer.ts"), n = i2("./src/deprecated/tiled-entity.ts"), l = i2("./src/deprecated/tiled-object-component.ts"), d = i2("./src/deprecated/tiled-layer-component.ts");
        !function(e3) {
          e3.TMX = "TMX", e3.JSON = "JSON";
        }(A2 || (A2 = {}));
        class c {
          constructor(e3, t3) {
            this.path = e3, this.layers = [], this.isoLayers = [], this._layerZIndexStart = -1, this._mapToRawLayer = /* @__PURE__ */ new Map();
            const { mapFormatOverride: i3, startingLayerZIndex: r3 } = { ...t3 };
            this._layerZIndexStart = null != r3 ? r3 : this._layerZIndexStart;
            const a2 = null != i3 ? i3 : e3.includes(".tmx") ? A2.TMX : A2.JSON;
            switch (a2) {
              case A2.TMX:
                this._resource = new s2.Resource(e3, "text");
                break;
              case A2.JSON:
                this._resource = new s2.Resource(e3, "json");
                break;
              default:
                throw `The format ${a2} is not currently supported. Please export Tiled map as JSON.`;
            }
            this.mapFormat = a2, this.ex = {}, this.imageMap = {}, this.sheetMap = {}, this.tileImageMap = {}, this.convertPath = (e4, t4) => {
              if (0 === t4.indexOf("/"))
                return t4;
              const i4 = e4.split("/"), A3 = t4.split("/");
              return i4[i4.length - 1].includes(".") && i4.pop(), i4.concat(A3).join("/");
            };
          }
          _addTiledCamera(e3) {
            const t3 = this.ex.camera;
            if (t3) {
              let i3 = (0, s2.vec)(t3.x, t3.y);
              this.isIsometric() && (i3 = this._isoTileToScreenCoords(t3.x, t3.y)), e3.camera.x = i3.x, e3.camera.y = i3.y, e3.camera.zoom = t3.zoom;
            }
          }
          _addTiledColliders(e3) {
            var t3;
            const i3 = this.ex.colliders;
            if (i3)
              for (let A3 of i3) {
                const i4 = new s2.Actor({ pos: (0, s2.vec)(A3.x, A3.y), name: A3.name, collisionType: null !== (t3 = A3.collisionType) && void 0 !== t3 ? t3 : s2.CollisionType.Fixed });
                if (A3.color && (i4.color = s2.Color.fromHex(A3.color.value)), "box" === A3.type)
                  if (this.isIsometric()) {
                    i4.pos = this._isoTileToScreenCoords(A3.x, A3.y);
                    const e4 = new s2.BoundingBox({ left: 0, top: 0, right: A3.width, bottom: A3.height }).getPoints().map((e5) => this._isoTileToScreenCoords(e5.x, e5.y));
                    i4.collider.usePolygonCollider(e4, s2.Vector.Zero);
                  } else
                    i4.collider.useBoxCollider(A3.width, A3.height, s2.Vector.Zero);
                "circle" === A3.type && i4.collider.useCircleCollider(A3.radius), i4.addComponent(new l.TiledObjectComponent(A3.tiled)), e3.add(i4), A3.zIndex && (i4.z = A3.zIndex);
              }
          }
          _isoTileToScreenCoords(e3, t3) {
            if (this.isIsometric()) {
              const i3 = this.isoLayers[0], A3 = i3.tileWidth, r3 = i3.tileHeight, a2 = 0, o2 = t3 / r3, n2 = e3 / r3;
              return (0, s2.vec)((n2 - o2) * A3 / 2 + a2, (n2 + o2) * r3 / 2);
            }
            return (0, s2.vec)(e3, t3);
          }
          _addTiledText(e3) {
            var t3, i3, A3, r3, a2, o2, n2, d2, c2, g, h, u;
            const p = null === (t3 = this.data) || void 0 === t3 ? void 0 : t3.getObjects();
            if (p && p.length > 0)
              for (const t4 of p) {
                const p2 = t4.getText();
                for (const I of p2) {
                  let p3 = (0, s2.vec)(I.x, I.y + ((null !== (i3 = I.height) && void 0 !== i3 ? i3 : 0) - (null !== (r3 = null === (A3 = I.text) || void 0 === A3 ? void 0 : A3.pixelSize) && void 0 !== r3 ? r3 : 0)));
                  this.isIsometric() && (p3 = this._isoTileToScreenCoords(I.x, I.y));
                  const f = new s2.Label({ anchor: s2.Vector.Zero, x: p3.x, y: p3.y, text: null !== (o2 = null === (a2 = I.text) || void 0 === a2 ? void 0 : a2.text) && void 0 !== o2 ? o2 : "", name: this._getEntityName(I), font: new s2.Font({ family: null === (n2 = I.text) || void 0 === n2 ? void 0 : n2.fontFamily, size: null === (d2 = I.text) || void 0 === d2 ? void 0 : d2.pixelSize, unit: s2.FontUnit.Px }) });
                  if (f.font.textAlign = s2.TextAlign.Left, f.font.baseAlign = s2.BaseAlign.Top, f.rotation = I.rotation, f.color = s2.Color.fromHex(null !== (g = null === (c2 = I.text) || void 0 === c2 ? void 0 : c2.color) && void 0 !== g ? g : "#000000"), f.collider.set(s2.Shape.Box(null !== (h = I.width) && void 0 !== h ? h : 0, null !== (u = I.height) && void 0 !== u ? u : 0)), f.body.collisionType = s2.CollisionType.PreventCollision, f.addComponent(new l.TiledObjectComponent(I)), f.z = this._calculateZIndex(I, t4), this.isIsometric()) {
                    const e4 = new s2.IsometricEntityComponent(this.isoLayers[0]);
                    f.addComponent(e4), e4.elevation = t4.order;
                  }
                  e3.add(f);
                }
              }
          }
          _addTiledInsertedTiles(e3) {
            var t3, i3, A3;
            const r3 = null === (t3 = this.data) || void 0 === t3 ? void 0 : t3.getObjects();
            if (r3 && r3.length > 0)
              for (const t4 of r3) {
                const r4 = t4.getInsertedTiles();
                for (const a2 of r4) {
                  const r5 = a2.getProperty("collisionType");
                  let o2 = s2.CollisionType.PreventCollision;
                  r5 && (o2 = r5.value);
                  let n2 = (0, s2.vec)(a2.x, a2.y);
                  if (this.isIsometric() && (n2 = this._isoTileToScreenCoords(a2.x, a2.y)), a2.gid) {
                    const r6 = this.getSpriteForGid(a2.gid), d2 = this.getCollidersForGid(a2.gid), c2 = new s2.Actor({ x: n2.x, y: n2.y, width: a2.width, height: a2.height, anchor: this.isIsometric() ? (0, s2.vec)(0.5, 1) : (0, s2.vec)(0, 1), rotation: a2.rotation, collisionType: o2, name: this._getEntityName(a2) });
                    if (this.isIsometric()) {
                      const e4 = this.isoLayers[0];
                      for (let t5 of d2)
                        t5.offset = (0, s2.vec)(-e4.tileWidth / 2, 2 * -e4.tileHeight);
                    }
                    if (d2.length && (c2.collider.clear(), c2.collider.set(new s2.CompositeCollider(d2))), c2.addComponent(new l.TiledObjectComponent(a2)), c2.graphics.anchor = this.isIsometric() ? (0, s2.vec)(0.5, 1) : (0, s2.vec)(0, 1), r6.destSize.width = null !== (i3 = a2.width) && void 0 !== i3 ? i3 : r6.destSize.width, r6.destSize.height = null !== (A3 = a2.height) && void 0 !== A3 ? A3 : r6.destSize.height, c2.graphics.use(r6), this.isIsometric()) {
                      const e4 = new s2.IsometricEntityComponent(this.isoLayers[0]);
                      c2.addComponent(e4), e4.elevation = t4.order;
                    }
                    e3.add(c2), c2.z = this._calculateZIndex(a2, t4);
                  }
                }
              }
          }
          useSolidLayers() {
            var e3, t3, i3;
            let A3 = this.getTileMapLayers();
            A3 = A3.concat(this.isoLayers);
            for (const s3 of A3) {
              const A4 = this._mapToRawLayer.get(s3);
              if (A4 && null !== (t3 = null === (e3 = (0, n.getProperty)(A4.properties, "solid")) || void 0 === e3 ? void 0 : e3.value) && void 0 !== t3 && t3)
                for (let e4 = 0; e4 < A4.data.length; e4++)
                  (i3 = s3.tiles[e4]).solid || (i3.solid = !!A4.data[e4]);
            }
          }
          addTiledMapToScene(e3) {
            const t3 = this.getTileMapLayers();
            for (const i3 of t3)
              e3.add(i3);
            for (const t4 of this.isoLayers)
              e3.add(t4);
            this._addTiledCamera(e3), this._addTiledColliders(e3), this._addTiledText(e3), this._addTiledInsertedTiles(e3), this.useSolidLayers();
          }
          _parseExcaliburInfo() {
            var e3, t3, i3, A3, r3, a2, o2, n2, l2, d2;
            const c2 = null === (e3 = this.data) || void 0 === e3 ? void 0 : e3.getObjects(), g = {};
            if (c2.length > 0) {
              g.camera = null === (t3 = c2.find((e4) => e4.getObjectByClass("camera"))) || void 0 === t3 ? void 0 : t3.getCamera(), g.colliders = [];
              for (let e4 of c2) {
                const t4 = e4.getObjectsByClass("boxcollider");
                for (let a3 of t4) {
                  const t5 = a3.getProperty("collisiontype"), o3 = a3.getProperty("color"), n3 = this._calculateZIndex(a3, e4);
                  g.colliders.push({ ...a3, width: +(null !== (i3 = a3.width) && void 0 !== i3 ? i3 : 0), height: +(null !== (A3 = a3.height) && void 0 !== A3 ? A3 : 0), collisionType: null !== (r3 = null == t5 ? void 0 : t5.value) && void 0 !== r3 ? r3 : s2.CollisionType.Fixed, color: o3, zIndex: n3, radius: 0, type: "box", tiled: a3, name: this._getEntityName(a3) });
                }
                const c3 = e4.getObjectsByClass("circlecollider");
                for (let t5 of c3) {
                  const i4 = t5.getProperty("collisiontype"), A4 = t5.getProperty("color"), r4 = this._calculateZIndex(t5, e4);
                  g.colliders.push({ x: t5.x, y: t5.y, radius: Math.max(null !== (a2 = t5.width) && void 0 !== a2 ? a2 : 0, null !== (o2 = t5.height) && void 0 !== o2 ? o2 : 0), collisionType: null !== (n2 = null == i4 ? void 0 : i4.value) && void 0 !== n2 ? n2 : s2.CollisionType.Fixed, color: A4, zIndex: r4, width: null !== (l2 = t5.width) && void 0 !== l2 ? l2 : 0, height: null !== (d2 = t5.height) && void 0 !== d2 ? d2 : 0, type: "circle", tiled: t5, name: this._getEntityName(t5) });
                }
              }
            }
            this.ex = g;
          }
          isLoaded() {
            return !!this.data;
          }
          isIsometric() {
            return !!this.isoLayers.length;
          }
          async load() {
            const e3 = await this._resource.load(), t3 = await this._importMapData(e3);
            let i3 = [];
            return t3.rawMap.tilesets.forEach((e4) => {
              if (e4.source) {
                const r3 = e4.source.includes(".tsx") ? "text" : "json";
                var A3 = new s2.Resource(this.convertPath(this.path, e4.source), r3);
                i3.push(A3.load().then((i4) => {
                  i4 = "text" === r3 ? (0, a.parseExternalTsx)(i4, e4.firstgid, e4.source) : (0, a.parseExternalJson)(i4, e4.firstgid, e4.source), Object.assign(e4, i4), t3.tileSets.push(i4);
                }, () => {
                  s2.Logger.getInstance().error(`[Tiled] Error loading external tileset file ${A3.path}`);
                }));
              }
            }), await Promise.all(i3).then(() => {
              let e4 = [];
              return t3.rawMap.tilesets.forEach((t4) => {
                let i4 = [];
                if (t4.image) {
                  i4 = t4.source ? [this.convertPath(t4.source, t4.image)] : [this.convertPath(this.path, t4.image)];
                  for (let A3 of i4) {
                    const i5 = new s2.ImageSource(A3);
                    this.imageMap[t4.firstgid] = i5, e4.push(i5.load()), s2.Logger.getInstance().debug("[Tiled] Loading associated tileset image: " + t4.image);
                  }
                } else
                  for (let i5 of t4.tiles) {
                    let A3;
                    A3 = t4.source ? this.convertPath(t4.source, i5.image) : this.convertPath(this.path, i5.image);
                    const r3 = new s2.ImageSource(A3);
                    e4.push(r3.load()), this.tileImageMap[t4.firstgid] || (this.tileImageMap[t4.firstgid] = []), this.tileImageMap[t4.firstgid].push([i5, r3]), s2.Logger.getInstance().debug("[Tiled] Loading associated tileset image: " + A3);
                  }
              }), Promise.all(e4).then(() => {
                this._createTileMap();
              }, () => {
                s2.Logger.getInstance().error("[Tiled] Error loading tileset images");
              });
            }), this._parseExcaliburInfo(), t3;
          }
          async _importMapData(e3) {
            if (void 0 === e3)
              throw `Tiled map resource ${this.path} is empty`;
            switch (this.mapFormat) {
              case A2.TMX:
                return this.data = await r2.TiledMap.fromTmx(e3);
              case A2.JSON:
                return this.data = await r2.TiledMap.fromJson(e3);
              default:
                throw new Error("Unknown map format: " + this.mapFormat);
            }
          }
          getTilesetForTile(e3) {
            if (this.data)
              for (var t3 = this.data.tileSets.length - 1; t3 >= 0; t3--) {
                var i3 = this.data.tileSets[t3];
                if (e3 >= i3.firstGid && e3 <= i3.firstGid + i3.tileCount - 1)
                  return i3;
              }
            throw Error(`No tileset exists for tiled gid [${e3}]!`);
          }
          getSpriteForGid(e3) {
            const t3 = (0, o.isFlippedHorizontally)(e3), i3 = (0, o.isFlippedVertically)(e3), A3 = (0, o.isFlippedDiagonally)(e3), r3 = (0, o.getCanonicalGid)(e3), a2 = this.getTilesetForTile(r3), n2 = r3 - a2.firstGid, l2 = this.sheetMap[a2.firstGid.toString()];
            if (l2) {
              let e4 = l2.sprites[n2];
              return (A3 || t3 || i3) && (e4 = e4.clone()), A3 && (e4.rotation = -Math.PI / 2, e4.scale = (0, s2.vec)(-1, 1)), t3 && (e4.scale = (0, s2.vec)((A3 ? 1 : -1) * e4.scale.x, (A3 ? -1 : 1) * e4.scale.y)), i3 && (e4.scale = (0, s2.vec)((A3 ? -1 : 1) * e4.scale.x, (A3 ? 1 : -1) * e4.scale.y)), e4;
            }
            throw new Error(`Could not find sprite for gid: [${e3}] normalized gid: [${r3}]`);
          }
          _transformPoints(e3, t3, i3) {
            const A3 = (0, o.isFlippedHorizontally)(i3), s3 = (0, o.isFlippedVertically)(i3);
            return (0, o.isFlippedDiagonally)(i3) && (e3 = e3.map((e4) => t3.diagonalFlipTransform.multiply(e4))), A3 && (e3 = e3.map((e4) => t3.horizontalFlipTransform.multiply(e4))), s3 && (e3 = e3.map((e4) => t3.verticalFlipTransform.multiply(e4))), e3;
          }
          getCollidersForGid(e3) {
            const t3 = (0, o.getCanonicalGid)(e3), i3 = this.getTilesetForTile(t3), A3 = t3 - i3.firstGid, r3 = i3.tiles.find((e4) => e4.id === A3);
            if (r3 && r3.objectgroup) {
              const t4 = [];
              for (const A4 of r3.objectgroup.getPolygons()) {
                const r4 = (0, s2.vec)(A4.x, A4.y), a2 = A4.polygon.points.split(" ").map((e4) => {
                  const t5 = e4.split(",");
                  return (0, s2.vec)(Number.parseFloat(t5[0]), Number.parseFloat(t5[1])).add(r4);
                }), o2 = s2.Shape.Polygon(a2);
                o2.points = this._transformPoints(o2.points, i3, e3), t4.push(o2);
              }
              for (const A4 of r3.objectgroup.getBoxes()) {
                const r4 = s2.Shape.Box(A4.width, A4.height, s2.Vector.Zero);
                r4.points = r4.points.map((e4) => e4.add((0, s2.vec)(A4.x, A4.y))), r4.points = this._transformPoints(r4.points, i3, e3), t4.push(r4);
              }
              for (const e4 of r3.objectgroup.getEllipses()) {
                const i4 = s2.Shape.Circle(Math.min(e4.width / 2, e4.height / 2), (0, s2.vec)(e4.width / 2, e4.height / 2).add((0, s2.vec)(e4.x, e4.y)));
                t4.push(i4);
              }
              return t4;
            }
            return [];
          }
          getAnimationForGid(e3) {
            const t3 = (0, o.getCanonicalGid)(e3), i3 = this.getTilesetForTile(t3), A3 = t3 - i3.firstGid, s3 = i3.tiles.find((e4) => e4.id === A3);
            return s3 && s3.hasAnimation() ? s3.getAnimation(this) : null;
          }
          _calculateZIndex(e3, t3) {
            var i3, A3, s3;
            let r3 = null !== (A3 = null === (i3 = e3.getProperty("z")) || void 0 === i3 ? void 0 : i3.value) && void 0 !== A3 ? A3 : null === (s3 = e3.getProperty("zindex")) || void 0 === s3 ? void 0 : s3.value;
            return null != r3 || (r3 = t3.order + this._layerZIndexStart), +r3;
          }
          _getEntityName(e3) {
            return e3.name;
          }
          _createTileMap() {
            var e3, t3, i3, A3, r3, a2, o2, n2, l2;
            for (const a3 of this.data.rawMap.tilesets) {
              const o3 = null !== (e3 = a3.spacing) && void 0 !== e3 ? e3 : 0, n3 = Math.floor((a3.imagewidth + o3) / (a3.tilewidth + o3)), l3 = Math.floor((a3.imageheight + o3) / (a3.tileheight + o3));
              if (this.imageMap[a3.firstgid]) {
                const e4 = s2.SpriteSheet.fromImageSource({ image: this.imageMap[a3.firstgid], grid: { columns: n3, rows: l3, spriteWidth: a3.tilewidth, spriteHeight: a3.tileheight }, spacing: { originOffset: { x: null !== (t3 = a3.margin) && void 0 !== t3 ? t3 : 0, y: null !== (i3 = a3.margin) && void 0 !== i3 ? i3 : 0 }, margin: { x: null !== (A3 = a3.spacing) && void 0 !== A3 ? A3 : 0, y: null !== (r3 = a3.spacing) && void 0 !== r3 ? r3 : 0 } } });
                this.sheetMap[a3.firstgid.toString()] = e4;
              } else {
                const e4 = this.tileImageMap[a3.firstgid].map(([e5, t5]) => t5.toSprite()), t4 = new s2.SpriteSheet({ sprites: e4 });
                this.sheetMap[a3.firstgid.toString()] = t4;
              }
            }
            for (var c2 of this.data.layers)
              if ("tilelayer" === c2.rawLayer.type) {
                if ("orthogonal" === this.data.orientation) {
                  const e4 = c2.rawLayer, t4 = new s2.TileMap({ name: c2.rawLayer.name, pos: (0, s2.vec)(c2.offset.x, c2.offset.y), tileWidth: this.data.rawMap.tilewidth, tileHeight: this.data.rawMap.tileheight, columns: this.data.width, rows: this.data.height });
                  if (t4.addComponent(new d.TiledLayerComponent(c2)), c2.rawLayer.parallaxx || c2.rawLayer.parallaxy) {
                    const e5 = (0, s2.vec)(null !== (a2 = c2.rawLayer.parallaxx) && void 0 !== a2 ? a2 : 1, null !== (o2 = c2.rawLayer.parallaxy) && void 0 !== o2 ? o2 : 1);
                    t4.addComponent(new s2.ParallaxComponent(e5));
                  }
                  t4.z = this._calculateZIndex(c2, c2);
                  for (let i4 = 0; i4 < e4.data.length; i4++) {
                    let A4 = e4.data[i4];
                    if (0 !== A4) {
                      const e5 = this.getSpriteForGid(A4);
                      t4.tiles[i4].addGraphic(e5);
                      const s3 = this.getCollidersForGid(A4);
                      for (let e6 of s3)
                        t4.tiles[i4].addCollider(e6);
                      const r4 = this.getAnimationForGid(A4);
                      r4 && (t4.tiles[i4].clearGraphics(), t4.tiles[i4].addGraphic(r4));
                    }
                  }
                  this._mapToRawLayer.set(t4, e4), null === (n2 = this.layers) || void 0 === n2 || n2.push(t4);
                }
                if ("isometric" === this.data.orientation) {
                  const e4 = c2.rawLayer, t4 = new s2.IsometricMap({ name: c2.rawLayer.name, pos: (0, s2.vec)(c2.offset.x, c2.offset.y), columns: this.data.width, rows: this.data.height, tileWidth: this.data.tileWidth, tileHeight: this.data.tileHeight }), i4 = t4.get(s2.TransformComponent);
                  i4 && (i4.z = this._calculateZIndex(c2, c2));
                  for (let i5 = 0; i5 < e4.data.length; i5++) {
                    let A4 = e4.data[i5];
                    if (0 !== A4) {
                      const e5 = this.getSpriteForGid(A4);
                      t4.tiles[i5].addGraphic(e5);
                      const r4 = this.getCollidersForGid(A4);
                      for (let e6 of r4)
                        t4.tiles[i5].addCollider(e6);
                      const a3 = t4.tiles[i5].get(s2.IsometricEntityComponent);
                      a3 && (a3.elevation = c2.order);
                    }
                  }
                  t4.updateColliders(), this._mapToRawLayer.set(t4, e4), null === (l2 = this.isoLayers) || void 0 === l2 || l2.push(t4);
                }
              }
          }
          getTileMapLayers() {
            var e3;
            return (null === (e3 = this.layers) || void 0 === e3 ? void 0 : e3.length) ? this.layers : [];
          }
          getIsometricMapLayers() {
            var e3;
            return (null === (e3 = this.isoLayers) || void 0 === e3 ? void 0 : e3.length) ? this.isoLayers : [];
          }
          _lookupTile(e3, t3, i3) {
            const A3 = e3.tiles.indexOf(t3), s3 = this.data.getTileLayerByName(i3), r3 = (0, o.getCanonicalGid)(s3.data[A3]);
            if (0 === r3)
              return null;
            const a2 = this.getTilesetForTile(r3);
            return a2.tiles.find((e4) => e4.id === r3 - 1) || { id: r3 - 1, tileset: a2, properties: {} };
          }
          getTileByPoint(e3, t3) {
            const i3 = this.getTileMapLayers().find((t4) => t4.name === e3);
            if (i3) {
              const A3 = i3.getTileByPoint(t3);
              return A3 ? this._lookupTile(i3, A3, e3) : null;
            }
            return null;
          }
          getTileByCoordinate(e3, t3, i3) {
            const A3 = this.getTileMapLayers().find((t4) => t4.name === e3);
            if (A3) {
              const s3 = A3.getTile(t3, i3);
              return this._lookupTile(A3, s3, e3);
            }
            return null;
          }
        }
      }, "./src/deprecated/tiled-object-component.ts": (e2, t2, i2) => {
        "use strict";
        i2.r(t2), i2.d(t2, { TiledObjectComponent: () => s2 });
        var A2 = i2("excalibur");
        class s2 extends A2.Component {
          constructor(e3) {
            super(), this.object = e3, this.type = "ex.tiledobject";
          }
        }
      }, "./src/deprecated/tiled-object.ts": (e2, t2, i2) => {
        "use strict";
        i2.r(t2), i2.d(t2, { TiledObject: () => a, TiledObjectGroup: () => r2 });
        var A2 = i2("./src/deprecated/tiled-entity.ts"), s2 = i2("excalibur");
        class r2 extends A2.TiledEntity {
          constructor() {
            super(...arguments), this.objects = [];
          }
          getCamera() {
            var e3;
            const t3 = this.getObjectByClass("camera");
            if (t3) {
              const i3 = t3.getProperty("zoom");
              return { x: t3.x, y: t3.y, zoom: i3 ? +(null !== (e3 = null == i3 ? void 0 : i3.value) && void 0 !== e3 ? e3 : 1) : 1 };
            }
          }
          getObjectByType(e3) {
            return this.getObjectsByType(e3)[0];
          }
          getObjectByClass(e3) {
            return this.getObjectsByClass(e3)[0];
          }
          getObjectsByType(e3) {
            return this.objects.filter((t3) => {
              var i3;
              return (null === (i3 = t3.type) || void 0 === i3 ? void 0 : i3.toLocaleLowerCase()) === e3.toLocaleLowerCase();
            });
          }
          getObjectsByClass(e3) {
            return this.objects.filter((t3) => {
              var i3, A3;
              return (null === (i3 = t3.class) || void 0 === i3 ? void 0 : i3.toLocaleLowerCase()) === e3.toLocaleLowerCase() || (null === (A3 = t3.type) || void 0 === A3 ? void 0 : A3.toLocaleLowerCase()) === e3.toLocaleLowerCase();
            });
          }
          getObjectByName(e3) {
            return this.getObjectsByName(e3)[0];
          }
          getObjectsByName(e3) {
            return this.objects.filter((t3) => {
              var i3;
              return (null === (i3 = t3.name) || void 0 === i3 ? void 0 : i3.toString().toLocaleLowerCase()) === e3.toString().toLocaleLowerCase();
            });
          }
          getPoints() {
            return this.objects.filter((e3) => !!e3.point);
          }
          getEllipses() {
            return this.objects.filter((e3) => !!e3.ellipse);
          }
          getText() {
            return this.objects.filter((e3) => !!e3.text);
          }
          getPolyLines() {
            return this.objects.filter((e3) => !!e3.polyline);
          }
          getPolygons() {
            return this.objects.filter((e3) => !!e3.polygon);
          }
          getBoxes() {
            return this.objects.filter((e3) => !!e3.width && !!e3.height && !e3.ellipse);
          }
          getInsertedTiles() {
            return this.objects.filter((e3) => !!e3.gid);
          }
          static parse(e3) {
            var t3;
            if ("objectgroup" !== e3.type)
              throw Error("Cannot parse non objectgroup type layer");
            const i3 = new r2();
            i3.id = +e3.id, i3.name = e3.name, i3.properties = null !== (t3 = e3.properties) && void 0 !== t3 ? t3 : [], i3.rawObjectGroup = e3, i3.order = e3.order;
            for (let t4 of e3.objects)
              i3.objects.push(a.parse(t4));
            return i3;
          }
        }
        class a extends A2.TiledEntity {
          static parse(e3) {
            var t3, i3, A3, r3;
            const o = new a();
            return o.id = +e3.id, o.gid = e3.gid, o.visible = null === (t3 = e3.visible) || void 0 === t3 || t3, o.name = e3.name, o.type = e3.type, o.class = e3.class, o.x = +e3.x, o.y = +e3.y, o.rotation = e3.rotation ? (0, s2.toRadians)(e3.rotation) : 0, o.width = null !== (i3 = e3.width) && void 0 !== i3 ? i3 : 0, o.height = null !== (A3 = e3.height) && void 0 !== A3 ? A3 : 0, o.point = e3.point, o.ellipse = true === e3.ellipse || "" === e3.ellipse, o.polyline = e3.polyline, o.polygon = e3.polygon, o.rawObject = e3, e3.text && (o.text = { ...e3.text, pixelSize: e3.text.pixelsize, fontFamily: e3.text.fontfamily }), o.properties = null !== (r3 = e3.properties) && void 0 !== r3 ? r3 : [], o;
          }
        }
      }, "./src/deprecated/tiled-tileset.ts": (e2, t2, i2) => {
        "use strict";
        i2.r(t2), i2.d(t2, { TiledTileset: () => o, TiledTilesetTile: () => n, parseExternalJson: () => d, parseExternalTsx: () => l });
        var A2 = i2("excalibur"), s2 = i2("./node_modules/fast-xml-parser/src/parser.js"), r2 = i2("./src/deprecated/tiled-object.ts"), a = i2("./src/deprecated/tiled-entity.ts");
        class o {
          constructor() {
            this.tiles = [];
          }
          static parse(e3) {
            var t3, i3;
            const s3 = new o();
            let r3 = [];
            if (Array.isArray(e3.tiles))
              r3 = (null !== (t3 = e3.tiles) && void 0 !== t3 ? t3 : []).map((e4) => n.parse(e4, s3));
            else
              for (let t4 in e3.tiles)
                r3.push(n.parse({ ...e3.tiles[t4], id: +t4 }, s3));
            return s3.tiles = r3, s3.firstGid = e3.firstgid, s3.tileWidth = e3.tilewidth, s3.tileHeight = e3.tileheight, s3.tileCount = e3.tilecount, s3.tileOffset = e3.tileoffset, s3.tiledVersion = e3.tiledversion, s3.backgroundColor = e3.backgroundcolor, s3.transparentColor = e3.transparentcolor, s3.wangSets = e3.wangsets, s3.imageWidth = e3.imagewidth, s3.imageHeight = e3.imageheight, s3.objectAlignment = null !== (i3 = e3.objectalignment) && void 0 !== i3 ? i3 : "unspecified", s3.image = e3.image, s3.spacing = isNaN(e3.spacing) ? 0 : e3.spacing, s3.horizontalFlipTransform = A2.Matrix.identity().translate(s3.tileWidth, 0).scale(-1, 1), s3.verticalFlipTransform = A2.Matrix.identity().translate(0, s3.tileHeight).scale(1, -1), s3.diagonalFlipTransform = A2.Matrix.identity().translate(0, 0).rotate(-Math.PI / 2).scale(-1, 1), s3;
          }
        }
        class n {
          hasAnimation() {
            return !!this.animation;
          }
          getAnimation(e3) {
            var t3;
            if (this.animation) {
              let i3 = [];
              for (let t4 of this.animation)
                i3.push({ graphic: e3.getSpriteForGid(t4.tileid + this.tileset.firstGid), duration: t4.duration });
              return new A2.Animation({ frames: i3, strategy: null !== (t3 = this.animationStrategy) && void 0 !== t3 ? t3 : A2.AnimationStrategy.Loop });
            }
            return null;
          }
          static parse(e3, t3) {
            var i3, s3, o2;
            const l2 = new n();
            if (l2.id = +e3.id, l2.image = e3.image, l2.tileset = t3, l2.properties = Array.isArray(e3.properties) ? e3.properties : null !== (s3 = null === (i3 = e3.properties) || void 0 === i3 ? void 0 : i3.property) && void 0 !== s3 ? s3 : [], e3.objectgroup && (l2.objectgroup = r2.TiledObjectGroup.parse(e3.objectgroup)), e3.terrain && (l2.terrain = e3.terrain), e3.animation && (l2.animation = Array.isArray(e3.animation) ? e3.animation : [...e3.animation.frame], l2.properties)) {
              const e4 = null === (o2 = (0, a.getProperty)(l2.properties, "animationstrategy")) || void 0 === o2 ? void 0 : o2.value;
              switch (null == e4 ? void 0 : e4.toLowerCase()) {
                case A2.AnimationStrategy.End.toLowerCase():
                  l2.animationStrategy = A2.AnimationStrategy.End;
                  break;
                case A2.AnimationStrategy.Freeze.toLowerCase():
                  l2.animationStrategy = A2.AnimationStrategy.Freeze;
                  break;
                case A2.AnimationStrategy.Loop.toLowerCase():
                  l2.animationStrategy = A2.AnimationStrategy.Loop;
                  break;
                case A2.AnimationStrategy.PingPong.toLowerCase():
                  l2.animationStrategy = A2.AnimationStrategy.PingPong;
                  break;
                default:
                  l2.animationStrategy = A2.AnimationStrategy.Loop;
              }
            }
            return l2;
          }
        }
        const l = (e3, t3, i3) => {
          var r3, a2, o2, l2, d2;
          const c = (e4, t4, i4 = false) => {
            e4[t4] ? (e4[t4 + (i4 ? "s" : "")] = Array.isArray(e4[t4]) ? e4[t4] : [e4[t4]], i4 && delete e4[t4]) : e4[t4 + (i4 ? "s" : "")] = [];
          }, g = s2.parse(e3, { attributeNamePrefix: "", textNodeName: "#text", ignoreAttributes: false, ignoreNameSpace: false, allowBooleanAttributes: true, parseNodeValue: true, parseAttributeValue: true, trimValues: true, parseTrueNumberOnly: false, arrayMode: false, stopNodes: ["parse-me-as-string"] }).tileset, h = g;
          h.firstgid = t3, h.source = i3, h.imagewidth = null === (r3 = g.image) || void 0 === r3 ? void 0 : r3.width, h.imageheight = null === (a2 = g.image) || void 0 === a2 ? void 0 : a2.height, h.objectalignment = null !== (o2 = g.objectalignment) && void 0 !== o2 ? o2 : "unspecified", h.image = null === (l2 = g.image) || void 0 === l2 ? void 0 : l2.source, h.spacing = isNaN(g.spacing) ? 0 : g.spacing, c(g, "tile", true), g.tiles.forEach((e4) => {
            var t4;
            (null === (t4 = e4.image) || void 0 === t4 ? void 0 : t4.source) && (e4.image = e4.image.source), e4.objectgroup && (e4.objectgroup.type = "objectgroup", c(e4.objectgroup, "object", true));
          }), h.tiles = g.tiles;
          const u = { ...h, tiles: [], firstGid: h.firstgid, tileWidth: h.tilewidth, tileHeight: h.tileheight, tileCount: h.tilecount, tileOffset: h.tileoffset, tiledVersion: h.tiledversion, backgroundColor: h.backgroundcolor, transparentColor: h.transparentcolor, wangSets: h.wangsets, imageWidth: h.imagewidth, imageHeight: h.imageheight, objectAlignment: null !== (d2 = h.objectalignment) && void 0 !== d2 ? d2 : "unspecified", image: h.image, spacing: isNaN(h.spacing) ? 0 : h.spacing, horizontalFlipTransform: A2.Matrix.identity().translate(h.tilewidth, 0).scale(-1, 1), verticalFlipTransform: A2.Matrix.identity().translate(0, h.tileheight).scale(1, -1), diagonalFlipTransform: A2.Matrix.identity().translate(h.tilewidth, h.tileheight).rotate(-Math.PI / 2).scale(-1, 1) };
          return u.tiles = h.tiles.map((e4) => n.parse(e4, u)), u;
        }, d = (e3, t3, i3) => {
          var s3, r3;
          let a2 = [];
          e3.tiles = null !== (s3 = e3.tiles) && void 0 !== s3 ? s3 : [], (0, A2.vec)(e3.tilewidth / 2, e3.tileheight / 2);
          const o2 = { ...e3, source: i3, tiles: a2, firstGid: t3, tileWidth: e3.tilewidth, tileHeight: e3.tileheight, tileCount: e3.tilecount, tileOffset: e3.tileoffset, tiledVersion: e3.tiledversion, backgroundColor: e3.backgroundcolor, transparentColor: e3.transparentcolor, wangSets: e3.wangsets, imageWidth: e3.imagewidth, imageHeight: e3.imageheight, spacing: isNaN(e3.spacing) ? 0 : e3.spacing, objectAlignment: null !== (r3 = e3.objectalignment) && void 0 !== r3 ? r3 : "unspecified", image: e3.image, horizontalFlipTransform: A2.Matrix.identity().translate(e3.tilewidth, 0).scale(-1, 1), verticalFlipTransform: A2.Matrix.identity().translate(0, e3.tileheight).scale(1, -1), diagonalFlipTransform: A2.Matrix.identity().translate(e3.tilewidth, e3.tileheight).rotate(-Math.PI / 2).scale(-1, 1) };
          for (let t4 in e3.tiles)
            a2.push(n.parse({ ...e3.tiles[t4], id: +t4 }, o2));
          return o2;
        };
      }, "./src/deprecated/tiled-types.ts": (e2, t2, i2) => {
        "use strict";
        i2.r(t2);
      }, "./src/parser/tiled-parser.ts": (e2, t2, i2) => {
        "use strict";
        i2.r(t2), i2.d(t2, { TiledMap: () => O, TiledParser: () => q, TiledTemplate: () => R, TiledText: () => b, TiledTile: () => L, TiledTileLayer: () => B, TiledTileLayerInfinite: () => m, TiledTileset: () => M, TiledTilesetFile: () => G, isCSV: () => y, isInfiniteLayer: () => z, isTiledTilesetCollectionOfImages: () => S, isTiledTilesetEmbedded: () => P, isTiledTilesetExternal: () => U, isTiledTilesetSingleImage: () => F, needsDecoding: () => E });
        var A2 = i2("./node_modules/zod/lib/index.mjs");
        const s2 = A2.z.object({ name: A2.z.string(), type: A2.z.literal("int"), value: A2.z.number().int() }), r2 = A2.z.object({ name: A2.z.string(), type: A2.z.literal("bool"), value: A2.z.boolean() }), a = A2.z.object({ name: A2.z.string(), type: A2.z.literal("float"), value: A2.z.number() }), o = A2.z.object({ name: A2.z.string(), type: A2.z.literal("string"), value: A2.z.string() }), n = A2.z.object({ name: A2.z.string(), type: A2.z.literal("file"), value: A2.z.string() }), l = A2.z.object({ name: A2.z.string(), type: A2.z.literal("color"), value: A2.z.string() }), d = A2.z.object({ name: A2.z.string(), type: A2.z.literal("object"), value: A2.z.number() }), c = A2.z.discriminatedUnion("type", [s2, r2, a, o, n, l, d]), g = A2.z.object({ name: A2.z.string(), type: A2.z.literal("tilelayer"), class: A2.z.string().optional(), height: A2.z.number(), width: A2.z.number(), x: A2.z.number(), y: A2.z.number(), id: A2.z.number(), opacity: A2.z.number(), properties: A2.z.array(c).optional(), visible: A2.z.boolean(), tintcolor: A2.z.string().optional(), parallaxx: A2.z.number().optional(), parallaxy: A2.z.number().optional(), offsetx: A2.z.number().optional(), offsety: A2.z.number().optional() }), h = g.extend({ data: A2.z.array(A2.z.number()), encoding: A2.z.literal("csv") }), u = g.extend({ data: A2.z.array(A2.z.number()), encoding: A2.z.literal("base64"), compression: A2.z.literal("gzip") }), p = g.extend({ data: A2.z.array(A2.z.number()), encoding: A2.z.literal("base64"), compression: A2.z.literal("zlib") }), I = g.extend({ data: A2.z.array(A2.z.number()), encoding: A2.z.literal("base64"), compression: A2.z.literal("zstandard") }), f = g.extend({ data: A2.z.string(), encoding: A2.z.literal("base64"), compression: A2.z.string() }), C = A2.z.object({ x: A2.z.number(), y: A2.z.number(), width: A2.z.number(), height: A2.z.number(), data: A2.z.array(A2.z.number()) }), m = g.extend({ startx: A2.z.number(), starty: A2.z.number(), chunks: A2.z.array(C) }), B = A2.z.union([f, h, u, p, I, m]);
        function E(e3) {
          return "base64" === e3.encoding;
        }
        function y(e3) {
          return "csv" === e3.encoding || Array.isArray(e3.data);
        }
        const Q = A2.z.object({ x: A2.z.number(), y: A2.z.number() }), w = A2.z.array(Q), b = A2.z.object({ text: A2.z.string(), color: A2.z.string().optional(), fontfamily: A2.z.string().optional(), pixelsize: A2.z.number().optional(), wrap: A2.z.boolean().optional(), halign: A2.z.union([A2.z.literal("left"), A2.z.literal("center"), A2.z.literal("right"), A2.z.literal("justify")]).optional(), valign: A2.z.union([A2.z.literal("top"), A2.z.literal("center"), A2.z.literal("bottom")]).optional() }), _ = A2.z.object({ id: A2.z.number().optional(), name: A2.z.string().optional(), type: A2.z.string().optional(), x: A2.z.number().optional(), y: A2.z.number().optional(), rotation: A2.z.number().optional(), height: A2.z.number().optional(), width: A2.z.number().optional(), visible: A2.z.boolean().optional(), gid: A2.z.number().optional(), text: b.optional(), point: A2.z.boolean().optional(), ellipse: A2.z.boolean().optional(), polyline: A2.z.array(Q).optional(), polygon: w.optional(), template: A2.z.string().optional(), properties: A2.z.array(c).optional() }), v = A2.z.object({ duration: A2.z.number(), tileid: A2.z.number() }), x = A2.z.object({ name: A2.z.string(), draworder: A2.z.string(), type: A2.z.literal("objectgroup"), class: A2.z.string().optional(), x: A2.z.number(), y: A2.z.number(), id: A2.z.number(), color: A2.z.string().optional(), tintcolor: A2.z.string().optional(), parallaxx: A2.z.number().optional(), parallaxy: A2.z.number().optional(), offsetx: A2.z.number().optional(), offsety: A2.z.number().optional(), opacity: A2.z.number(), properties: A2.z.array(c).optional(), visible: A2.z.boolean(), objects: A2.z.array(_) }), T = A2.z.object({ name: A2.z.string(), x: A2.z.number(), y: A2.z.number(), id: A2.z.number(), type: A2.z.literal("imagelayer"), class: A2.z.string().optional(), image: A2.z.string().optional(), opacity: A2.z.number(), properties: A2.z.array(c).optional(), visible: A2.z.boolean(), tintcolor: A2.z.string().optional(), repeatx: A2.z.boolean().optional(), repeaty: A2.z.boolean().optional(), parallaxx: A2.z.number().optional(), parallaxy: A2.z.number().optional(), offsetx: A2.z.number().optional(), offsety: A2.z.number().optional(), transparentcolor: A2.z.string().optional() }), k = A2.z.union([T, B, x]), D = A2.z.object({ draworder: A2.z.string(), id: A2.z.number().optional(), name: A2.z.string(), x: A2.z.number(), y: A2.z.number(), opacity: A2.z.number(), tintcolor: A2.z.string().optional(), type: A2.z.literal("objectgroup"), visible: A2.z.boolean(), objects: A2.z.array(_), properties: A2.z.array(c).optional() }), L = A2.z.object({ id: A2.z.number(), type: A2.z.string().optional(), animation: A2.z.array(v).optional(), objectgroup: D.optional(), probability: A2.z.number().optional(), properties: A2.z.array(c).optional(), image: A2.z.string().optional(), imageheight: A2.z.number().optional(), imagewidth: A2.z.number().optional() }), N = A2.z.object({ name: A2.z.string(), firstgid: A2.z.number().optional(), class: A2.z.string().optional(), objectalignment: A2.z.union([A2.z.literal("topleft"), A2.z.literal("top"), A2.z.literal("topright"), A2.z.literal("left"), A2.z.literal("center"), A2.z.literal("right"), A2.z.literal("bottomleft"), A2.z.literal("bottom"), A2.z.literal("bottomright")]).optional(), image: A2.z.string().optional(), imagewidth: A2.z.number().optional(), imageheight: A2.z.number().optional(), columns: A2.z.number(), tileheight: A2.z.number(), tilewidth: A2.z.number(), tilecount: A2.z.number(), grid: A2.z.object({ height: A2.z.number(), width: A2.z.number(), orientation: A2.z.union([A2.z.literal("isometric"), A2.z.literal("orthogonal")]) }).optional(), tileoffset: Q.optional(), spacing: A2.z.number(), margin: A2.z.number(), tiles: A2.z.array(L).optional(), properties: A2.z.array(c).optional() });
        function F(e3) {
          return !!e3.image;
        }
        function S(e3) {
          return !e3.image;
        }
        const G = N.extend({ tiledversion: A2.z.string().optional(), type: A2.z.literal("tileset"), version: A2.z.string().optional() }), j = A2.z.object({ firstgid: A2.z.number(), source: A2.z.string() }), M = A2.z.union([N, j]), R = A2.z.object({ object: _.extend({ id: A2.z.number().optional() }), tileset: j.optional(), type: A2.z.literal("template") }), O = A2.z.object({ type: A2.z.string(), class: A2.z.string().optional(), tiledversion: A2.z.string(), version: A2.z.string(), width: A2.z.number(), height: A2.z.number(), tilewidth: A2.z.number(), tileheight: A2.z.number(), compressionlevel: A2.z.number().optional(), infinite: A2.z.boolean(), nextlayerid: A2.z.number(), nextobjectid: A2.z.number(), parallaxoriginx: A2.z.number().optional(), parallaxoriginy: A2.z.number().optional(), hexsidelength: A2.z.number().optional(), staggeraxis: A2.z.literal("y").or(A2.z.literal("x")).optional(), staggerindex: A2.z.literal("odd").or(A2.z.literal("even")).optional(), orientation: A2.z.union([A2.z.literal("isometric"), A2.z.literal("orthogonal"), A2.z.literal("staggered"), A2.z.literal("hexagonal")]), renderorder: A2.z.union([A2.z.literal("right-down"), A2.z.literal("right-up"), A2.z.literal("left-down"), A2.z.literal("left-up")]), backgroundcolor: A2.z.string().optional(), layers: A2.z.array(k), tilesets: A2.z.array(M), properties: A2.z.array(c).optional() });
        function z(e3) {
          return !!e3.chunks;
        }
        function P(e3) {
          return !e3.source;
        }
        function U(e3) {
          return !!e3.source;
        }
        class J {
          constructor(e3, t3, i3, A3) {
            this.x = e3, this.y = t3, this.width = i3, this.height = A3;
          }
          combine(e3) {
            const t3 = this.x + this.width, i3 = this.y + this.height, A3 = e3.x + e3.width, s3 = e3.y + e3.height, r3 = Math.max(t3, A3), a2 = Math.max(i3, s3);
            return new J(Math.min(this.x, e3.x), Math.min(this.y, e3.y), r3 - Math.min(this.x, e3.x), a2 - Math.min(this.y, e3.y));
          }
        }
        class q {
          constructor() {
            this._largestBounds = new J(0, 0, 0, 0);
          }
          _coerceNumber(e3) {
            return +e3;
          }
          _coerceBoolean(e3) {
            switch (e3) {
              case "0":
              case "false":
                return false;
              case "true":
                return true;
              default:
                return !!Boolean(e3);
            }
          }
          _coerceType(e3, t3) {
            return "bool" === e3 ? this._coerceBoolean(t3) : "int" === e3 || "float" === e3 || "object" === e3 ? this._coerceNumber(t3) : t3;
          }
          _parsePropertiesNode(e3, t3) {
            var i3;
            const A3 = [];
            if (e3)
              for (let t4 of e3.children) {
                const e4 = null !== (i3 = t4.getAttribute("type")) && void 0 !== i3 ? i3 : "string";
                let s3 = t4.getAttribute("value");
                s3 || (s3 = t4.innerHTML), A3.push({ name: t4.getAttribute("name"), type: e4, value: this._coerceType(e4, s3) });
              }
            t3.properties = A3;
          }
          _parseAttributes(e3, t3) {
            const i3 = ["width", "height", "columns", "firstgid", "spacing", "margin", "tilecount", "tilewidth", "tileheight", "opacity", "compressionlevel", "nextlayerid", "nextobjectid", "parallaxoriginx", "parallaxoriginy", "parallaxx", "parallaxy", "hexsidelength", "offsetx", "offsety", "id", "gid", "x", "y", "rotation", "probability"], A3 = ["infinite", "visible", "repeatx", "repeaty"];
            for (let s3 of e3.attributes)
              i3.indexOf(s3.name) > -1 ? t3[s3.name] = this._coerceNumber(s3.value) : A3.indexOf(s3.name) > -1 ? t3[s3.name] = this._coerceBoolean(s3.value) : t3[s3.name] = s3.value;
          }
          _parseToDocument(e3) {
            if ("undefined" != typeof DOMParser)
              return new DOMParser().parseFromString(e3, "application/xml");
            try {
              const { JSDOM: t4 } = i2("jsdom");
              return new t4(e3, { contentType: "application/xml", encoding: "utf-8" }).window.document;
            } catch (e4) {
            }
            const t3 = new Error("Could not find DOM parser");
            throw console.error(t3.message, t3), t3;
          }
          parseObject(e3, t3 = true) {
            var i3, A3;
            const s3 = { type: "", x: 0, y: 0 };
            e3.getAttribute("template") || (s3.visible = true, s3.name = "", s3.rotation = 0, s3.height = 0, s3.width = 0), this._parseAttributes(e3, s3);
            const r3 = e3.querySelector("properties");
            r3 && this._parsePropertiesNode(r3, s3);
            const a2 = e3.querySelector("text");
            if (a2) {
              s3.text = { text: a2.textContent };
              const e4 = a2.getAttribute("fontfamily");
              e4 && (s3.text.fontfamily = e4);
              const t4 = a2.getAttribute("color");
              t4 && (s3.text.color = t4);
              const i4 = a2.getAttribute("pixelsize");
              i4 && (s3.text.pixelsize = this._coerceNumber(i4));
              const A4 = a2.getAttribute("wrap");
              A4 && (s3.text.wrap = this._coerceBoolean(A4));
              const r4 = a2.getAttribute("valign");
              r4 && (s3.text.valign = r4);
              const o3 = a2.getAttribute("halign");
              o3 && (s3.text.halign = o3);
            }
            e3.querySelector("point") && (s3.point = true), e3.querySelector("ellipse") && (s3.ellipse = true);
            const o2 = e3.querySelector("polygon");
            if (o2) {
              const e4 = null === (i3 = o2.getAttribute("points")) || void 0 === i3 ? void 0 : i3.split(" ");
              s3.polygon = [], e4 && e4.forEach((e5) => {
                const t4 = e5.split(",");
                s3.polygon.push({ x: +t4[0], y: +t4[1] });
              });
            }
            const n2 = e3.querySelector("polyline");
            if (n2) {
              const e4 = null === (A3 = n2.getAttribute("points")) || void 0 === A3 ? void 0 : A3.split(" ");
              s3.polyline = [], e4 && e4.forEach((e5) => {
                const t4 = e5.split(",");
                s3.polyline.push({ x: +t4[0], y: +t4[1] });
              });
            }
            if (t3)
              try {
                return _.parse(s3);
              } catch (e4) {
                throw console.error("Could not parse object", s3, e4), e4;
              }
            return s3;
          }
          parseTileset(e3, t3 = true) {
            const i3 = { spacing: 0, margin: 0 };
            if (this._parseAttributes(e3, i3), i3.source)
              try {
                return M.parse(i3);
              } catch (e4) {
                console.error("Could not parse external tileset", i3, e4);
              }
            for (let A3 of e3.children)
              switch (A3.tagName) {
                case "properties":
                  this._parsePropertiesNode(A3, i3);
                  break;
                case "tileoffset": {
                  const e4 = {};
                  this._parseAttributes(A3, e4), i3.tileoffset = e4;
                  break;
                }
                case "grid": {
                  const e4 = {};
                  this._parseAttributes(A3, e4), i3.grid = e4;
                  break;
                }
                case "image":
                  i3.image = A3.getAttribute("source"), i3.imagewidth = this._coerceNumber(A3.getAttribute("width")), i3.imageheight = this._coerceNumber(A3.getAttribute("height"));
                  break;
                case "tile": {
                  i3.tiles || (i3.tiles = []);
                  const e4 = {};
                  this._parseAttributes(A3, e4);
                  for (let i4 of A3.children)
                    switch (i4.tagName) {
                      case "image":
                        e4.image = i4.getAttribute("source"), e4.imagewidth = this._coerceNumber(i4.getAttribute("width")), e4.imageheight = this._coerceNumber(i4.getAttribute("height"));
                        break;
                      case "objectgroup": {
                        const A4 = { type: "objectgroup", name: "", visible: true, x: 0, y: 0, opacity: 1, objects: [] };
                        this._parseAttributes(i4, A4), e4.objectgroup = A4;
                        for (let e5 of i4.children) {
                          const i5 = this.parseObject(e5, t3);
                          A4.objects.push(i5);
                        }
                        break;
                      }
                      case "animation": {
                        const t4 = [];
                        for (let e5 of i4.children)
                          t4.push({ duration: this._coerceNumber(e5.getAttribute("duration")), tileid: this._coerceNumber(e5.getAttribute("tileid")) });
                        e4.animation = t4;
                        break;
                      }
                      case "properties":
                        this._parsePropertiesNode(i4, e4);
                    }
                  if (t3)
                    try {
                      i3.tiles.push(L.parse(e4));
                    } catch (t4) {
                      throw console.error("Could not parse Tile", e4, t4), t4;
                    }
                  else
                    i3.tiles.push(e4);
                  break;
                }
              }
            if (t3)
              try {
                return M.parse(i3);
              } catch (e4) {
                throw console.error("Could not parse Tileset", i3, e4), e4;
              }
            return i3;
          }
          parseTileLayer(e3, t3, i3 = true) {
            var A3, s3, r3;
            const a2 = { type: "tilelayer", compression: "", x: 0, y: 0, opacity: 1, visible: true };
            this._parseAttributes(e3, a2);
            for (let i4 of e3.children)
              switch (i4.tagName) {
                case "properties":
                  this._parsePropertiesNode(i4, a2);
                  break;
                case "data":
                  if (t3) {
                    a2.width = 0, a2.height = 0, a2.chunks = [];
                    let e4 = new J(0, 0, 0, 0);
                    for (let t4 of i4.children)
                      if ("chunk" === t4.tagName) {
                        const i5 = {};
                        this._parseAttributes(t4, i5), i5.data = null === (A3 = t4.textContent) || void 0 === A3 ? void 0 : A3.split(",").map((e5) => +e5);
                        const s4 = new J(i5.x, i5.y, i5.width, i5.height);
                        e4 = e4.combine(s4), a2.chunks.push(i5);
                      }
                    a2.width = e4.width, a2.height = e4.height, a2.startx = e4.x, a2.starty = e4.y, this._largestBounds = this._largestBounds.combine(new J(a2.startx, a2.starty, a2.width, a2.height));
                  } else {
                    const e4 = i4.getAttribute("encoding");
                    a2.encoding = e4;
                    const t4 = i4.getAttribute("compression");
                    switch (t4 && (a2.compression = t4), a2.encoding) {
                      case "base64":
                        a2.data = null === (s3 = i4.textContent) || void 0 === s3 ? void 0 : s3.trim();
                        break;
                      case "csv":
                        a2.data = null === (r3 = i4.textContent) || void 0 === r3 ? void 0 : r3.split(",").map((e5) => +e5);
                    }
                  }
              }
            if (i3)
              try {
                return k.parse(a2);
              } catch (e4) {
                throw console.error("Could not parse tiled tile layer", a2, e4), e4;
              }
            return a2;
          }
          parseObjectGroup(e3, t3 = true) {
            const i3 = { type: "objectgroup", draworder: "topdown", visible: true, x: 0, y: 0, opacity: 1, objects: [] };
            this._parseAttributes(e3, i3);
            for (let A3 of e3.children)
              switch (A3.tagName) {
                case "properties":
                  this._parsePropertiesNode(A3, i3);
                  break;
                case "object": {
                  const e4 = this.parseObject(A3, t3);
                  i3.objects.push(e4);
                  break;
                }
              }
            if (t3)
              try {
                return k.parse(i3);
              } catch (e4) {
                throw console.error("Could not parse object group", i3, e4), e4;
              }
            return i3;
          }
          parseImageLayer(e3, t3 = true) {
            const i3 = { type: "imagelayer", visible: true, x: 0, y: 0, opacity: 1 }, A3 = e3.querySelector("image");
            i3.image = null == A3 ? void 0 : A3.getAttribute("source");
            const s3 = e3.querySelector("properties");
            s3 && this._parsePropertiesNode(s3, i3);
            const r3 = null == A3 ? void 0 : A3.getAttribute("trans");
            if (r3 && (i3.transparentcolor = "#" + r3), this._parseAttributes(e3, i3), t3)
              try {
                return k.parse(i3);
              } catch (e4) {
                throw console.error("Could not parse layer", i3, e4), e4;
              }
            return i3;
          }
          parseExternalTemplate(e3, t3 = true) {
            const i3 = this._parseToDocument(e3).querySelector("template"), A3 = { type: "template" }, s3 = i3.querySelector("object");
            s3 && (A3.object = this.parseObject(s3, t3));
            const r3 = i3.querySelector("tileset");
            if (r3 && (A3.tileset = this.parseTileset(r3, t3)), t3)
              try {
                return R.parse(A3);
              } catch (e4) {
                throw console.error("Could not parse template", A3, e4), e4;
              }
            return A3;
          }
          parseExternalTileset(e3, t3 = true) {
            const i3 = this._parseToDocument(e3).querySelector("tileset"), A3 = this.parseTileset(i3, t3);
            if (A3.type = "tileset", this._parseAttributes(i3, A3), t3)
              try {
                return G.parse(A3);
              } catch (e4) {
                throw console.error("Could not parse tileset file", A3, e4), e4;
              }
            return A3;
          }
          parse(e3, t3 = true) {
            const i3 = this._parseToDocument(e3).querySelector("map"), A3 = { type: "map", compressionlevel: -1, layers: [], tilesets: [] };
            this._parseAttributes(i3, A3);
            const s3 = (e4, t4 = true) => {
              switch (e4.tagName) {
                case "group":
                  for (let i4 of e4.children)
                    s3(i4, t4);
                  break;
                case "layer": {
                  const i4 = this.parseTileLayer(e4, A3.infinite, t4);
                  A3.layers.push(i4);
                  break;
                }
                case "properties":
                  this._parsePropertiesNode(e4, A3);
                  break;
                case "tileset": {
                  const i4 = this.parseTileset(e4, t4);
                  A3.tilesets.push(i4);
                  break;
                }
                case "objectgroup": {
                  const i4 = this.parseObjectGroup(e4, t4);
                  A3.layers.push(i4);
                  break;
                }
                case "imagelayer": {
                  const i4 = this.parseImageLayer(e4, t4);
                  A3.layers.push(i4);
                  break;
                }
              }
            };
            for (let e4 of i3.children)
              s3(e4, t3);
            if (t3)
              try {
                return O.parse(A3);
              } catch (e4) {
                throw console.error("Could not parse Tiled map", e4), e4;
              }
            return A3;
          }
        }
      }, "./src/resource/decoder.ts": (e2, t2, i2) => {
        "use strict";
        i2.r(t2), i2.d(t2, { Decoder: () => r2 });
        var A2 = i2("./node_modules/pako/index.js"), s2 = i2("./node_modules/zstddec/dist/zstddec.modern.js");
        class r2 {
          static decode(e3, t3) {
            var i3, r3, a, o, n, l;
            if (e3.length % 4 > 0)
              throw new Error("Invalid string. Length must be a multiple of 4");
            var d = "+".charCodeAt(0), c = "/".charCodeAt(0), g = "0".charCodeAt(0), h = "a".charCodeAt(0), u = "A".charCodeAt(0), p = "-".charCodeAt(0), I = "_".charCodeAt(0);
            function f(e4) {
              var t4 = e4.charCodeAt(0);
              if (t4 === d || t4 === p)
                return 62;
              if (t4 === c || t4 === I)
                return 63;
              if (t4 < g)
                return -1;
              if (t4 < g + 10)
                return t4 - g + 26 + 26;
              if (t4 < u + 26)
                return t4 - u;
              if (t4 < h + 26)
                return t4 - h + 26;
              throw Error("Could not decode elt");
            }
            var C = e3.length;
            n = "=" === e3.charAt(C - 2) ? 2 : "=" === e3.charAt(C - 1) ? 1 : 0, l = new Uint8Array(3 * e3.length / 4 - n), a = n > 0 ? e3.length - 4 : e3.length;
            var m = 0;
            function B(e4) {
              l[m++] = e4;
            }
            for (i3 = 0, r3 = 0; i3 < a; i3 += 4, r3 += 3)
              B((16711680 & (o = f(e3.charAt(i3)) << 18 | f(e3.charAt(i3 + 1)) << 12 | f(e3.charAt(i3 + 2)) << 6 | f(e3.charAt(i3 + 3)))) >> 16), B((65280 & o) >> 8), B(255 & o);
            return 2 === n ? B(255 & (o = f(e3.charAt(i3)) << 2 | f(e3.charAt(i3 + 1)) >> 4)) : 1 === n && (B((o = f(e3.charAt(i3)) << 10 | f(e3.charAt(i3 + 1)) << 4 | f(e3.charAt(i3 + 2)) >> 2) >> 8 & 255), B(255 & o)), new Promise((e4) => {
              const r4 = function(e5) {
                for (var t4 = 0, i4 = e5.length - 1; i4 >= 0; i4--)
                  t4 = 256 * t4 + 1 * e5[i4];
                return t4;
              };
              if ("zlib" === t3 || "gzip" === t3) {
                var a2 = (l = (0, A2.inflate)(l)).length / 4, o2 = new Array(a2);
                for (i3 = 0; i3 < a2; i3++)
                  o2[i3] = r4(l.slice(4 * i3, 4 * i3 + 4));
                e4(o2);
              }
              if ("zstd" === t3) {
                const t4 = new s2.ZSTDDecoder();
                t4.init().then(() => {
                  var A3 = (l = t4.decode(l)).length / 4, s3 = new Array(A3);
                  for (i3 = 0; i3 < A3; i3++)
                    s3[i3] = r4(l.slice(4 * i3, 4 * i3 + 4));
                  e4(s3);
                });
              }
              if (!t3) {
                for (a2 = l.length / 4, o2 = new Array(a2), i3 = 0; i3 < a2; i3++)
                  o2[i3] = r4(l.slice(4 * i3, 4 * i3 + 4));
                e4(o2);
              }
            });
          }
        }
      }, "./src/resource/excalibur-properties.ts": (e2, t2, i2) => {
        "use strict";
        i2.r(t2), i2.d(t2, { ExcaliburTiledProperties: () => A2 });
        const A2 = { TileData: { Tiled: "ex-tiled" }, ZIndex: { ZIndex: "zindex" }, Camera: { Camera: "camera", Zoom: "zoom" }, Animation: { Strategy: "animationstrategy" }, Layer: { Solid: "solid" }, Collision: { Type: "collisiontype" } };
      }, "./src/resource/file-loader.ts": (e2, t2, i2) => {
        "use strict";
        i2.r(t2), i2.d(t2, { FetchLoader: () => A2 });
        const A2 = async (e3, t3) => {
          const i3 = await fetch(e3);
          switch (t3.toLowerCase()) {
            case "xml":
            default:
              return await i3.text();
            case "json":
              return await i3.json();
          }
        };
      }, "./src/resource/filter-util.ts": (e2, t2, i2) => {
        "use strict";
        i2.r(t2), i2.d(t2, { byClassCaseInsensitive: () => s2, byNameCaseInsensitive: () => A2, byPropertyCaseInsensitive: () => r2 });
        const A2 = (e3) => (t3) => (null == t3 ? void 0 : t3.name) && e3 ? 0 === t3.name.toLocaleLowerCase().localeCompare(e3.toLocaleLowerCase()) : (null == t3 ? void 0 : t3.name) === e3, s2 = (e3) => (t3) => (null == t3 ? void 0 : t3.class) && e3 ? 0 === t3.class.toLocaleLowerCase().localeCompare(e3.toLocaleLowerCase()) : (null == t3 ? void 0 : t3.class) === e3, r2 = (e3, t3) => (i3) => {
          const A3 = ((e4) => {
            const t4 = /* @__PURE__ */ new Map();
            for (let [i4, A4] of e4) {
              let e5 = A4;
              "string" == typeof A4 && (e5 = A4.toLocaleLowerCase()), t4.set(i4.toLocaleLowerCase(), e5);
            }
            return t4;
          })(i3.properties);
          if (void 0 !== t3) {
            let i4 = t3;
            return "string" == typeof t3 && (i4 = t3.toLocaleLowerCase()), A3.get(e3.toLocaleLowerCase()) === i4;
          }
          return A3.has(e3.toLocaleLowerCase());
        };
      }, "./src/resource/gid-util.ts": (e2, t2, i2) => {
        "use strict";
        i2.r(t2), i2.d(t2, { FLIPPED_DIAGONALLY_FLAG: () => r2, FLIPPED_HORIZONTALLY_FLAG: () => A2, FLIPPED_VERTICALLY_FLAG: () => s2, getCanonicalGid: () => l, isFlippedDiagonally: () => n, isFlippedHorizontally: () => a, isFlippedVertically: () => o });
        const A2 = 2147483648, s2 = 1073741824, r2 = 536870912, a = (e3) => !!(e3 & A2), o = (e3) => !!(e3 & s2), n = (e3) => !!(e3 & r2), l = (e3) => e3 & ~(A2 | s2 | r2);
      }, "./src/resource/image-layer.ts": (e2, t2, i2) => {
        "use strict";
        i2.r(t2), i2.d(t2, { ImageLayer: () => a });
        var A2 = i2("excalibur"), s2 = i2("./src/resource/properties.ts"), r2 = i2("./src/resource/path-util.ts");
        class a {
          constructor(e3, t3, i3) {
            this.tiledImageLayer = e3, this.resource = t3, this.order = i3, this.properties = /* @__PURE__ */ new Map(), this.image = null, this.imageActor = null, this.name = e3.name, this.class = e3.class, (0, s2.mapProps)(this, e3.properties), e3.image && (this.image = new A2.ImageSource((0, r2.pathRelativeToBase)(this.resource.path, e3.image, this.resource.pathMap)));
          }
          async load() {
            var e3, t3, i3, s3;
            const r3 = this.tiledImageLayer.opacity, a2 = !!this.tiledImageLayer.tintcolor, o = this.tiledImageLayer.tintcolor ? A2.Color.fromHex(this.tiledImageLayer.tintcolor) : A2.Color.White, n = (0, A2.vec)(null !== (e3 = this.tiledImageLayer.offsetx) && void 0 !== e3 ? e3 : 0, null !== (t3 = this.tiledImageLayer.offsety) && void 0 !== t3 ? t3 : 0), l = null !== (i3 = this.tiledImageLayer.parallaxx) && void 0 !== i3 ? i3 : 1, d = null !== (s3 = this.tiledImageLayer.parallaxy) && void 0 !== s3 ? s3 : 1;
            if (this.image) {
              this.resource.headless || await this.image.load(), this.imageActor = new A2.Actor({ name: this.tiledImageLayer.name, pos: n, anchor: A2.Vector.Zero, z: this.order }), this.imageActor.addComponent(new A2.ParallaxComponent((0, A2.vec)(l, d)));
              const e4 = this.image.toSprite();
              this.imageActor.graphics.use(e4), this.imageActor.graphics.visible = this.tiledImageLayer.visible, this.imageActor.graphics.opacity = r3, a2 && (e4.tint = o);
            }
          }
        }
      }, "./src/resource/iso-tile-layer.ts": (e2, t2, i2) => {
        "use strict";
        i2.r(t2), i2.d(t2, { IsoTileLayer: () => c });
        var A2 = i2("excalibur"), s2 = i2("./src/resource/properties.ts"), r2 = i2("./src/parser/tiled-parser.ts"), a = i2("./src/resource/decoder.ts"), o = i2("./src/resource/gid-util.ts"), n = i2("./src/resource/excalibur-properties.ts"), l = i2("./src/resource/tiled-layer-component.ts"), d = i2("./src/resource/filter-util.ts");
        class c {
          constructor(e3, t3, i3) {
            this.tiledTileLayer = e3, this.resource = t3, this.order = i3, this.logger = A2.Logger.getInstance(), this.width = 0, this.height = 0, this.properties = /* @__PURE__ */ new Map(), this.data = [], this._gidToTileInfo = /* @__PURE__ */ new Map(), this.name = e3.name, this.class = e3.class, this.width = e3.width, this.height = e3.height, (0, s2.mapProps)(this, e3.properties);
          }
          getTilesByGid(e3) {
            var t3;
            return null !== (t3 = this._gidToTileInfo.get(e3)) && void 0 !== t3 ? t3 : [];
          }
          getTilesByClassName(e3) {
            return this.isometricMap.tiles.filter((t3) => {
              const i3 = t3.data.get(n.ExcaliburTiledProperties.TileData.Tiled);
              return !!i3 && (0, d.byClassCaseInsensitive)(e3)(i3);
            }).map((e4) => ({ exTile: e4, tiledTile: e4.data.get(n.ExcaliburTiledProperties.TileData.Tiled) }));
          }
          getTilesByProperty(e3, t3) {
            return this.isometricMap.tiles.filter((i3) => {
              const A3 = i3.data.get(n.ExcaliburTiledProperties.TileData.Tiled);
              return !!A3 && (0, d.byPropertyCaseInsensitive)(e3, t3)(A3);
            }).map((e4) => ({ exTile: e4, tiledTile: e4.data.get(n.ExcaliburTiledProperties.TileData.Tiled) }));
          }
          getTileByPoint(e3) {
            if (!this.isometricMap)
              return this.logger.warn("IsometricMap has not yet been loaded! getTileByPoint() will only return null"), null;
            if (this.isometricMap) {
              const t3 = this.isometricMap.getTileByPoint(e3);
              if (!t3)
                return null;
              const i3 = this.isometricMap.tiles.indexOf(t3), A3 = (0, o.getCanonicalGid)(this.data[i3]);
              return A3 <= 0 ? null : { tiledTile: this.resource.getTilesetForTileGid(A3).getTileByGid(A3), exTile: t3 };
            }
            return null;
          }
          _recordTileData(e3, t3) {
            let i3 = this._gidToTileInfo.get(e3), A3 = this.resource.getTilesetForTileGid(e3).getTileByGid(e3);
            i3 ? i3.push({ exTile: t3, tiledTile: A3 }) : i3 = [{ exTile: t3, tiledTile: A3 }], this._gidToTileInfo.set(e3, i3), t3.data.set(n.ExcaliburTiledProperties.TileData.Tiled, A3);
          }
          updateTile(e3, t3, i3, s3, r3) {
            this._recordTileData(t3, e3), this.resource.useExcaliburWiring && r3 && (e3.solid = true);
            const a2 = e3.get(A2.IsometricEntityComponent);
            a2 && (a2.elevation = this.order);
            const o2 = this.resource.getTilesetForTileGid(t3);
            let l2 = o2.getSpriteForGid(t3);
            i3 && (l2 = l2.clone(), l2.tint = s3), e3.addGraphic(l2, { offset: o2.tileOffset });
            let d2 = e3.pos;
            if ("orthogonal" === o2.orientation)
              d2 = (0, A2.vec)(0, 0);
            else {
              const e4 = this.resource.map.tilewidth / 2, t4 = this.resource.map.tileheight;
              d2 = (0, A2.vec)(e4, t4);
            }
            const c2 = o2.getCollidersForGid(t3, { offset: d2 });
            for (let t4 of c2)
              e3.addCollider(t4);
            let g = o2.getAnimationForGid(t3);
            if (g && (i3 && (g = g.clone(), g.tint = s3), e3.clearGraphics(), e3.addGraphic(g, { offset: o2.tileOffset }), this.resource.useExcaliburWiring)) {
              const e4 = o2.getTileByGid(t3), i4 = null == e4 ? void 0 : e4.properties.get(n.ExcaliburTiledProperties.Animation.Strategy);
              if (i4 && "string" == typeof i4)
                switch (i4.toLowerCase()) {
                  case A2.AnimationStrategy.End.toLowerCase():
                    g.strategy = A2.AnimationStrategy.End;
                    break;
                  case A2.AnimationStrategy.Freeze.toLowerCase():
                    g.strategy = A2.AnimationStrategy.Freeze;
                    break;
                  case A2.AnimationStrategy.Loop.toLowerCase():
                    g.strategy = A2.AnimationStrategy.Loop;
                    break;
                  case A2.AnimationStrategy.PingPong.toLowerCase():
                    g.strategy = A2.AnimationStrategy.PingPong;
                    break;
                  default:
                    this.logger.warn(`Unknown animation strategy in tileset ${o2.name} on tile gid ${t3}: ${i4}`);
                }
            }
          }
          async load() {
            var e3, t3, i3, s3;
            const o2 = this.tiledTileLayer, d2 = !!this.properties.get(n.ExcaliburTiledProperties.Layer.Solid), c2 = (this.tiledTileLayer.opacity, !!this.tiledTileLayer.tintcolor), g = this.tiledTileLayer.tintcolor ? A2.Color.fromHex(this.tiledTileLayer.tintcolor) : A2.Color.Transparent, h = (0, A2.vec)(null !== (e3 = o2.offsetx) && void 0 !== e3 ? e3 : 0, null !== (t3 = o2.offsety) && void 0 !== t3 ? t3 : 0);
            (0, r2.needsDecoding)(this.tiledTileLayer) ? this.data = await a.Decoder.decode(this.tiledTileLayer.data, this.tiledTileLayer.compression) : (0, r2.isCSV)(this.tiledTileLayer) && (this.data = this.tiledTileLayer.data);
            let u = this.order, p = this.properties.get(n.ExcaliburTiledProperties.ZIndex.ZIndex);
            if ("number" == typeof p && (u = p), this.resource.map.infinite && (0, r2.isInfiniteLayer)(this.tiledTileLayer)) {
              const e4 = this.resource.isometricTiledCoordToWorld(this.tiledTileLayer.startx, this.tiledTileLayer.starty), t4 = (0, A2.vec)(e4.x * this.resource.map.tilewidth, e4.y * this.resource.map.tileheight);
              this.isometricMap = new A2.IsometricMap({ name: this.name, pos: h.add(t4), tileHeight: this.resource.map.tileheight, tileWidth: this.resource.map.tilewidth, columns: o2.width, rows: o2.height, elevation: u });
            } else
              this.isometricMap = new A2.IsometricMap({ name: this.name, pos: h, tileWidth: this.resource.map.tilewidth, tileHeight: this.resource.map.tileheight, columns: o2.width, rows: o2.height, elevation: u });
            if (this.isometricMap.visible = this.tiledTileLayer.visible, this.isometricMap.opacity = this.tiledTileLayer.opacity, this.isometricMap.addComponent(new l.TiledLayerDataComponent({ tiledTileLayer: o2 })), o2.parallaxx || o2.parallaxy) {
              const e4 = (0, A2.vec)(null !== (i3 = o2.parallaxx) && void 0 !== i3 ? i3 : 1, null !== (s3 = o2.parallaxy) && void 0 !== s3 ? s3 : 1);
              this.isometricMap.addComponent(new A2.ParallaxComponent(e4));
            }
            if (this.resource.map.infinite && (0, r2.isInfiniteLayer)(this.tiledTileLayer))
              for (let e4 of this.tiledTileLayer.chunks)
                for (let t4 = 0; t4 < e4.data.length; t4++) {
                  const i4 = e4.data[t4];
                  if (0 != i4) {
                    const A3 = t4 % e4.width + (e4.x - this.tiledTileLayer.startx), s4 = Math.floor(t4 / e4.width) + (e4.y - this.tiledTileLayer.starty), r3 = this.isometricMap.tiles[A3 + s4 * o2.width];
                    this.updateTile(r3, i4, c2, g, d2);
                  }
                }
            else
              for (let e4 = 0; e4 < this.data.length; e4++) {
                let t4 = this.data[e4];
                if (0 !== t4) {
                  const i4 = this.isometricMap.tiles[e4];
                  this.updateTile(i4, t4, c2, g, d2);
                }
              }
          }
        }
      }, "./src/resource/layer.ts": (e2, t2, i2) => {
        "use strict";
        i2.r(t2);
      }, "./src/resource/loader-cache.ts": (e2, t2, i2) => {
        "use strict";
        i2.r(t2), i2.d(t2, { LoaderCache: () => A2 });
        class A2 {
          constructor(e3) {
            this.type = e3, this._loaded = false, this.cache = /* @__PURE__ */ new Map();
          }
          getOrAdd(...e3) {
            let t3 = this.cache.get(e3.join("+"));
            return t3 || (t3 = new this.type(...e3), this.cache.set(e3.join("+"), t3), t3);
          }
          values() {
            if (this._loaded)
              return Array.from(this.cache.values());
            throw new Error("Read through cache not yet loaded! No values to return!");
          }
          async load() {
            const e3 = Array.from(this.cache.entries()), t3 = await Promise.allSettled(e3.map((e4) => e4[1].load()));
            let i3 = 0;
            for (let A3 = 0; A3 < t3.length; A3++) {
              const s2 = t3[A3];
              "rejected" === s2.status && (console.error(`Error loading resource at ${e3[A3][0]}, is your pathMap correct? or your Tiled map corrupted?`, s2.reason), i3++);
            }
            if (i3)
              throw new Error(`Error loading ${i3} resources`);
            this._loaded = true;
          }
        }
      }, "./src/resource/object-layer.ts": (e2, t2, i2) => {
        "use strict";
        i2.r(t2), i2.d(t2, { ObjectLayer: () => l });
        var A2 = i2("excalibur"), s2 = i2("./src/resource/objects.ts"), r2 = i2("./src/resource/properties.ts"), a = i2("./src/resource/filter-util.ts"), o = i2("./src/resource/excalibur-properties.ts"), n = i2("./src/resource/tiled-data-component.ts");
        class l {
          constructor(e3, t3, i3) {
            this.tiledObjectLayer = e3, this.resource = t3, this.order = i3, this.logger = A2.Logger.getInstance(), this.properties = /* @__PURE__ */ new Map(), this.objects = [], this.entities = [], this._objectToEntity = /* @__PURE__ */ new Map(), this._entityToObject = /* @__PURE__ */ new Map(), this._loaded = false, this.name = e3.name, this.class = e3.class, (0, r2.mapProps)(this, e3.properties);
          }
          _logLoadedWarning(e3) {
            this.logger.warn(`ObjectLayer ${this.name} is not yet loaded, ${e3}() will always be empty!`);
          }
          getObjectsByName(e3) {
            return this._loaded || this._logLoadedWarning("getObjectsByName"), this.objects.filter((0, a.byNameCaseInsensitive)(e3));
          }
          getEntitiesByName(e3) {
            return this._loaded || this._logLoadedWarning("getEntitiesByName"), this.entities.filter((0, a.byNameCaseInsensitive)(e3));
          }
          getEntityByObject(e3) {
            return this._loaded || this._logLoadedWarning("getEntityByObject"), this._objectToEntity.get(e3);
          }
          getObjectByEntity(e3) {
            return this._loaded || this._logLoadedWarning("getObjectByEntity"), this._entityToObject.get(e3);
          }
          getObjectsByProperty(e3, t3) {
            return this._loaded || this._logLoadedWarning("getObjectsByProperty"), this.objects.filter((0, a.byPropertyCaseInsensitive)(e3, t3));
          }
          getEntitiesByProperty(e3, t3) {
            return this._loaded || this._logLoadedWarning("getEntitiesByProperty"), this.getObjectsByProperty(e3, t3).map((e4) => this._objectToEntity.get(e4)).filter((e4) => !!e4);
          }
          getObjectsByClassName(e3) {
            return this._loaded || this._logLoadedWarning("getObjectsByClassName"), this.objects.filter((0, a.byClassCaseInsensitive)(e3));
          }
          getEntitiesByClassName(e3) {
            return this._loaded || this._logLoadedWarning("getEntitiesByClassName"), this.getObjectsByClassName(e3).map((e4) => this._objectToEntity.get(e4)).filter((e4) => !!e4);
          }
          getTemplates() {
            return this._loaded || this._logLoadedWarning("getTemplates"), this.objects.filter((e3) => e3 instanceof s2.TemplateObject);
          }
          runFactory(e3) {
            var t3, i3, r3, a2;
            const o2 = (0, A2.vec)(null !== (t3 = this.tiledObjectLayer.offsetx) && void 0 !== t3 ? t3 : 0, null !== (i3 = this.tiledObjectLayer.offsety) && void 0 !== i3 ? i3 : 0), n2 = this.objects.slice();
            for (let t4 of n2) {
              let i4 = t4.class;
              if (t4 instanceof s2.TemplateObject && (i4 = i4 || t4.template.object.class), e3 !== i4)
                continue;
              let n3 = (0, A2.vec)((null !== (r3 = t4.x) && void 0 !== r3 ? r3 : 0) + o2.x, (null !== (a2 = t4.y) && void 0 !== a2 ? a2 : 0) + o2.y);
              "isometric" === this.resource.map.orientation && (n3 = this.resource.isometricTiledCoordToWorld(n3.x, n3.y));
              const l2 = this.resource.factories.get(e3);
              if (l2) {
                const e4 = l2({ worldPos: n3, name: t4.name, class: i4, layer: this, object: t4, properties: t4.properties });
                e4 && this._recordObjectEntityMapping(t4, e4);
              }
            }
          }
          _actorFromObject(e3, t3, i3) {
            var r3, a2, o2, n2, l2, d;
            const c = this.resource.headless, g = !!this.tiledObjectLayer.tintcolor, h = this.tiledObjectLayer.tintcolor ? A2.Color.fromHex(this.tiledObjectLayer.tintcolor) : A2.Color.White;
            if (e3 instanceof s2.InsertedTile && i3) {
              const s3 = "isometric" === this.resource.map.orientation && "orthogonal" === i3.orientation ? "bottom" : void 0, u = i3.getTilesetAlignmentAnchor(s3);
              t3.anchor = u;
              const p = (null !== (r3 = e3.tiledObject.width) && void 0 !== r3 ? r3 : this.resource.map.tilewidth) / this.resource.map.tilewidth, I = (null !== (a2 = e3.tiledObject.width) && void 0 !== a2 ? a2 : this.resource.map.tilewidth) / this.resource.map.tilewidth, f = (0, A2.vec)(p, I);
              if (!c) {
                const A3 = i3.getSpriteForGid(e3.gid).clone();
                A3.destSize.width = null !== (o2 = e3.tiledObject.width) && void 0 !== o2 ? o2 : A3.width, A3.destSize.height = null !== (n2 = e3.tiledObject.height) && void 0 !== n2 ? n2 : A3.height, g && (A3.tint = h), t3.graphics.use(A3), t3.graphics.offset = i3.tileOffset;
                const s4 = i3.getAnimationForGid(e3.gid);
                if (s4) {
                  const e4 = s4.clone();
                  e4.scale = f, g && (e4.tint = h), t3.graphics.use(e4), t3.graphics.offset = i3.tileOffset;
                }
              }
              const C = null !== (l2 = e3.tiledObject.width) && void 0 !== l2 ? l2 : 0, m = null !== (d = e3.tiledObject.height) && void 0 !== d ? d : 0, B = -C * u.x, E = -m * u.y, y = this.resource.map.tilewidth / 2, Q = this.resource.map.tileheight;
              let w = (0, A2.vec)(B, E);
              "isometric" === this.resource.map.orientation && (w = (0, A2.vec)(B + y, E + Q), "orthogonal" === i3.orientation && (w = w.sub((0, A2.vec)(y, Q))));
              const b = i3.getCollidersForGid(e3.gid, { anchor: A2.Vector.Zero, scale: f, offset: w });
              if (b.length)
                t3.collider.useCompositeCollider(b);
              else {
                let i4 = e3.width, s4 = e3.height;
                if ("isometric" === this.resource.map.orientation) {
                  const t4 = e3.height / 2;
                  i4 = t4, s4 = t4;
                }
                let r4 = A2.Shape.Box(i4, s4, "isometric" === this.resource.map.orientation ? (0, A2.vec)(1, 1) : (0, A2.vec)(0, 1));
                "isometric" === this.resource.map.orientation && (r4.points = r4.points.map((e4) => this.resource.isometricTiledCoordToWorld(e4.x, e4.y))), t3.collider.set(r4);
              }
            }
            if (e3 instanceof s2.Text && t3.graphics.use(e3.text), e3 instanceof s2.Polygon) {
              let i4 = (0, A2.vec)(e3.x, e3.y), s3 = e3.localPoints;
              "isometric" === this.resource.map.orientation && (i4 = this.resource.isometricTiledCoordToWorld(i4.x, i4.y), s3 = s3.map((e4) => this.resource.isometricTiledCoordToWorld(e4.x, e4.y))), t3.anchor = (0, A2.vec)(0, 1), t3.pos = i4;
              const r4 = A2.Shape.Polygon(s3, A2.Vector.Zero, true);
              r4.isConvex() ? t3.collider.set(r4) : t3.collider.set(r4.triangulate());
            }
            if (e3 instanceof s2.Rectangle) {
              t3.anchor = e3.anchor;
              let i4 = A2.Shape.Box(e3.width, e3.height, e3.anchor);
              "isometric" === this.resource.map.orientation && (i4.points = i4.points.map((e4) => this.resource.isometricTiledCoordToWorld(e4.x, e4.y))), t3.collider.set(i4);
            }
            e3 instanceof s2.Ellipse && t3.collider.useCircleCollider(Math.min(e3.width, e3.height) / 2);
          }
          async load() {
            var e3, t3, i3, r3, a2;
            const n2 = this.tiledObjectLayer.opacity, l2 = (0, A2.vec)(null !== (e3 = this.tiledObjectLayer.offsetx) && void 0 !== e3 ? e3 : 0, null !== (t3 = this.tiledObjectLayer.offsety) && void 0 !== t3 ? t3 : 0), d = (0, s2.parseObjects)(this.tiledObjectLayer, this.resource);
            for (let e4 of d) {
              let t4 = (0, A2.vec)((null !== (i3 = e4.x) && void 0 !== i3 ? i3 : 0) + l2.x, (null !== (r3 = e4.y) && void 0 !== r3 ? r3 : 0) + l2.y);
              "isometric" === this.resource.map.orientation && (t4 = this.resource.isometricTiledCoordToWorld(t4.x, t4.y));
              let d2, c = e4.class;
              if (e4 instanceof s2.TemplateObject && (c = c || e4.template.object.class), c) {
                const i4 = this.resource.factories.get(c);
                if (i4) {
                  const A3 = i4({ worldPos: t4, name: e4.name, class: c, layer: this, object: e4, properties: e4.properties });
                  A3 && this._recordObjectEntityMapping(e4, A3);
                  continue;
                }
              }
              let g = this.properties.get(o.ExcaliburTiledProperties.ZIndex.ZIndex);
              "number" == typeof g && (d2 = g);
              const h = new A2.Actor({ name: e4.tiledObject.name, pos: t4, anchor: A2.Vector.Zero, rotation: (0, A2.toRadians)(null !== (a2 = e4.tiledObject.rotation) && void 0 !== a2 ? a2 : 0), z: d2 }), u = h.get(A2.GraphicsComponent);
              if (u && (u.visible = this.tiledObjectLayer.visible && (void 0 === e4.tiledObject.visible || !!e4.tiledObject.visible), u.opacity = n2), "isometric" === this.resource.map.orientation) {
                const e5 = new A2.IsometricEntityComponent({ rows: this.resource.map.height, columns: this.resource.map.width, tileWidth: this.resource.map.tilewidth, tileHeight: this.resource.map.tileheight });
                e5.elevation = null != d2 ? d2 : this.order, h.addComponent(e5);
              }
              if (this.resource.useExcaliburWiring) {
                const t5 = e4.properties.get(o.ExcaliburTiledProperties.Collision.Type);
                if (t5 && "string" == typeof t5)
                  switch (t5.toLowerCase()) {
                    case A2.CollisionType.Active.toLowerCase():
                      h.body.collisionType = A2.CollisionType.Active;
                      break;
                    case A2.CollisionType.Fixed.toLowerCase():
                      h.body.collisionType = A2.CollisionType.Fixed;
                      break;
                    case A2.CollisionType.Passive.toLowerCase():
                      h.body.collisionType = A2.CollisionType.Passive;
                      break;
                    case A2.CollisionType.PreventCollision.toLowerCase():
                      h.body.collisionType = A2.CollisionType.PreventCollision;
                      break;
                    default:
                      this.logger.warn(`Unknown collision type in layer ${this.name}, for object id ${e4.id} and name ${e4.name}: ${t5}`);
                  }
              }
              if (e4 instanceof s2.TemplateObject) {
                const t5 = e4.template.tileset;
                e4.template.object && this._actorFromObject(e4.template.object, h, t5);
              } else {
                let t5;
                e4 instanceof s2.InsertedTile && (t5 = this.resource.getTilesetForTileGid(e4.gid)), this._actorFromObject(e4, h, t5);
              }
              this._recordObjectEntityMapping(e4, h);
            }
            this._loaded = true;
          }
          _recordObjectEntityMapping(e3, t3) {
            t3.addComponent(new n.TiledDataComponent({ tiledObject: e3 })), this.objects.push(e3), this.entities.push(t3), this._objectToEntity.set(e3, t3), this._entityToObject.set(t3, e3);
          }
        }
      }, "./src/resource/objects.ts": (e2, t2, i2) => {
        "use strict";
        i2.r(t2), i2.d(t2, { Ellipse: () => c, InsertedTile: () => n, PluginObject: () => a, Point: () => l, Polygon: () => h, Polyline: () => u, Rectangle: () => g, TemplateObject: () => o, Text: () => d, parseObject: () => p, parseObjects: () => I });
        var A2 = i2("excalibur"), s2 = i2("./src/resource/properties.ts"), r2 = i2("./src/resource/path-util.ts");
        class a {
          constructor(e3) {
            var t3, i3, A3;
            this.properties = /* @__PURE__ */ new Map(), this.tiledObject = e3.tiledObject, this.name = this.tiledObject.name, this.class = this.tiledObject.type, this.id = null !== (t3 = this.tiledObject.id) && void 0 !== t3 ? t3 : -1, this.x = null !== (i3 = this.tiledObject.x) && void 0 !== i3 ? i3 : 0, this.y = null !== (A3 = this.tiledObject.y) && void 0 !== A3 ? A3 : 0;
          }
        }
        class o extends a {
          constructor(e3, t3) {
            if (super({ tiledObject: e3 }), !e3.template)
              throw new Error("Invalid template");
            if (this.source = e3.template, this.tiledTemplate = e3, this.template = t3, t3.object) {
              this.name = this.name || t3.object.name, this.class = this.class || t3.object.class;
              for (const [e4, i3] of t3.object.properties.entries())
                this.properties.has(e4) || this.properties.set(e4, i3);
            }
            if (t3.tileset && t3.object.tiledObject.gid) {
              const e4 = t3.tileset.getTileByGid(t3.object.tiledObject.gid);
              if (e4) {
                this.class = this.class || e4.class;
                for (const [t4, i3] of e4.properties.entries())
                  this.properties.has(t4) || this.properties.set(t4, i3);
              }
            }
          }
        }
        class n extends a {
          constructor(e3, t3, i3, A3) {
            super({ tiledObject: e3 }), this.gid = t3, this.width = i3, this.height = A3;
          }
        }
        class l extends a {
        }
        class d extends a {
          constructor(e3, t3, i3, s3) {
            var r3, a2, o2;
            super({ tiledObject: e3 }), this.font = new A2.Font({ family: null !== (r3 = t3.fontfamily) && void 0 !== r3 ? r3 : "sans-serif", color: t3.color ? A2.Color.fromHex(t3.color) : A2.Color.Black, size: null !== (a2 = t3.pixelsize) && void 0 !== a2 ? a2 : 16, unit: A2.FontUnit.Px, textAlign: this._textAlignFromTiled(t3.halign), baseAlign: this._textBaselineFromTiled(t3.valign), quality: s3 });
            const n2 = null !== (o2 = t3.wrap) && void 0 !== o2 && o2;
            this.text = new A2.Text({ text: t3.text, font: this.font, ...n2 ? { maxWidth: i3 + 10 } : {} });
          }
          _textBaselineFromTiled(e3) {
            switch (e3) {
              case "bottom":
                return A2.BaseAlign.Bottom;
              case "center":
                return A2.BaseAlign.Middle;
              default:
                return A2.BaseAlign.Top;
            }
          }
          _textAlignFromTiled(e3) {
            switch (e3) {
              case "left":
              default:
                return A2.TextAlign.Left;
              case "center":
                return A2.TextAlign.Center;
              case "right":
                return A2.TextAlign.Right;
              case "justify":
                return A2.TextAlign.Start;
            }
          }
        }
        class c extends a {
          constructor(e3, t3, i3) {
            super({ tiledObject: e3 }), this.width = t3, this.height = i3;
          }
        }
        class g extends a {
          constructor(e3, t3, i3, A3) {
            super({ tiledObject: e3 }), this.width = t3, this.height = i3, this.anchor = A3;
          }
        }
        class h extends a {
          constructor(e3, t3) {
            super({ tiledObject: e3 }), this.points = [], this.localPoints = [], this.localPoints = t3.map((e4) => (0, A2.vec)(e4.x, e4.y)), this.points = t3.map((e4) => (0, A2.vec)(e4.x, e4.y).add((0, A2.vec)(this.x, this.y)));
          }
        }
        class u extends a {
          constructor(e3, t3) {
            super({ tiledObject: e3 }), this.points = [], this.points = t3.map((e4) => (0, A2.vec)(e4.x, e4.y));
          }
        }
        function p(e3, t3) {
          var i3, a2, p2, I2;
          let f;
          if (e3.point)
            f = new l({ tiledObject: e3 });
          else if (e3.ellipse)
            e3.width && e3.height ? (f = new c(e3, e3.width, e3.height), f.x += e3.width / 2, f.y += e3.height / 2) : f = new c(e3, 20, 20);
          else if (e3.polygon)
            f = new h(e3, e3.polygon);
          else if (e3.polyline)
            f = new u(e3, e3.polyline);
          else if (e3.text)
            f = new d(e3, e3.text, null !== (i3 = e3.width) && void 0 !== i3 ? i3 : 0, null !== (a2 = null == t3 ? void 0 : t3.textQuality) && void 0 !== a2 ? a2 : 4);
          else if (e3.gid) {
            f = new n(e3, e3.gid, null !== (p2 = e3.width) && void 0 !== p2 ? p2 : 0, null !== (I2 = e3.height) && void 0 !== I2 ? I2 : 0);
            const i4 = null == t3 ? void 0 : t3.getTilesetForTileGid(e3.gid);
            let A3 = e3.type;
            if (i4) {
              const t4 = null == i4 ? void 0 : i4.getTileByGid(e3.gid);
              if (A3 = A3 || (null == t4 ? void 0 : t4.class), null == t4 ? void 0 : t4.properties)
                for (const [e4, i5] of t4.properties.entries())
                  f.properties.has(e4) || f.properties.set(e4, i5);
            }
            f.class = A3;
          } else if (e3.template && t3) {
            const i4 = t3.templates.find((t4) => (0, r2.filenameFromPath)(t4.templatePath) === (0, r2.filenameFromPath)(e3.template));
            if (!i4)
              throw new Error(`Template object id ${e3.id} with name ${e3.name} is missing a loaded template file, there should be one loaded from ${e3.template}! Is your tiled map or template corrupted?`);
            f = new o(e3, i4);
          } else
            f = e3.width && e3.height ? new g(e3, e3.width, e3.height, A2.Vector.Zero) : new g(e3, 20, 20, A2.Vector.Half);
          return (0, s2.mapProps)(f, e3.properties), f;
        }
        function I(e3, t3) {
          const i3 = [];
          for (const A3 of e3.objects) {
            let e4 = p(A3, t3);
            i3.push(e4);
          }
          return i3;
        }
      }, "./src/resource/path-util.ts": (e2, t2, i2) => {
        "use strict";
        function A2(e3) {
          const t3 = e3.match(/[^/\\&\?]+\.\w{2,4}(?=([\#\?&].*$|$))/gi);
          if (t3)
            return t3[0];
          throw new Error(`Could not locate filename from path: ${e3}`);
        }
        function s2(e3, t3) {
          for (const { path: i3, output: A3 } of t3)
            if ("string" == typeof i3) {
              if (e3.includes(i3))
                return A3;
            } else {
              const t4 = e3.match(i3);
              if (t4)
                return A3.replace("[match]", t4[0]);
            }
          return e3;
        }
        function r2(e3, t3) {
          if (!t3)
            return false;
          for (const { path: i3, output: A3 } of t3)
            if ("string" == typeof i3) {
              if (e3.includes(i3))
                return true;
            } else if (e3.match(i3))
              return true;
          return false;
        }
        function a(e3, t3, i3) {
          if (r2(t3, i3) && i3)
            return s2(t3, i3);
          if (0 === t3.indexOf("/"))
            return t3;
          const A3 = e3.split("/"), a2 = t3.split("/");
          return A3[A3.length - 1].includes(".") && A3.pop(), A3.concat(a2).join("/");
        }
        i2.r(t2), i2.d(t2, { filenameFromPath: () => A2, mapPath: () => s2, pathInMap: () => r2, pathRelativeToBase: () => a });
      }, "./src/resource/properties.ts": (e2, t2, i2) => {
        "use strict";
        function A2(e3, t3) {
          try {
            if (t3)
              for (const i3 of t3) {
                let t4 = i3.value;
                "string" == typeof i3.value && (t4 = i3.value.toLocaleLowerCase()), e3.properties.set(i3.name.toLocaleLowerCase(), t4);
              }
          } catch (t4) {
            console.error(`Unable to map properties onto ${e3}`, t4);
          }
        }
        i2.r(t2), i2.d(t2, { mapProps: () => A2 });
      }, "./src/resource/template-resource.ts": (e2, t2, i2) => {
        "use strict";
        i2.r(t2), i2.d(t2, { TemplateResource: () => c });
        var A2 = i2("excalibur"), s2 = i2("./src/parser/tiled-parser.ts"), r2 = i2("./src/resource/file-loader.ts"), a = i2("./src/resource/loader-cache.ts"), o = i2("./src/resource/objects.ts"), n = i2("./src/resource/path-util.ts"), l = i2("./src/resource/template.ts"), d = i2("./src/resource/tileset-resource.ts");
        class c {
          constructor(e3, t3) {
            this.templatePath = e3, this.headless = false, this.strict = true, this.fileLoader = r2.FetchLoader;
            const { fileLoader: i3, parser: o2, pathMap: n2, imageLoader: l2, strict: d2, headless: c2 } = { ...t3 };
            this.headless = null != c2 ? c2 : this.headless, this.strict = null != d2 ? d2 : this.strict, this.fileLoader = null != i3 ? i3 : this.fileLoader, this.imageLoader = null != l2 ? l2 : new a.LoaderCache(A2.ImageSource), this.parser = null != o2 ? o2 : new s2.TiledParser(), this.pathMap = n2;
          }
          isLoaded() {
            return !!this.data;
          }
          async load() {
            const e3 = this.templatePath.includes(".tx") ? "xml" : "json";
            try {
              const t3 = await this.fileLoader(this.templatePath, e3);
              let i3;
              i3 = "xml" === e3 ? this.parser.parseExternalTemplate(t3, this.strict) : this.strict ? s2.TiledTemplate.parse(t3) : t3;
              const A3 = i3, r3 = (0, o.parseObject)(i3.object);
              let a2;
              if (i3.tileset) {
                const e4 = (0, n.pathRelativeToBase)(this.templatePath, i3.tileset.source, this.pathMap), t4 = new d.TilesetResource(e4, i3.tileset.firstgid, { headless: this.headless, strict: this.strict, fileLoader: this.fileLoader, imageLoader: this.imageLoader, parser: this.parser, pathMap: this.pathMap });
                a2 = await t4.load();
              }
              return this.data = new l.Template({ templatePath: this.templatePath, tiledTemplate: A3, object: r3, tileset: a2 });
            } catch (e4) {
              throw console.error(`Could not load template at ${this.templatePath}, check to see if your pathMap is correct or if you're Tiled map is corrupted`), e4;
            }
          }
        }
      }, "./src/resource/template.ts": (e2, t2, i2) => {
        "use strict";
        i2.r(t2), i2.d(t2, { Template: () => A2 });
        class A2 {
          constructor(e3) {
            const { templatePath: t3, object: i3, tiledTemplate: A3, tileset: s2 } = e3;
            this.templatePath = t3, this.object = i3, this.tiledTemplate = A3, this.tileset = s2;
          }
        }
      }, "./src/resource/tile-layer.ts": (e2, t2, i2) => {
        "use strict";
        i2.r(t2), i2.d(t2, { TileLayer: () => c });
        var A2 = i2("excalibur"), s2 = i2("./src/resource/properties.ts"), r2 = i2("./src/parser/tiled-parser.ts"), a = i2("./src/resource/decoder.ts"), o = i2("./src/resource/gid-util.ts"), n = i2("./src/resource/excalibur-properties.ts"), l = i2("./src/resource/tiled-layer-component.ts"), d = i2("./src/resource/filter-util.ts");
        class c {
          getTilesByGid(e3) {
            var t3;
            return null !== (t3 = this._gidToTileInfo.get(e3)) && void 0 !== t3 ? t3 : [];
          }
          getTilesByClassName(e3) {
            return this.tilemap.tiles.filter((t3) => {
              const i3 = t3.data.get(n.ExcaliburTiledProperties.TileData.Tiled);
              return !!i3 && (0, d.byClassCaseInsensitive)(e3)(i3);
            }).map((e4) => ({ exTile: e4, tiledTile: e4.data.get(n.ExcaliburTiledProperties.TileData.Tiled) }));
          }
          getTilesByProperty(e3, t3) {
            return this.tilemap.tiles.filter((i3) => {
              const A3 = i3.data.get(n.ExcaliburTiledProperties.TileData.Tiled);
              return !!A3 && (0, d.byPropertyCaseInsensitive)(e3, t3)(A3);
            }).map((e4) => ({ exTile: e4, tiledTile: e4.data.get(n.ExcaliburTiledProperties.TileData.Tiled) }));
          }
          getTileByPoint(e3) {
            if (!this.tilemap)
              return this.logger.warn("Tilemap has not yet been loaded! getTileByPoint() will only return null"), null;
            if (this.tilemap) {
              const t3 = this.tilemap.getTileByPoint(e3);
              if (!t3)
                return null;
              const i3 = this.tilemap.tiles.indexOf(t3), A3 = (0, o.getCanonicalGid)(this.data[i3]);
              return A3 <= 0 ? null : { tiledTile: this.resource.getTilesetForTileGid(A3).getTileByGid(A3), exTile: t3 };
            }
            return null;
          }
          getTileByCoordinate(e3, t3) {
            if (!this.tilemap)
              return this.logger.warn("Tilemap has not yet been loaded! getTileByCoordinate() will only return null"), null;
            if (this.tilemap) {
              const i3 = this.tilemap.getTile(e3, t3), A3 = this.tilemap.tiles.indexOf(i3), s3 = (0, o.getCanonicalGid)(this.data[A3]);
              return s3 <= 0 ? null : { tiledTile: this.resource.getTilesetForTileGid(s3).getTileByGid(s3), exTile: i3 };
            }
            return null;
          }
          constructor(e3, t3, i3) {
            this.tiledTileLayer = e3, this.resource = t3, this.order = i3, this.logger = A2.Logger.getInstance(), this.width = 0, this.height = 0, this.properties = /* @__PURE__ */ new Map(), this.data = [], this._gidToTileInfo = /* @__PURE__ */ new Map(), this.name = e3.name, this.class = e3.class, this.width = e3.width, this.height = e3.height, (0, s2.mapProps)(this, e3.properties);
          }
          _recordTileData(e3, t3) {
            let i3 = this._gidToTileInfo.get(e3), A3 = this.resource.getTilesetForTileGid(e3).getTileByGid(e3);
            i3 ? i3.push({ exTile: t3, tiledTile: A3 }) : i3 = [{ exTile: t3, tiledTile: A3 }], this._gidToTileInfo.set(e3, i3), t3.data.set(n.ExcaliburTiledProperties.TileData.Tiled, A3);
          }
          updateTile(e3, t3, i3, s3, r3) {
            this._recordTileData(t3, e3), this.resource.useExcaliburWiring && r3 && (e3.solid = true);
            const a2 = this.resource.getTilesetForTileGid(t3), o2 = this.resource.headless;
            if (!o2) {
              let A3 = a2.getSpriteForGid(t3);
              i3 && (A3 = A3.clone(), A3.tint = s3), e3.addGraphic(A3, { offset: a2.tileOffset });
            }
            const l2 = a2.getCollidersForGid(t3);
            for (let t4 of l2)
              e3.addCollider(t4);
            let d2 = o2 ? null : a2.getAnimationForGid(t3);
            if (d2 && (i3 && (d2 = d2.clone(), d2.tint = s3), e3.clearGraphics(), e3.addGraphic(d2, { offset: a2.tileOffset }), this.resource.useExcaliburWiring)) {
              const e4 = a2.getTileByGid(t3), i4 = null == e4 ? void 0 : e4.properties.get(n.ExcaliburTiledProperties.Animation.Strategy);
              if (i4 && "string" == typeof i4)
                switch (i4.toLowerCase()) {
                  case A2.AnimationStrategy.End.toLowerCase():
                    d2.strategy = A2.AnimationStrategy.End;
                    break;
                  case A2.AnimationStrategy.Freeze.toLowerCase():
                    d2.strategy = A2.AnimationStrategy.Freeze;
                    break;
                  case A2.AnimationStrategy.Loop.toLowerCase():
                    d2.strategy = A2.AnimationStrategy.Loop;
                    break;
                  case A2.AnimationStrategy.PingPong.toLowerCase():
                    d2.strategy = A2.AnimationStrategy.PingPong;
                    break;
                  default:
                    this.logger.warn(`Unknown animation strategy in tileset ${a2.name} on tile gid ${t3}: ${i4}`);
                }
            }
          }
          async load() {
            var e3, t3, i3, s3;
            const o2 = this.tiledTileLayer.opacity, d2 = !!this.tiledTileLayer.tintcolor, c2 = this.tiledTileLayer.tintcolor ? A2.Color.fromHex(this.tiledTileLayer.tintcolor) : A2.Color.Transparent, g = !!this.properties.get(n.ExcaliburTiledProperties.Layer.Solid), h = this.tiledTileLayer, u = (0, A2.vec)(null !== (e3 = h.offsetx) && void 0 !== e3 ? e3 : 0, null !== (t3 = h.offsety) && void 0 !== t3 ? t3 : 0);
            if ((0, r2.needsDecoding)(this.tiledTileLayer) ? this.data = await a.Decoder.decode(this.tiledTileLayer.data, this.tiledTileLayer.compression) : (0, r2.isCSV)(this.tiledTileLayer) && (this.data = this.tiledTileLayer.data), this.resource.map.infinite && (0, r2.isInfiniteLayer)(this.tiledTileLayer)) {
              const e4 = (0, A2.vec)(this.tiledTileLayer.startx * this.resource.map.tilewidth, this.tiledTileLayer.starty * this.resource.map.tileheight);
              this.tilemap = new A2.TileMap({ name: this.name, pos: u.add(e4), tileHeight: this.resource.map.tileheight, tileWidth: this.resource.map.tilewidth, columns: h.width, rows: h.height });
            } else
              this.tilemap = new A2.TileMap({ name: this.name, pos: u, tileWidth: this.resource.map.tilewidth, tileHeight: this.resource.map.tileheight, columns: h.width, rows: h.height });
            this.tilemap.addComponent(new l.TiledLayerDataComponent({ tiledTileLayer: h }));
            const p = this.tilemap.get(A2.TransformComponent);
            if (p) {
              p.z = this.order;
              let e4 = this.properties.get(n.ExcaliburTiledProperties.ZIndex.ZIndex);
              "number" == typeof e4 && (p.z = e4);
            }
            const I = this.tilemap.get(A2.GraphicsComponent);
            if (I && (I.visible = this.tiledTileLayer.visible, I.opacity = o2), h.parallaxx || h.parallaxy) {
              const e4 = (0, A2.vec)(null !== (i3 = h.parallaxx) && void 0 !== i3 ? i3 : 1, null !== (s3 = h.parallaxy) && void 0 !== s3 ? s3 : 1);
              this.tilemap.addComponent(new A2.ParallaxComponent(e4));
            }
            if (this.resource.map.infinite && (0, r2.isInfiniteLayer)(this.tiledTileLayer))
              for (let e4 of this.tiledTileLayer.chunks)
                for (let t4 = 0; t4 < e4.data.length; t4++) {
                  const i4 = e4.data[t4];
                  if (0 != i4) {
                    const A3 = t4 % e4.width + (e4.x - this.tiledTileLayer.startx), s4 = Math.floor(t4 / e4.width) + (e4.y - this.tiledTileLayer.starty), r3 = this.tilemap.tiles[A3 + s4 * h.width];
                    this.updateTile(r3, i4, d2, c2, g);
                  }
                }
            else
              for (let e4 = 0; e4 < this.data.length; e4++) {
                let t4 = this.data[e4];
                if (0 !== t4) {
                  const i4 = this.tilemap.tiles[e4];
                  this.updateTile(i4, t4, d2, c2, g);
                }
              }
          }
        }
      }, "./src/resource/tiled-data-component.ts": (e2, t2, i2) => {
        "use strict";
        i2.r(t2), i2.d(t2, { TiledDataComponent: () => s2 });
        var A2 = i2("excalibur");
        class s2 extends A2.Component {
          constructor(e3) {
            super();
            const { tiledObject: t3 } = e3;
            this.tiledObject = t3;
          }
        }
      }, "./src/resource/tiled-layer-component.ts": (e2, t2, i2) => {
        "use strict";
        i2.r(t2), i2.d(t2, { TiledLayerDataComponent: () => s2 });
        var A2 = i2("excalibur");
        class s2 extends A2.Component {
          constructor(e3) {
            super();
            const { tiledTileLayer: t3 } = e3;
            this.tiledTileLayer = t3;
          }
        }
      }, "./src/resource/tiled-resource.ts": (e2, t2, i2) => {
        "use strict";
        i2.r(t2), i2.d(t2, { TiledResource: () => m });
        var A2 = i2("excalibur"), s2 = i2("./src/parser/tiled-parser.ts"), r2 = i2("./src/resource/tileset.ts"), a = i2("./src/resource/iso-tile-layer.ts"), o = i2("./src/resource/tile-layer.ts"), n = i2("./src/resource/object-layer.ts"), l = i2("./node_modules/compare-versions/lib/esm/compare.js"), d = i2("./src/resource/gid-util.ts"), c = i2("./src/resource/path-util.ts"), g = i2("./src/resource/filter-util.ts"), h = i2("./src/resource/excalibur-properties.ts"), u = i2("./src/resource/file-loader.ts"), p = i2("./src/resource/tileset-resource.ts"), I = i2("./src/resource/loader-cache.ts"), f = i2("./src/resource/template-resource.ts"), C = i2("./src/resource/image-layer.ts");
        class m {
          constructor(e3, t3) {
            this.path = e3, this.logger = A2.Logger.getInstance(), this.tilesets = [], this.templates = [], this.layers = [], this.mapFormat = "TMX", this.strict = true, this.factories = /* @__PURE__ */ new Map(), this.parser = new s2.TiledParser(), this.fileLoader = u.FetchLoader, this.startZIndex = 0, this.textQuality = 4, this.useExcaliburWiring = true, this.useMapBackgroundColor = false, this.useTilemapCameraStrategy = false, this.headless = false, this._imageLoader = new I.LoaderCache(A2.ImageSource), this._tilesetLoader = new I.LoaderCache(p.TilesetResource), this._templateLoader = new I.LoaderCache(f.TemplateResource);
            const { mapFormatOverride: i3, textQuality: r3, entityClassNameFactories: a2, useExcaliburWiring: o2, useTilemapCameraStrategy: n2, useMapBackgroundColor: l2, pathMap: d2, fileLoader: c2, strict: g2, headless: h2, startZIndex: C2 } = { ...t3 };
            this.strict = null != g2 ? g2 : this.strict, this.headless = null != h2 ? h2 : this.headless, this.useExcaliburWiring = null != o2 ? o2 : this.useExcaliburWiring, this.useTilemapCameraStrategy = null != n2 ? n2 : this.useTilemapCameraStrategy, this.useMapBackgroundColor = null != l2 ? l2 : this.useMapBackgroundColor, this.textQuality = null != r3 ? r3 : this.textQuality, this.startZIndex = null != C2 ? C2 : this.startZIndex, this.fileLoader = null != c2 ? c2 : this.fileLoader, this.pathMap = d2;
            for (const e4 in a2)
              this.registerEntityFactory(e4, a2[e4]);
            this.mapFormat = null != i3 ? i3 : e3.includes(".tmx") ? "TMX" : "TMJ";
          }
          registerEntityFactory(e3, t3) {
            if (this.factories.has(e3) && console.warn(`Another factory has already been registered for tiled class/type "${e3}", this is probably a bug.`), this.factories.set(e3, t3), this.isLoaded())
              for (let t4 of this.getObjectLayers())
                t4.runFactory(e3);
          }
          unregisterEntityFactory(e3) {
            this.factories.has(e3) || console.warn(`No factory has been registered for tiled class/type "${e3}", cannot unregister!`), this.factories.delete(e3);
          }
          getTilesetForTileGid(e3) {
            const t3 = (0, d.getCanonicalGid)(e3);
            if (this.tilesets) {
              for (let e4 of this.tilesets)
                if (t3 >= e4.firstGid && t3 <= e4.firstGid + e4.tileCount - 1)
                  return e4;
            }
            throw Error(`No tileset exists for tiled gid [${e3}] normalized [${t3}]!`);
          }
          getTilesetByName(e3) {
            return this.tilesets.filter((0, g.byNameCaseInsensitive)(e3));
          }
          getTilesetByClassName(e3) {
            return this.tilesets.filter((0, g.byClassCaseInsensitive)(e3));
          }
          getTilesetByProperty(e3, t3) {
            return this.tilesets.filter((0, g.byPropertyCaseInsensitive)(e3, t3));
          }
          getTileMetadataByClassName(e3) {
            let t3 = [];
            for (let i3 of this.tilesets)
              t3 = t3.concat(i3.tiles.filter((0, g.byClassCaseInsensitive)(e3)));
            return t3;
          }
          getTileMetadataByProperty(e3, t3) {
            let i3 = [];
            for (let A3 of this.tilesets)
              i3 = i3.concat(A3.tiles.filter((0, g.byPropertyCaseInsensitive)(e3, t3)));
            return i3;
          }
          getTilesByGid(e3) {
            if ("orthogonal" === this.map.orientation) {
              let t3 = [];
              for (let i3 of this.getTileLayers())
                t3 = t3.concat(i3.getTilesByGid(e3));
              return t3;
            }
            {
              let t3 = [];
              for (let i3 of this.getIsoTileLayers())
                t3 = t3.concat(i3.getTilesByGid(e3));
              return t3;
            }
          }
          getTilesByClassName(e3) {
            if ("orthogonal" === this.map.orientation) {
              let t3 = [];
              for (let i3 of this.getTileLayers())
                t3 = t3.concat(i3.getTilesByClassName(e3));
              return t3;
            }
            {
              let t3 = [];
              for (let i3 of this.getIsoTileLayers())
                t3 = t3.concat(i3.getTilesByClassName(e3));
              return t3;
            }
          }
          getTilesByProperty(e3, t3) {
            if ("orthogonal" === this.map.orientation) {
              let i3 = [];
              for (let A3 of this.getTileLayers())
                i3 = i3.concat(A3.getTilesByProperty(e3, t3));
              return i3;
            }
            {
              let i3 = [];
              for (let A3 of this.getIsoTileLayers())
                i3 = i3.concat(A3.getTilesByProperty(e3, t3));
              return i3;
            }
          }
          getTileByPoint(e3, t3) {
            if ("isometric" === this.map.orientation) {
              const i3 = this.getIsoTileLayers().find((0, g.byNameCaseInsensitive)(e3));
              if (i3)
                return i3.getTileByPoint(t3);
            } else {
              const i3 = this.getTileLayers().find((0, g.byNameCaseInsensitive)(e3));
              if (i3)
                return i3.getTileByPoint(t3);
            }
            return null;
          }
          getTilesByPoint(e3) {
            if ("orthogonal" === this.map.orientation) {
              let t3 = [];
              for (let i3 of this.getTileLayers()) {
                const A3 = i3.getTileByPoint(e3);
                A3 && t3.push(A3);
              }
              return t3;
            }
            {
              let t3 = [];
              for (let i3 of this.getIsoTileLayers()) {
                const A3 = i3.getTileByPoint(e3);
                A3 && t3.push(A3);
              }
              return t3;
            }
          }
          getObjectsByName(e3) {
            let t3 = [];
            for (let i3 of this.getObjectLayers())
              t3 = t3.concat(i3.getObjectsByName(e3));
            return t3;
          }
          getEntitiesByName(e3) {
            let t3 = [];
            for (let i3 of this.getObjectLayers())
              t3 = t3.concat(i3.getEntitiesByName(e3));
            return t3;
          }
          getEntityByObject(e3) {
            for (let t3 of this.getObjectLayers()) {
              const i3 = t3.getEntityByObject(e3);
              if (i3)
                return i3;
            }
          }
          getObjectByEntity(e3) {
            for (let t3 of this.getObjectLayers()) {
              const i3 = t3.getObjectByEntity(e3);
              if (i3)
                return i3;
            }
          }
          getObjectsByProperty(e3, t3) {
            let i3 = [];
            for (let A3 of this.getObjectLayers())
              i3 = i3.concat(A3.getObjectsByProperty(e3, t3));
            return i3;
          }
          getEntitiesByProperty(e3, t3) {
            let i3 = [];
            for (let A3 of this.getObjectLayers())
              i3 = i3.concat(A3.getEntitiesByProperty(e3, t3));
            return i3;
          }
          getObjectsByClassName(e3) {
            let t3 = [];
            for (let i3 of this.getObjectLayers())
              t3 = t3.concat(i3.getObjectsByClassName(e3));
            return t3;
          }
          getEntitiesByClassName(e3) {
            let t3 = [];
            for (let i3 of this.getObjectLayers())
              t3 = t3.concat(i3.getEntitiesByClassName(e3));
            return t3;
          }
          getTileByCoordinate(e3, t3, i3) {
            const A3 = this.getTileLayers().find((0, g.byNameCaseInsensitive)(e3));
            return A3 ? A3.getTileByCoordinate(t3, i3) : null;
          }
          getImageLayers(e3) {
            const t3 = this.layers.filter((e4) => e4 instanceof C.ImageLayer);
            return e3 ? t3.filter((0, g.byNameCaseInsensitive)(e3)) : t3;
          }
          getTileLayers(e3) {
            const t3 = this.layers.filter((e4) => e4 instanceof o.TileLayer);
            return e3 ? t3.filter((0, g.byNameCaseInsensitive)(e3)) : t3;
          }
          getIsoTileLayers(e3) {
            const t3 = this.layers.filter((e4) => e4 instanceof a.IsoTileLayer);
            return e3 ? t3.filter((0, g.byNameCaseInsensitive)(e3)) : t3;
          }
          getObjectLayers(e3) {
            const t3 = this.layers.filter((e4) => e4 instanceof n.ObjectLayer);
            return e3 ? t3.filter((0, g.byNameCaseInsensitive)(e3)) : t3;
          }
          getLayersByName(e3) {
            return this.layers.filter((0, g.byNameCaseInsensitive)(e3));
          }
          getLayersByClassName(e3) {
            return this.layers.filter((0, g.byClassCaseInsensitive)(e3));
          }
          getLayersByProperty(e3, t3) {
            return this.layers.filter((0, g.byPropertyCaseInsensitive)(e3, t3));
          }
          _parseMap(e3) {
            return "TMX" === this.mapFormat ? this.parser.parse(e3, this.strict) : e3;
          }
          async load() {
            var e3;
            const t3 = await this.fileLoader(this.path, "TMX" === this.mapFormat ? "xml" : "json");
            let i3;
            if (this.strict)
              try {
                i3 = this._parseMap(t3);
              } catch (e4) {
                throw console.error(`Could not parse tiled map from location ${this.path}, attempted to interpret as ${this.mapFormat}.
Excalibur only supports the latest version of Tiled formats as of the plugin's release.`), console.error("Is your map file corrupted or being interpreted as the wrong type?"), e4;
              }
            else
              i3 = this._parseMap(t3);
            (0, l.compare)(m.supportedTiledVersion, null !== (e3 = i3.tiledversion) && void 0 !== e3 ? e3 : "0.0.0", ">") && console.warn(`The excalibur tiled plugin officially supports ${m.supportedTiledVersion}+, the current map has tiled version ${i3.tiledversion}`), this.map = i3, this._collectTilesets(), this._collectTemplates(), await Promise.all([this._tilesetLoader.load(), this.headless ? Promise.resolve() : this._imageLoader.load(), this._templateLoader.load()]), this.tilesets = [...this.tilesets, ...this._tilesetLoader.values().map((e4) => e4.data)], this.templates = this._templateLoader.values().map((e4) => e4.data);
            let A3 = [], s3 = this.startZIndex;
            for (const e4 of this.map.layers) {
              if ("tilelayer" === e4.type) {
                if ("isometric" === this.map.orientation) {
                  const t4 = new a.IsoTileLayer(e4, this, s3);
                  A3.push(t4);
                }
                if ("orthogonal" === this.map.orientation) {
                  const t4 = new o.TileLayer(e4, this, s3);
                  A3.push(t4);
                }
              }
              if ("objectgroup" === e4.type) {
                const t4 = new n.ObjectLayer(e4, this, s3);
                A3.push(t4);
              }
              if ("imagelayer" === e4.type) {
                const t4 = new C.ImageLayer(e4, this, s3);
                A3.push(t4);
              }
              s3++;
            }
            await Promise.all(A3.map((e4) => e4.load())), this.layers = A3;
          }
          _collectTilesets() {
            for (const e3 of this.map.tilesets) {
              if ((0, s2.isTiledTilesetEmbedded)(e3)) {
                if ((0, s2.isTiledTilesetSingleImage)(e3)) {
                  const t3 = (0, c.pathRelativeToBase)(this.path, e3.image, this.pathMap), i3 = this._imageLoader.getOrAdd(t3), A3 = new r2.Tileset({ name: e3.name, tiledTileset: e3, image: i3, firstGid: e3.firstgid });
                  this.tilesets.push(A3);
                }
                if ((0, s2.isTiledTilesetCollectionOfImages)(e3)) {
                  const t3 = /* @__PURE__ */ new Map();
                  if (e3.tiles) {
                    for (let i4 of e3.tiles)
                      if (i4.image) {
                        const e4 = (0, c.pathRelativeToBase)(this.path, i4.image, this.pathMap), A3 = this._imageLoader.getOrAdd(e4);
                        t3.set(i4, A3);
                      }
                  }
                  const i3 = new r2.Tileset({ name: e3.name, tiledTileset: e3, tileToImage: t3, firstGid: e3.firstgid });
                  this.tilesets.push(i3);
                }
              }
              if ((0, s2.isTiledTilesetExternal)(e3)) {
                const t3 = (0, c.pathRelativeToBase)(this.path, e3.source, this.pathMap);
                this._tilesetLoader.getOrAdd(t3, e3.firstgid, { strict: this.strict, headless: this.headless, parser: this.parser, fileLoader: this.fileLoader, imageLoader: this._imageLoader, pathMap: this.pathMap });
              }
            }
          }
          _collectTemplates() {
            let e3 = [];
            for (const t4 of this.map.layers)
              if ("objectgroup" === t4.type) {
                let i3 = t4.objects.filter((e4) => e4.template).map((e4) => e4.template);
                e3 = e3.concat(i3);
              }
            const t3 = e3.filter((e4, t4, i3) => i3.findIndex((t5) => t5 === e4) === t4);
            for (const e4 of t3) {
              const t4 = (0, c.pathRelativeToBase)(this.path, e4, this.pathMap);
              this._templateLoader.getOrAdd(t4, { strict: this.strict, headless: this.headless, parser: this.parser, fileLoader: this.fileLoader, imageLoader: this._imageLoader, pathMap: this.pathMap });
            }
          }
          addToScene(e3, t3) {
            if (!this.isLoaded())
              return void this.logger.warn(`TiledResource ${this.path} is not loaded! Nothing will be wired into excalibur!`);
            const i3 = { pos: (0, A2.vec)(0, 0) }, { pos: s3 } = { ...i3, ...t3 };
            for (const t4 of this.layers) {
              if (t4 instanceof o.TileLayer && (t4.tilemap.pos = t4.tilemap.pos.add(s3), e3.add(t4.tilemap)), t4 instanceof a.IsoTileLayer && e3.add(t4.isometricMap), t4 instanceof n.ObjectLayer)
                for (const i4 of t4.entities) {
                  const t5 = i4.get(A2.TransformComponent);
                  t5 && (t5.pos = t5.pos.add(s3)), e3.add(i4);
                }
              t4 instanceof C.ImageLayer && t4.imageActor && (t4.imageActor.pos = t4.imageActor.pos.add(s3), e3.add(t4.imageActor));
            }
            if (this.useExcaliburWiring) {
              const t4 = this.getObjectsByProperty(h.ExcaliburTiledProperties.Camera.Camera, true);
              if (t4 && t4.length) {
                const i4 = t4[0];
                let s4 = 1;
                const r3 = i4.properties.get(h.ExcaliburTiledProperties.Camera.Zoom);
                r3 && "number" == typeof r3 && (s4 = r3), "isometric" === this.map.orientation ? e3.camera.pos = this.isometricTiledCoordToWorld(i4.x, i4.y) : e3.camera.pos = (0, A2.vec)(i4.x, i4.y), e3.camera.zoom = s4;
              }
            }
            if (this.useTilemapCameraStrategy) {
              const t4 = this.getTileLayers()[0];
              if (t4) {
                const i4 = A2.BoundingBox.fromDimension(this.map.width * this.map.tilewidth, this.map.height * this.map.tileheight, A2.Vector.Zero, s3.add(t4.tilemap.pos));
                e3.camera.strategy.limitCameraBounds(i4);
              }
            }
            this.useMapBackgroundColor && this.map.backgroundcolor && (e3.backgroundColor = A2.Color.fromHex(this.map.backgroundcolor));
          }
          isometricTiledCoordToWorld(e3, t3) {
            const i3 = this.map.tilewidth, s3 = this.map.tileheight, r3 = t3 / s3, a2 = e3 / s3;
            return (0, A2.vec)((a2 - r3) * i3 / 2 + 0, (a2 + r3) * s3 / 2);
          }
          isLoaded() {
            return !!this.map;
          }
        }
        m.supportedTiledVersion = "1.10.1";
      }, "./src/resource/tileset-resource.ts": (e2, t2, i2) => {
        "use strict";
        i2.r(t2), i2.d(t2, { TilesetResource: () => l });
        var A2 = i2("excalibur"), s2 = i2("./src/resource/tileset.ts"), r2 = i2("./src/parser/tiled-parser.ts"), a = i2("./src/resource/file-loader.ts"), o = i2("./src/resource/path-util.ts"), n = i2("./src/resource/loader-cache.ts");
        class l {
          constructor(e3, t3, i3) {
            this.path = e3, this.strict = true, this.headless = false, this.orientation = "orthogonal", this.fileLoader = a.FetchLoader;
            const { fileLoader: s3, parser: o2, pathMap: l2, imageLoader: d, strict: c, headless: g, orientation: h } = { ...i3 };
            this.headless = null != g ? g : this.headless, this.orientation = null != h ? h : this.orientation, this.strict = null != c ? c : this.strict, this.fileLoader = null != s3 ? s3 : this.fileLoader, this.imageLoader = null != d ? d : new n.LoaderCache(A2.ImageSource), this.parser = null != o2 ? o2 : new r2.TiledParser(), this.firstGid = t3, this.pathMap = l2;
          }
          async load() {
            const e3 = this.path.includes(".tsx") ? "xml" : "json";
            try {
              const t3 = await this.fileLoader(this.path, e3);
              let i3;
              if (i3 = "json" === e3 ? this.strict ? r2.TiledTilesetFile.parse(t3) : t3 : this.parser.parseExternalTileset(t3, this.strict), (0, r2.isTiledTilesetSingleImage)(i3)) {
                const e4 = (0, o.pathRelativeToBase)(this.path, i3.image, this.pathMap), t4 = this.headless ? void 0 : this.imageLoader.getOrAdd(e4);
                this.data = new s2.Tileset({ name: i3.name, tiledTileset: i3, firstGid: this.firstGid, image: t4 });
              }
              if ((0, r2.isTiledTilesetCollectionOfImages)(i3)) {
                const e4 = this.headless ? void 0 : /* @__PURE__ */ new Map();
                if (e4) {
                  const t4 = [];
                  if (i3.tiles) {
                    for (let A3 of i3.tiles)
                      if (A3.image) {
                        const i4 = (0, o.pathRelativeToBase)(this.path, A3.image, this.pathMap), s3 = this.imageLoader.getOrAdd(i4);
                        e4.set(A3, s3), t4.push(s3);
                      }
                  }
                }
                i3.firstgid = this.firstGid, this.data = new s2.Tileset({ name: i3.name, tiledTileset: i3, firstGid: this.firstGid, tileToImage: e4 });
              }
              if (this.headless || await this.imageLoader.load(), this.data)
                return this.data;
            } catch (e4) {
              throw console.error(`Could not load tileset at path ${this.path}`), e4;
            }
            throw new Error(`No tileset at path ${this.path}`);
          }
          isLoaded() {
            return !!this.data;
          }
        }
      }, "./src/resource/tileset.ts": (e2, t2, i2) => {
        "use strict";
        i2.r(t2), i2.d(t2, { Tile: () => l, Tileset: () => d });
        var A2 = i2("excalibur"), s2 = i2("./src/resource/gid-util.ts"), r2 = i2("./src/parser/tiled-parser.ts"), a = i2("./src/resource/objects.ts"), o = i2("./src/resource/properties.ts"), n = i2("./src/resource/filter-util.ts");
        class l {
          constructor(e3) {
            this.objects = [], this.colliders = [], this.animation = [], this.properties = /* @__PURE__ */ new Map();
            const { id: t3, tileset: i3, tiledTile: A3 } = e3;
            this.id = t3, this.tileset = i3, this.tiledTile = A3, this.class = A3.type, (0, o.mapProps)(this, A3.properties), A3.objectgroup && A3.objectgroup.objects && (this.objects = (0, a.parseObjects)(A3.objectgroup)), A3.animation && (this.animation = A3.animation);
          }
        }
        class d {
          constructor(e3) {
            var t3, i3, s3, a2, n2, d2, c, g, h, u;
            this.firstGid = -1, this.tileCount = 0, this.tileWidth = 0, this.tileHeight = 0, this.tileOffset = (0, A2.vec)(0, 0), this.tiles = [], this.objectalignment = "bottomleft", this.orientation = "orthogonal", this.properties = /* @__PURE__ */ new Map();
            const { name: p, tiledTileset: I, image: f, tileToImage: C, firstGid: m } = e3;
            if (this.name = p, this.tiledTileset = I, this.firstGid = m, (0, r2.isTiledTilesetSingleImage)(I)) {
              (0, o.mapProps)(this, I.properties);
              const e4 = I.spacing, r3 = Math.floor((I.imagewidth + e4) / (I.tilewidth + e4)), g2 = Math.floor((I.imageheight + e4) / (I.tileheight + e4));
              if (this.class = I.class, this.orientation = null !== (i3 = null === (t3 = I.grid) || void 0 === t3 ? void 0 : t3.orientation) && void 0 !== i3 ? i3 : "orthogonal", this.horizontalFlipTransform = A2.AffineMatrix.identity().translate(I.tilewidth, 0).scale(-1, 1), this.verticalFlipTransform = A2.AffineMatrix.identity().translate(0, I.tileheight).scale(1, -1), this.diagonalFlipTransform = A2.AffineMatrix.identity().translate(0, 0).rotate(-Math.PI / 2).scale(-1, 1), this.objectalignment = null !== (s3 = I.objectalignment) && void 0 !== s3 ? s3 : "orthogonal" === this.orientation ? "bottomleft" : "bottom", f && (this.spritesheet = A2.SpriteSheet.fromImageSource({ image: f, grid: { rows: g2, columns: r3, spriteWidth: I.tilewidth, spriteHeight: I.tileheight }, spacing: { originOffset: { x: null !== (a2 = I.margin) && void 0 !== a2 ? a2 : 0, y: null !== (n2 = I.margin) && void 0 !== n2 ? n2 : 0 }, margin: { x: null !== (d2 = I.spacing) && void 0 !== d2 ? d2 : 0, y: null !== (c = I.spacing) && void 0 !== c ? c : 0 } } })), this.tileCount = I.tilecount, this.tileWidth = I.tilewidth, this.tileHeight = I.tileheight, I.tileoffset && (this.tileOffset = (0, A2.vec)(I.tileoffset.x, I.tileoffset.y)), I.tiles)
                for (const e5 of I.tiles)
                  this.tiles.push(new l({ id: e5.id, tileset: this, tiledTile: e5, image: f }));
            }
            if ((0, r2.isTiledTilesetCollectionOfImages)(I) && void 0 !== I.firstgid) {
              this.horizontalFlipTransform = A2.AffineMatrix.identity().translate(I.tilewidth, 0).scale(-1, 1), this.verticalFlipTransform = A2.AffineMatrix.identity().translate(0, I.tileheight).scale(1, -1), this.diagonalFlipTransform = A2.AffineMatrix.identity().translate(0, 0).rotate(-Math.PI / 2).scale(-1, 1), this.objectalignment = null !== (g = I.objectalignment) && void 0 !== g ? g : "orthogonal" === this.orientation ? "bottomleft" : "bottom", this.orientation = null !== (u = null === (h = I.grid) || void 0 === h ? void 0 : h.orientation) && void 0 !== u ? u : "orthogonal", this.tileCount = I.tilecount, this.tileWidth = I.tilewidth, this.tileHeight = I.tileheight, I.tileoffset && (this.tileOffset = (0, A2.vec)(I.tileoffset.x, I.tileoffset.y));
              let e4 = [];
              if (I.tiles)
                for (const t4 of I.tiles) {
                  const i4 = null == C ? void 0 : C.get(t4);
                  i4 && e4.push(i4.toSprite()), this.tiles.push(new l({ id: t4.id, tileset: this, tiledTile: t4, image: i4 }));
                }
              C && (this.spritesheet = new A2.SpriteSheet({ sprites: e4 }));
            }
          }
          getTilesetAlignmentAnchor(e3) {
            switch (null != e3 ? e3 : this.objectalignment) {
              case "topleft":
                return (0, A2.vec)(0, 0);
              case "top":
                return (0, A2.vec)(0.5, 0);
              case "topright":
                return (0, A2.vec)(1, 0);
              case "left":
                return (0, A2.vec)(0, 0.5);
              case "center":
                return (0, A2.vec)(0.5, 0.5);
              case "right":
                return (0, A2.vec)(1, 0.5);
              case "bottomleft":
              default:
                return (0, A2.vec)(0, 1);
              case "bottom":
                return (0, A2.vec)(0.5, 1);
              case "bottomright":
                return (0, A2.vec)(1, 1);
            }
          }
          getTileByGid(e3) {
            const t3 = (0, s2.getCanonicalGid)(e3) - this.firstGid;
            return this.tiles.find((e4) => e4.id === t3);
          }
          getTilesByClassName(e3) {
            return this.tiles.filter((0, n.byClassCaseInsensitive)(e3));
          }
          getTilesByProperty(e3, t3) {
            return this.tiles.filter((0, n.byPropertyCaseInsensitive)(e3, t3));
          }
          getSpriteForGid(e3) {
            const t3 = (0, s2.isFlippedHorizontally)(e3), i3 = (0, s2.isFlippedVertically)(e3), r3 = (0, s2.isFlippedDiagonally)(e3), a2 = (0, s2.getCanonicalGid)(e3), o2 = a2 - this.firstGid;
            if (this.spritesheet) {
              let e4 = this.spritesheet.sprites[o2];
              return (r3 || t3 || i3) && (e4 = e4.clone()), r3 && (e4.rotation = -Math.PI / 2, e4.scale = (0, A2.vec)(-1, 1)), t3 && (e4.scale = (0, A2.vec)((r3 ? 1 : -1) * e4.scale.x, (r3 ? -1 : 1) * e4.scale.y)), i3 && (e4.scale = (0, A2.vec)((r3 ? -1 : 1) * e4.scale.x, (r3 ? 1 : -1) * e4.scale.y)), e4;
            }
            throw new Error(`Tileset: [${this.name}] Could not find sprite for gid: [${e3}] normalized gid: [${a2}]`);
          }
          _isometricTiledCoordToWorld(e3) {
            const t3 = this.tileWidth, i3 = this.tileHeight / 2, s3 = e3.y / i3, r3 = e3.x / i3;
            return (0, A2.vec)((r3 - s3) * t3 / 2 + 0, (r3 + s3) * i3 / 2);
          }
          getCollidersForGid(e3, t3) {
            let { anchor: i3, scale: s3, orientationOverride: r3, offset: o2 } = { anchor: A2.Vector.Zero, scale: A2.Vector.One, offset: A2.Vector.Zero, orientationOverride: void 0, ...t3 };
            const n2 = null != r3 ? r3 : this.orientation, l2 = this.getTileByGid(e3), d2 = [];
            if (l2 && l2.objects)
              for (let t4 of l2.objects) {
                if (t4 instanceof a.Polygon) {
                  let i4 = t4.points.map((e4) => e4.scale(s3));
                  i4 = this._applyFlipsToPoints(i4, e3), "isometric" === n2 && (i4 = i4.map((e4) => this._isometricTiledCoordToWorld(e4))), i4 = i4.map((e4) => e4.add(o2));
                  let r4 = A2.Shape.Polygon(i4, A2.Vector.Zero, true);
                  r4.isConvex() ? d2.push(r4) : d2.push(r4.triangulate());
                }
                if (t4 instanceof a.Rectangle) {
                  let r4 = A2.BoundingBox.fromDimension(t4.width * s3.x, t4.height * s3.y, i3).getPoints().map((e4) => e4.add((0, A2.vec)(t4.x, t4.y)));
                  "isometric" === n2 && (r4 = r4.map((e4) => this._isometricTiledCoordToWorld(e4))), r4 = this._applyFlipsToPoints(r4, e3), r4 = r4.map((e4) => e4.add(o2));
                  const a2 = A2.Shape.Polygon(r4);
                  d2.push(a2);
                }
                if (t4 instanceof a.Ellipse) {
                  let e4 = (0, A2.vec)(t4.x, t4.y);
                  "isometric" === n2 && (e4 = this._isometricTiledCoordToWorld(e4)), e4 = e4.add(o2);
                  const i4 = Math.min(t4.width / 2, t4.height / 2), r4 = A2.Shape.Circle(i4, e4.scale(s3));
                  d2.push(r4);
                }
              }
            return d2;
          }
          _applyFlipsToPoints(e3, t3) {
            const i3 = (0, s2.isFlippedHorizontally)(t3), A3 = (0, s2.isFlippedVertically)(t3);
            return (0, s2.isFlippedDiagonally)(t3) && (e3 = e3.map((e4) => this.diagonalFlipTransform.multiply(e4))), i3 && (e3 = e3.map((e4) => this.horizontalFlipTransform.multiply(e4))), A3 && (e3 = e3.map((e4) => this.verticalFlipTransform.multiply(e4))), e3;
          }
          getAnimationForGid(e3) {
            var t3;
            const i3 = this.getTileByGid(e3);
            if (i3 && (null === (t3 = i3.animation) || void 0 === t3 ? void 0 : t3.length)) {
              let e4 = [];
              for (let t4 of i3.animation)
                e4.push({ graphic: this.getSpriteForGid(t4.tileid + this.firstGid), duration: t4.duration });
              return new A2.Animation({ frames: e4, strategy: A2.AnimationStrategy.Loop });
            }
            return null;
          }
        }
      }, excalibur: (e2) => {
        "use strict";
        e2.exports = t;
      }, jsdom: (t2) => {
        "use strict";
        if (void 0 === e) {
          var i2 = new Error("Cannot find module 'jsdom'");
          throw i2.code = "MODULE_NOT_FOUND", i2;
        }
        t2.exports = e;
      }, "./node_modules/zod/lib/index.mjs": (e2, t2, i2) => {
        "use strict";
        var A2, s2;
        i2.r(t2), i2.d(t2, { BRAND: () => ye, DIRTY: () => m, EMPTY_PATH: () => p, INVALID: () => C, NEVER: () => ut, OK: () => B, ParseStatus: () => f, Schema: () => T, ZodAny: () => H, ZodArray: () => W, ZodBigInt: () => z, ZodBoolean: () => P, ZodBranded: () => Qe, ZodCatch: () => Be, ZodDate: () => U, ZodDefault: () => me, ZodDiscriminatedUnion: () => ie, ZodEffects: () => Ie, ZodEnum: () => he, ZodError: () => l, ZodFirstPartyTypeKind: () => xe, ZodFunction: () => le, ZodIntersection: () => se, ZodIssueCode: () => o, ZodLazy: () => de, ZodLiteral: () => ce, ZodMap: () => oe, ZodNaN: () => Ee, ZodNativeEnum: () => ue, ZodNever: () => K, ZodNull: () => Z, ZodNullable: () => Ce, ZodNumber: () => O, ZodObject: () => $, ZodOptional: () => fe, ZodParsedType: () => r2, ZodPipeline: () => we, ZodPromise: () => pe, ZodReadonly: () => be, ZodRecord: () => ae, ZodSchema: () => T, ZodSet: () => ne, ZodString: () => M, ZodSymbol: () => J, ZodTransformer: () => Ie, ZodTuple: () => re, ZodType: () => T, ZodUndefined: () => q, ZodUnion: () => ee, ZodUnknown: () => Y, ZodVoid: () => V, addIssueToContext: () => I, any: () => Re, array: () => Ue, bigint: () => Ne, boolean: () => Fe, coerce: () => ht, custom: () => _e, date: () => Se, default: () => pt, defaultErrorMap: () => d, discriminatedUnion: () => He, effect: () => rt, enum: () => it, function: () => $e, getErrorMap: () => h, getParsedType: () => a, instanceof: () => Te, intersection: () => Ye, isAborted: () => E, isAsync: () => w, isDirty: () => y, isValid: () => Q, late: () => ve, lazy: () => et, literal: () => tt, makeIssue: () => u, map: () => We, nan: () => Le, nativeEnum: () => At, never: () => ze, null: () => Me, nullable: () => ot, number: () => De, object: () => Je, objectUtil: () => s2, oboolean: () => gt, onumber: () => ct, optional: () => at, ostring: () => dt, pipeline: () => lt, preprocess: () => nt, promise: () => st, quotelessJson: () => n, record: () => Ve, set: () => Xe, setErrorMap: () => g, strictObject: () => qe, string: () => ke, symbol: () => Ge, transformer: () => rt, tuple: () => Ke, undefined: () => je, union: () => Ze, unknown: () => Oe, util: () => A2, void: () => Pe, z: () => pt }), function(e3) {
          e3.assertEqual = (e4) => e4, e3.assertIs = function(e4) {
          }, e3.assertNever = function(e4) {
            throw new Error();
          }, e3.arrayToEnum = (e4) => {
            const t3 = {};
            for (const i3 of e4)
              t3[i3] = i3;
            return t3;
          }, e3.getValidEnumValues = (t3) => {
            const i3 = e3.objectKeys(t3).filter((e4) => "number" != typeof t3[t3[e4]]), A3 = {};
            for (const e4 of i3)
              A3[e4] = t3[e4];
            return e3.objectValues(A3);
          }, e3.objectValues = (t3) => e3.objectKeys(t3).map(function(e4) {
            return t3[e4];
          }), e3.objectKeys = "function" == typeof Object.keys ? (e4) => Object.keys(e4) : (e4) => {
            const t3 = [];
            for (const i3 in e4)
              Object.prototype.hasOwnProperty.call(e4, i3) && t3.push(i3);
            return t3;
          }, e3.find = (e4, t3) => {
            for (const i3 of e4)
              if (t3(i3))
                return i3;
          }, e3.isInteger = "function" == typeof Number.isInteger ? (e4) => Number.isInteger(e4) : (e4) => "number" == typeof e4 && isFinite(e4) && Math.floor(e4) === e4, e3.joinValues = function(e4, t3 = " | ") {
            return e4.map((e5) => "string" == typeof e5 ? `'${e5}'` : e5).join(t3);
          }, e3.jsonStringifyReplacer = (e4, t3) => "bigint" == typeof t3 ? t3.toString() : t3;
        }(A2 || (A2 = {})), function(e3) {
          e3.mergeShapes = (e4, t3) => ({ ...e4, ...t3 });
        }(s2 || (s2 = {}));
        const r2 = A2.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"]), a = (e3) => {
          switch (typeof e3) {
            case "undefined":
              return r2.undefined;
            case "string":
              return r2.string;
            case "number":
              return isNaN(e3) ? r2.nan : r2.number;
            case "boolean":
              return r2.boolean;
            case "function":
              return r2.function;
            case "bigint":
              return r2.bigint;
            case "symbol":
              return r2.symbol;
            case "object":
              return Array.isArray(e3) ? r2.array : null === e3 ? r2.null : e3.then && "function" == typeof e3.then && e3.catch && "function" == typeof e3.catch ? r2.promise : "undefined" != typeof Map && e3 instanceof Map ? r2.map : "undefined" != typeof Set && e3 instanceof Set ? r2.set : "undefined" != typeof Date && e3 instanceof Date ? r2.date : r2.object;
            default:
              return r2.unknown;
          }
        }, o = A2.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"]), n = (e3) => JSON.stringify(e3, null, 2).replace(/"([^"]+)":/g, "$1:");
        class l extends Error {
          constructor(e3) {
            super(), this.issues = [], this.addIssue = (e4) => {
              this.issues = [...this.issues, e4];
            }, this.addIssues = (e4 = []) => {
              this.issues = [...this.issues, ...e4];
            };
            const t3 = new.target.prototype;
            Object.setPrototypeOf ? Object.setPrototypeOf(this, t3) : this.__proto__ = t3, this.name = "ZodError", this.issues = e3;
          }
          get errors() {
            return this.issues;
          }
          format(e3) {
            const t3 = e3 || function(e4) {
              return e4.message;
            }, i3 = { _errors: [] }, A3 = (e4) => {
              for (const s3 of e4.issues)
                if ("invalid_union" === s3.code)
                  s3.unionErrors.map(A3);
                else if ("invalid_return_type" === s3.code)
                  A3(s3.returnTypeError);
                else if ("invalid_arguments" === s3.code)
                  A3(s3.argumentsError);
                else if (0 === s3.path.length)
                  i3._errors.push(t3(s3));
                else {
                  let e5 = i3, A4 = 0;
                  for (; A4 < s3.path.length; ) {
                    const i4 = s3.path[A4];
                    A4 === s3.path.length - 1 ? (e5[i4] = e5[i4] || { _errors: [] }, e5[i4]._errors.push(t3(s3))) : e5[i4] = e5[i4] || { _errors: [] }, e5 = e5[i4], A4++;
                  }
                }
            };
            return A3(this), i3;
          }
          toString() {
            return this.message;
          }
          get message() {
            return JSON.stringify(this.issues, A2.jsonStringifyReplacer, 2);
          }
          get isEmpty() {
            return 0 === this.issues.length;
          }
          flatten(e3 = (e4) => e4.message) {
            const t3 = {}, i3 = [];
            for (const A3 of this.issues)
              A3.path.length > 0 ? (t3[A3.path[0]] = t3[A3.path[0]] || [], t3[A3.path[0]].push(e3(A3))) : i3.push(e3(A3));
            return { formErrors: i3, fieldErrors: t3 };
          }
          get formErrors() {
            return this.flatten();
          }
        }
        l.create = (e3) => new l(e3);
        const d = (e3, t3) => {
          let i3;
          switch (e3.code) {
            case o.invalid_type:
              i3 = e3.received === r2.undefined ? "Required" : `Expected ${e3.expected}, received ${e3.received}`;
              break;
            case o.invalid_literal:
              i3 = `Invalid literal value, expected ${JSON.stringify(e3.expected, A2.jsonStringifyReplacer)}`;
              break;
            case o.unrecognized_keys:
              i3 = `Unrecognized key(s) in object: ${A2.joinValues(e3.keys, ", ")}`;
              break;
            case o.invalid_union:
              i3 = "Invalid input";
              break;
            case o.invalid_union_discriminator:
              i3 = `Invalid discriminator value. Expected ${A2.joinValues(e3.options)}`;
              break;
            case o.invalid_enum_value:
              i3 = `Invalid enum value. Expected ${A2.joinValues(e3.options)}, received '${e3.received}'`;
              break;
            case o.invalid_arguments:
              i3 = "Invalid function arguments";
              break;
            case o.invalid_return_type:
              i3 = "Invalid function return type";
              break;
            case o.invalid_date:
              i3 = "Invalid date";
              break;
            case o.invalid_string:
              "object" == typeof e3.validation ? "includes" in e3.validation ? (i3 = `Invalid input: must include "${e3.validation.includes}"`, "number" == typeof e3.validation.position && (i3 = `${i3} at one or more positions greater than or equal to ${e3.validation.position}`)) : "startsWith" in e3.validation ? i3 = `Invalid input: must start with "${e3.validation.startsWith}"` : "endsWith" in e3.validation ? i3 = `Invalid input: must end with "${e3.validation.endsWith}"` : A2.assertNever(e3.validation) : i3 = "regex" !== e3.validation ? `Invalid ${e3.validation}` : "Invalid";
              break;
            case o.too_small:
              i3 = "array" === e3.type ? `Array must contain ${e3.exact ? "exactly" : e3.inclusive ? "at least" : "more than"} ${e3.minimum} element(s)` : "string" === e3.type ? `String must contain ${e3.exact ? "exactly" : e3.inclusive ? "at least" : "over"} ${e3.minimum} character(s)` : "number" === e3.type ? `Number must be ${e3.exact ? "exactly equal to " : e3.inclusive ? "greater than or equal to " : "greater than "}${e3.minimum}` : "date" === e3.type ? `Date must be ${e3.exact ? "exactly equal to " : e3.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e3.minimum))}` : "Invalid input";
              break;
            case o.too_big:
              i3 = "array" === e3.type ? `Array must contain ${e3.exact ? "exactly" : e3.inclusive ? "at most" : "less than"} ${e3.maximum} element(s)` : "string" === e3.type ? `String must contain ${e3.exact ? "exactly" : e3.inclusive ? "at most" : "under"} ${e3.maximum} character(s)` : "number" === e3.type ? `Number must be ${e3.exact ? "exactly" : e3.inclusive ? "less than or equal to" : "less than"} ${e3.maximum}` : "bigint" === e3.type ? `BigInt must be ${e3.exact ? "exactly" : e3.inclusive ? "less than or equal to" : "less than"} ${e3.maximum}` : "date" === e3.type ? `Date must be ${e3.exact ? "exactly" : e3.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e3.maximum))}` : "Invalid input";
              break;
            case o.custom:
              i3 = "Invalid input";
              break;
            case o.invalid_intersection_types:
              i3 = "Intersection results could not be merged";
              break;
            case o.not_multiple_of:
              i3 = `Number must be a multiple of ${e3.multipleOf}`;
              break;
            case o.not_finite:
              i3 = "Number must be finite";
              break;
            default:
              i3 = t3.defaultError, A2.assertNever(e3);
          }
          return { message: i3 };
        };
        let c = d;
        function g(e3) {
          c = e3;
        }
        function h() {
          return c;
        }
        const u = (e3) => {
          const { data: t3, path: i3, errorMaps: A3, issueData: s3 } = e3, r3 = [...i3, ...s3.path || []], a2 = { ...s3, path: r3 };
          let o2 = "";
          const n2 = A3.filter((e4) => !!e4).slice().reverse();
          for (const e4 of n2)
            o2 = e4(a2, { data: t3, defaultError: o2 }).message;
          return { ...s3, path: r3, message: s3.message || o2 };
        }, p = [];
        function I(e3, t3) {
          const i3 = u({ issueData: t3, data: e3.data, path: e3.path, errorMaps: [e3.common.contextualErrorMap, e3.schemaErrorMap, h(), d].filter((e4) => !!e4) });
          e3.common.issues.push(i3);
        }
        class f {
          constructor() {
            this.value = "valid";
          }
          dirty() {
            "valid" === this.value && (this.value = "dirty");
          }
          abort() {
            "aborted" !== this.value && (this.value = "aborted");
          }
          static mergeArray(e3, t3) {
            const i3 = [];
            for (const A3 of t3) {
              if ("aborted" === A3.status)
                return C;
              "dirty" === A3.status && e3.dirty(), i3.push(A3.value);
            }
            return { status: e3.value, value: i3 };
          }
          static async mergeObjectAsync(e3, t3) {
            const i3 = [];
            for (const e4 of t3)
              i3.push({ key: await e4.key, value: await e4.value });
            return f.mergeObjectSync(e3, i3);
          }
          static mergeObjectSync(e3, t3) {
            const i3 = {};
            for (const A3 of t3) {
              const { key: t4, value: s3 } = A3;
              if ("aborted" === t4.status)
                return C;
              if ("aborted" === s3.status)
                return C;
              "dirty" === t4.status && e3.dirty(), "dirty" === s3.status && e3.dirty(), "__proto__" === t4.value || void 0 === s3.value && !A3.alwaysSet || (i3[t4.value] = s3.value);
            }
            return { status: e3.value, value: i3 };
          }
        }
        const C = Object.freeze({ status: "aborted" }), m = (e3) => ({ status: "dirty", value: e3 }), B = (e3) => ({ status: "valid", value: e3 }), E = (e3) => "aborted" === e3.status, y = (e3) => "dirty" === e3.status, Q = (e3) => "valid" === e3.status, w = (e3) => "undefined" != typeof Promise && e3 instanceof Promise;
        var b;
        !function(e3) {
          e3.errToObj = (e4) => "string" == typeof e4 ? { message: e4 } : e4 || {}, e3.toString = (e4) => "string" == typeof e4 ? e4 : null == e4 ? void 0 : e4.message;
        }(b || (b = {}));
        class _ {
          constructor(e3, t3, i3, A3) {
            this._cachedPath = [], this.parent = e3, this.data = t3, this._path = i3, this._key = A3;
          }
          get path() {
            return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
          }
        }
        const v = (e3, t3) => {
          if (Q(t3))
            return { success: true, data: t3.value };
          if (!e3.common.issues.length)
            throw new Error("Validation failed but no issues detected.");
          return { success: false, get error() {
            if (this._error)
              return this._error;
            const t4 = new l(e3.common.issues);
            return this._error = t4, this._error;
          } };
        };
        function x(e3) {
          if (!e3)
            return {};
          const { errorMap: t3, invalid_type_error: i3, required_error: A3, description: s3 } = e3;
          if (t3 && (i3 || A3))
            throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
          return t3 ? { errorMap: t3, description: s3 } : { errorMap: (e4, t4) => "invalid_type" !== e4.code ? { message: t4.defaultError } : void 0 === t4.data ? { message: null != A3 ? A3 : t4.defaultError } : { message: null != i3 ? i3 : t4.defaultError }, description: s3 };
        }
        class T {
          constructor(e3) {
            this.spa = this.safeParseAsync, this._def = e3, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
          }
          get description() {
            return this._def.description;
          }
          _getType(e3) {
            return a(e3.data);
          }
          _getOrReturnCtx(e3, t3) {
            return t3 || { common: e3.parent.common, data: e3.data, parsedType: a(e3.data), schemaErrorMap: this._def.errorMap, path: e3.path, parent: e3.parent };
          }
          _processInputParams(e3) {
            return { status: new f(), ctx: { common: e3.parent.common, data: e3.data, parsedType: a(e3.data), schemaErrorMap: this._def.errorMap, path: e3.path, parent: e3.parent } };
          }
          _parseSync(e3) {
            const t3 = this._parse(e3);
            if (w(t3))
              throw new Error("Synchronous parse encountered promise.");
            return t3;
          }
          _parseAsync(e3) {
            const t3 = this._parse(e3);
            return Promise.resolve(t3);
          }
          parse(e3, t3) {
            const i3 = this.safeParse(e3, t3);
            if (i3.success)
              return i3.data;
            throw i3.error;
          }
          safeParse(e3, t3) {
            var i3;
            const A3 = { common: { issues: [], async: null !== (i3 = null == t3 ? void 0 : t3.async) && void 0 !== i3 && i3, contextualErrorMap: null == t3 ? void 0 : t3.errorMap }, path: (null == t3 ? void 0 : t3.path) || [], schemaErrorMap: this._def.errorMap, parent: null, data: e3, parsedType: a(e3) }, s3 = this._parseSync({ data: e3, path: A3.path, parent: A3 });
            return v(A3, s3);
          }
          async parseAsync(e3, t3) {
            const i3 = await this.safeParseAsync(e3, t3);
            if (i3.success)
              return i3.data;
            throw i3.error;
          }
          async safeParseAsync(e3, t3) {
            const i3 = { common: { issues: [], contextualErrorMap: null == t3 ? void 0 : t3.errorMap, async: true }, path: (null == t3 ? void 0 : t3.path) || [], schemaErrorMap: this._def.errorMap, parent: null, data: e3, parsedType: a(e3) }, A3 = this._parse({ data: e3, path: i3.path, parent: i3 }), s3 = await (w(A3) ? A3 : Promise.resolve(A3));
            return v(i3, s3);
          }
          refine(e3, t3) {
            const i3 = (e4) => "string" == typeof t3 || void 0 === t3 ? { message: t3 } : "function" == typeof t3 ? t3(e4) : t3;
            return this._refinement((t4, A3) => {
              const s3 = e3(t4), r3 = () => A3.addIssue({ code: o.custom, ...i3(t4) });
              return "undefined" != typeof Promise && s3 instanceof Promise ? s3.then((e4) => !!e4 || (r3(), false)) : !!s3 || (r3(), false);
            });
          }
          refinement(e3, t3) {
            return this._refinement((i3, A3) => !!e3(i3) || (A3.addIssue("function" == typeof t3 ? t3(i3, A3) : t3), false));
          }
          _refinement(e3) {
            return new Ie({ schema: this, typeName: xe.ZodEffects, effect: { type: "refinement", refinement: e3 } });
          }
          superRefine(e3) {
            return this._refinement(e3);
          }
          optional() {
            return fe.create(this, this._def);
          }
          nullable() {
            return Ce.create(this, this._def);
          }
          nullish() {
            return this.nullable().optional();
          }
          array() {
            return W.create(this, this._def);
          }
          promise() {
            return pe.create(this, this._def);
          }
          or(e3) {
            return ee.create([this, e3], this._def);
          }
          and(e3) {
            return se.create(this, e3, this._def);
          }
          transform(e3) {
            return new Ie({ ...x(this._def), schema: this, typeName: xe.ZodEffects, effect: { type: "transform", transform: e3 } });
          }
          default(e3) {
            const t3 = "function" == typeof e3 ? e3 : () => e3;
            return new me({ ...x(this._def), innerType: this, defaultValue: t3, typeName: xe.ZodDefault });
          }
          brand() {
            return new Qe({ typeName: xe.ZodBranded, type: this, ...x(this._def) });
          }
          catch(e3) {
            const t3 = "function" == typeof e3 ? e3 : () => e3;
            return new Be({ ...x(this._def), innerType: this, catchValue: t3, typeName: xe.ZodCatch });
          }
          describe(e3) {
            return new (0, this.constructor)({ ...this._def, description: e3 });
          }
          pipe(e3) {
            return we.create(this, e3);
          }
          readonly() {
            return be.create(this);
          }
          isOptional() {
            return this.safeParse(void 0).success;
          }
          isNullable() {
            return this.safeParse(null).success;
          }
        }
        const k = /^c[^\s-]{8,}$/i, D = /^[a-z][a-z0-9]*$/, L = /^[0-9A-HJKMNP-TV-Z]{26}$/, N = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, F = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
        let S;
        const G = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, j = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
        class M extends T {
          _parse(e3) {
            if (this._def.coerce && (e3.data = String(e3.data)), this._getType(e3) !== r2.string) {
              const t4 = this._getOrReturnCtx(e3);
              return I(t4, { code: o.invalid_type, expected: r2.string, received: t4.parsedType }), C;
            }
            const t3 = new f();
            let i3;
            for (const r3 of this._def.checks)
              if ("min" === r3.kind)
                e3.data.length < r3.value && (i3 = this._getOrReturnCtx(e3, i3), I(i3, { code: o.too_small, minimum: r3.value, type: "string", inclusive: true, exact: false, message: r3.message }), t3.dirty());
              else if ("max" === r3.kind)
                e3.data.length > r3.value && (i3 = this._getOrReturnCtx(e3, i3), I(i3, { code: o.too_big, maximum: r3.value, type: "string", inclusive: true, exact: false, message: r3.message }), t3.dirty());
              else if ("length" === r3.kind) {
                const A3 = e3.data.length > r3.value, s4 = e3.data.length < r3.value;
                (A3 || s4) && (i3 = this._getOrReturnCtx(e3, i3), A3 ? I(i3, { code: o.too_big, maximum: r3.value, type: "string", inclusive: true, exact: true, message: r3.message }) : s4 && I(i3, { code: o.too_small, minimum: r3.value, type: "string", inclusive: true, exact: true, message: r3.message }), t3.dirty());
              } else if ("email" === r3.kind)
                F.test(e3.data) || (i3 = this._getOrReturnCtx(e3, i3), I(i3, { validation: "email", code: o.invalid_string, message: r3.message }), t3.dirty());
              else if ("emoji" === r3.kind)
                S || (S = new RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u")), S.test(e3.data) || (i3 = this._getOrReturnCtx(e3, i3), I(i3, { validation: "emoji", code: o.invalid_string, message: r3.message }), t3.dirty());
              else if ("uuid" === r3.kind)
                N.test(e3.data) || (i3 = this._getOrReturnCtx(e3, i3), I(i3, { validation: "uuid", code: o.invalid_string, message: r3.message }), t3.dirty());
              else if ("cuid" === r3.kind)
                k.test(e3.data) || (i3 = this._getOrReturnCtx(e3, i3), I(i3, { validation: "cuid", code: o.invalid_string, message: r3.message }), t3.dirty());
              else if ("cuid2" === r3.kind)
                D.test(e3.data) || (i3 = this._getOrReturnCtx(e3, i3), I(i3, { validation: "cuid2", code: o.invalid_string, message: r3.message }), t3.dirty());
              else if ("ulid" === r3.kind)
                L.test(e3.data) || (i3 = this._getOrReturnCtx(e3, i3), I(i3, { validation: "ulid", code: o.invalid_string, message: r3.message }), t3.dirty());
              else if ("url" === r3.kind)
                try {
                  new URL(e3.data);
                } catch (A3) {
                  i3 = this._getOrReturnCtx(e3, i3), I(i3, { validation: "url", code: o.invalid_string, message: r3.message }), t3.dirty();
                }
              else
                "regex" === r3.kind ? (r3.regex.lastIndex = 0, r3.regex.test(e3.data) || (i3 = this._getOrReturnCtx(e3, i3), I(i3, { validation: "regex", code: o.invalid_string, message: r3.message }), t3.dirty())) : "trim" === r3.kind ? e3.data = e3.data.trim() : "includes" === r3.kind ? e3.data.includes(r3.value, r3.position) || (i3 = this._getOrReturnCtx(e3, i3), I(i3, { code: o.invalid_string, validation: { includes: r3.value, position: r3.position }, message: r3.message }), t3.dirty()) : "toLowerCase" === r3.kind ? e3.data = e3.data.toLowerCase() : "toUpperCase" === r3.kind ? e3.data = e3.data.toUpperCase() : "startsWith" === r3.kind ? e3.data.startsWith(r3.value) || (i3 = this._getOrReturnCtx(e3, i3), I(i3, { code: o.invalid_string, validation: { startsWith: r3.value }, message: r3.message }), t3.dirty()) : "endsWith" === r3.kind ? e3.data.endsWith(r3.value) || (i3 = this._getOrReturnCtx(e3, i3), I(i3, { code: o.invalid_string, validation: { endsWith: r3.value }, message: r3.message }), t3.dirty()) : "datetime" === r3.kind ? ((n2 = r3).precision ? n2.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${n2.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${n2.precision}}Z$`) : 0 === n2.precision ? n2.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : n2.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$")).test(e3.data) || (i3 = this._getOrReturnCtx(e3, i3), I(i3, { code: o.invalid_string, validation: "datetime", message: r3.message }), t3.dirty()) : "ip" === r3.kind ? (s3 = e3.data, ("v4" !== (a2 = r3.version) && a2 || !G.test(s3)) && ("v6" !== a2 && a2 || !j.test(s3)) && (i3 = this._getOrReturnCtx(e3, i3), I(i3, { validation: "ip", code: o.invalid_string, message: r3.message }), t3.dirty())) : A2.assertNever(r3);
            var s3, a2, n2;
            return { status: t3.value, value: e3.data };
          }
          _regex(e3, t3, i3) {
            return this.refinement((t4) => e3.test(t4), { validation: t3, code: o.invalid_string, ...b.errToObj(i3) });
          }
          _addCheck(e3) {
            return new M({ ...this._def, checks: [...this._def.checks, e3] });
          }
          email(e3) {
            return this._addCheck({ kind: "email", ...b.errToObj(e3) });
          }
          url(e3) {
            return this._addCheck({ kind: "url", ...b.errToObj(e3) });
          }
          emoji(e3) {
            return this._addCheck({ kind: "emoji", ...b.errToObj(e3) });
          }
          uuid(e3) {
            return this._addCheck({ kind: "uuid", ...b.errToObj(e3) });
          }
          cuid(e3) {
            return this._addCheck({ kind: "cuid", ...b.errToObj(e3) });
          }
          cuid2(e3) {
            return this._addCheck({ kind: "cuid2", ...b.errToObj(e3) });
          }
          ulid(e3) {
            return this._addCheck({ kind: "ulid", ...b.errToObj(e3) });
          }
          ip(e3) {
            return this._addCheck({ kind: "ip", ...b.errToObj(e3) });
          }
          datetime(e3) {
            var t3;
            return "string" == typeof e3 ? this._addCheck({ kind: "datetime", precision: null, offset: false, message: e3 }) : this._addCheck({ kind: "datetime", precision: void 0 === (null == e3 ? void 0 : e3.precision) ? null : null == e3 ? void 0 : e3.precision, offset: null !== (t3 = null == e3 ? void 0 : e3.offset) && void 0 !== t3 && t3, ...b.errToObj(null == e3 ? void 0 : e3.message) });
          }
          regex(e3, t3) {
            return this._addCheck({ kind: "regex", regex: e3, ...b.errToObj(t3) });
          }
          includes(e3, t3) {
            return this._addCheck({ kind: "includes", value: e3, position: null == t3 ? void 0 : t3.position, ...b.errToObj(null == t3 ? void 0 : t3.message) });
          }
          startsWith(e3, t3) {
            return this._addCheck({ kind: "startsWith", value: e3, ...b.errToObj(t3) });
          }
          endsWith(e3, t3) {
            return this._addCheck({ kind: "endsWith", value: e3, ...b.errToObj(t3) });
          }
          min(e3, t3) {
            return this._addCheck({ kind: "min", value: e3, ...b.errToObj(t3) });
          }
          max(e3, t3) {
            return this._addCheck({ kind: "max", value: e3, ...b.errToObj(t3) });
          }
          length(e3, t3) {
            return this._addCheck({ kind: "length", value: e3, ...b.errToObj(t3) });
          }
          nonempty(e3) {
            return this.min(1, b.errToObj(e3));
          }
          trim() {
            return new M({ ...this._def, checks: [...this._def.checks, { kind: "trim" }] });
          }
          toLowerCase() {
            return new M({ ...this._def, checks: [...this._def.checks, { kind: "toLowerCase" }] });
          }
          toUpperCase() {
            return new M({ ...this._def, checks: [...this._def.checks, { kind: "toUpperCase" }] });
          }
          get isDatetime() {
            return !!this._def.checks.find((e3) => "datetime" === e3.kind);
          }
          get isEmail() {
            return !!this._def.checks.find((e3) => "email" === e3.kind);
          }
          get isURL() {
            return !!this._def.checks.find((e3) => "url" === e3.kind);
          }
          get isEmoji() {
            return !!this._def.checks.find((e3) => "emoji" === e3.kind);
          }
          get isUUID() {
            return !!this._def.checks.find((e3) => "uuid" === e3.kind);
          }
          get isCUID() {
            return !!this._def.checks.find((e3) => "cuid" === e3.kind);
          }
          get isCUID2() {
            return !!this._def.checks.find((e3) => "cuid2" === e3.kind);
          }
          get isULID() {
            return !!this._def.checks.find((e3) => "ulid" === e3.kind);
          }
          get isIP() {
            return !!this._def.checks.find((e3) => "ip" === e3.kind);
          }
          get minLength() {
            let e3 = null;
            for (const t3 of this._def.checks)
              "min" === t3.kind && (null === e3 || t3.value > e3) && (e3 = t3.value);
            return e3;
          }
          get maxLength() {
            let e3 = null;
            for (const t3 of this._def.checks)
              "max" === t3.kind && (null === e3 || t3.value < e3) && (e3 = t3.value);
            return e3;
          }
        }
        function R(e3, t3) {
          const i3 = (e3.toString().split(".")[1] || "").length, A3 = (t3.toString().split(".")[1] || "").length, s3 = i3 > A3 ? i3 : A3;
          return parseInt(e3.toFixed(s3).replace(".", "")) % parseInt(t3.toFixed(s3).replace(".", "")) / Math.pow(10, s3);
        }
        M.create = (e3) => {
          var t3;
          return new M({ checks: [], typeName: xe.ZodString, coerce: null !== (t3 = null == e3 ? void 0 : e3.coerce) && void 0 !== t3 && t3, ...x(e3) });
        };
        class O extends T {
          constructor() {
            super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
          }
          _parse(e3) {
            if (this._def.coerce && (e3.data = Number(e3.data)), this._getType(e3) !== r2.number) {
              const t4 = this._getOrReturnCtx(e3);
              return I(t4, { code: o.invalid_type, expected: r2.number, received: t4.parsedType }), C;
            }
            let t3;
            const i3 = new f();
            for (const s3 of this._def.checks)
              "int" === s3.kind ? A2.isInteger(e3.data) || (t3 = this._getOrReturnCtx(e3, t3), I(t3, { code: o.invalid_type, expected: "integer", received: "float", message: s3.message }), i3.dirty()) : "min" === s3.kind ? (s3.inclusive ? e3.data < s3.value : e3.data <= s3.value) && (t3 = this._getOrReturnCtx(e3, t3), I(t3, { code: o.too_small, minimum: s3.value, type: "number", inclusive: s3.inclusive, exact: false, message: s3.message }), i3.dirty()) : "max" === s3.kind ? (s3.inclusive ? e3.data > s3.value : e3.data >= s3.value) && (t3 = this._getOrReturnCtx(e3, t3), I(t3, { code: o.too_big, maximum: s3.value, type: "number", inclusive: s3.inclusive, exact: false, message: s3.message }), i3.dirty()) : "multipleOf" === s3.kind ? 0 !== R(e3.data, s3.value) && (t3 = this._getOrReturnCtx(e3, t3), I(t3, { code: o.not_multiple_of, multipleOf: s3.value, message: s3.message }), i3.dirty()) : "finite" === s3.kind ? Number.isFinite(e3.data) || (t3 = this._getOrReturnCtx(e3, t3), I(t3, { code: o.not_finite, message: s3.message }), i3.dirty()) : A2.assertNever(s3);
            return { status: i3.value, value: e3.data };
          }
          gte(e3, t3) {
            return this.setLimit("min", e3, true, b.toString(t3));
          }
          gt(e3, t3) {
            return this.setLimit("min", e3, false, b.toString(t3));
          }
          lte(e3, t3) {
            return this.setLimit("max", e3, true, b.toString(t3));
          }
          lt(e3, t3) {
            return this.setLimit("max", e3, false, b.toString(t3));
          }
          setLimit(e3, t3, i3, A3) {
            return new O({ ...this._def, checks: [...this._def.checks, { kind: e3, value: t3, inclusive: i3, message: b.toString(A3) }] });
          }
          _addCheck(e3) {
            return new O({ ...this._def, checks: [...this._def.checks, e3] });
          }
          int(e3) {
            return this._addCheck({ kind: "int", message: b.toString(e3) });
          }
          positive(e3) {
            return this._addCheck({ kind: "min", value: 0, inclusive: false, message: b.toString(e3) });
          }
          negative(e3) {
            return this._addCheck({ kind: "max", value: 0, inclusive: false, message: b.toString(e3) });
          }
          nonpositive(e3) {
            return this._addCheck({ kind: "max", value: 0, inclusive: true, message: b.toString(e3) });
          }
          nonnegative(e3) {
            return this._addCheck({ kind: "min", value: 0, inclusive: true, message: b.toString(e3) });
          }
          multipleOf(e3, t3) {
            return this._addCheck({ kind: "multipleOf", value: e3, message: b.toString(t3) });
          }
          finite(e3) {
            return this._addCheck({ kind: "finite", message: b.toString(e3) });
          }
          safe(e3) {
            return this._addCheck({ kind: "min", inclusive: true, value: Number.MIN_SAFE_INTEGER, message: b.toString(e3) })._addCheck({ kind: "max", inclusive: true, value: Number.MAX_SAFE_INTEGER, message: b.toString(e3) });
          }
          get minValue() {
            let e3 = null;
            for (const t3 of this._def.checks)
              "min" === t3.kind && (null === e3 || t3.value > e3) && (e3 = t3.value);
            return e3;
          }
          get maxValue() {
            let e3 = null;
            for (const t3 of this._def.checks)
              "max" === t3.kind && (null === e3 || t3.value < e3) && (e3 = t3.value);
            return e3;
          }
          get isInt() {
            return !!this._def.checks.find((e3) => "int" === e3.kind || "multipleOf" === e3.kind && A2.isInteger(e3.value));
          }
          get isFinite() {
            let e3 = null, t3 = null;
            for (const i3 of this._def.checks) {
              if ("finite" === i3.kind || "int" === i3.kind || "multipleOf" === i3.kind)
                return true;
              "min" === i3.kind ? (null === t3 || i3.value > t3) && (t3 = i3.value) : "max" === i3.kind && (null === e3 || i3.value < e3) && (e3 = i3.value);
            }
            return Number.isFinite(t3) && Number.isFinite(e3);
          }
        }
        O.create = (e3) => new O({ checks: [], typeName: xe.ZodNumber, coerce: (null == e3 ? void 0 : e3.coerce) || false, ...x(e3) });
        class z extends T {
          constructor() {
            super(...arguments), this.min = this.gte, this.max = this.lte;
          }
          _parse(e3) {
            if (this._def.coerce && (e3.data = BigInt(e3.data)), this._getType(e3) !== r2.bigint) {
              const t4 = this._getOrReturnCtx(e3);
              return I(t4, { code: o.invalid_type, expected: r2.bigint, received: t4.parsedType }), C;
            }
            let t3;
            const i3 = new f();
            for (const s3 of this._def.checks)
              "min" === s3.kind ? (s3.inclusive ? e3.data < s3.value : e3.data <= s3.value) && (t3 = this._getOrReturnCtx(e3, t3), I(t3, { code: o.too_small, type: "bigint", minimum: s3.value, inclusive: s3.inclusive, message: s3.message }), i3.dirty()) : "max" === s3.kind ? (s3.inclusive ? e3.data > s3.value : e3.data >= s3.value) && (t3 = this._getOrReturnCtx(e3, t3), I(t3, { code: o.too_big, type: "bigint", maximum: s3.value, inclusive: s3.inclusive, message: s3.message }), i3.dirty()) : "multipleOf" === s3.kind ? e3.data % s3.value !== BigInt(0) && (t3 = this._getOrReturnCtx(e3, t3), I(t3, { code: o.not_multiple_of, multipleOf: s3.value, message: s3.message }), i3.dirty()) : A2.assertNever(s3);
            return { status: i3.value, value: e3.data };
          }
          gte(e3, t3) {
            return this.setLimit("min", e3, true, b.toString(t3));
          }
          gt(e3, t3) {
            return this.setLimit("min", e3, false, b.toString(t3));
          }
          lte(e3, t3) {
            return this.setLimit("max", e3, true, b.toString(t3));
          }
          lt(e3, t3) {
            return this.setLimit("max", e3, false, b.toString(t3));
          }
          setLimit(e3, t3, i3, A3) {
            return new z({ ...this._def, checks: [...this._def.checks, { kind: e3, value: t3, inclusive: i3, message: b.toString(A3) }] });
          }
          _addCheck(e3) {
            return new z({ ...this._def, checks: [...this._def.checks, e3] });
          }
          positive(e3) {
            return this._addCheck({ kind: "min", value: BigInt(0), inclusive: false, message: b.toString(e3) });
          }
          negative(e3) {
            return this._addCheck({ kind: "max", value: BigInt(0), inclusive: false, message: b.toString(e3) });
          }
          nonpositive(e3) {
            return this._addCheck({ kind: "max", value: BigInt(0), inclusive: true, message: b.toString(e3) });
          }
          nonnegative(e3) {
            return this._addCheck({ kind: "min", value: BigInt(0), inclusive: true, message: b.toString(e3) });
          }
          multipleOf(e3, t3) {
            return this._addCheck({ kind: "multipleOf", value: e3, message: b.toString(t3) });
          }
          get minValue() {
            let e3 = null;
            for (const t3 of this._def.checks)
              "min" === t3.kind && (null === e3 || t3.value > e3) && (e3 = t3.value);
            return e3;
          }
          get maxValue() {
            let e3 = null;
            for (const t3 of this._def.checks)
              "max" === t3.kind && (null === e3 || t3.value < e3) && (e3 = t3.value);
            return e3;
          }
        }
        z.create = (e3) => {
          var t3;
          return new z({ checks: [], typeName: xe.ZodBigInt, coerce: null !== (t3 = null == e3 ? void 0 : e3.coerce) && void 0 !== t3 && t3, ...x(e3) });
        };
        class P extends T {
          _parse(e3) {
            if (this._def.coerce && (e3.data = Boolean(e3.data)), this._getType(e3) !== r2.boolean) {
              const t3 = this._getOrReturnCtx(e3);
              return I(t3, { code: o.invalid_type, expected: r2.boolean, received: t3.parsedType }), C;
            }
            return B(e3.data);
          }
        }
        P.create = (e3) => new P({ typeName: xe.ZodBoolean, coerce: (null == e3 ? void 0 : e3.coerce) || false, ...x(e3) });
        class U extends T {
          _parse(e3) {
            if (this._def.coerce && (e3.data = new Date(e3.data)), this._getType(e3) !== r2.date) {
              const t4 = this._getOrReturnCtx(e3);
              return I(t4, { code: o.invalid_type, expected: r2.date, received: t4.parsedType }), C;
            }
            if (isNaN(e3.data.getTime()))
              return I(this._getOrReturnCtx(e3), { code: o.invalid_date }), C;
            const t3 = new f();
            let i3;
            for (const s3 of this._def.checks)
              "min" === s3.kind ? e3.data.getTime() < s3.value && (i3 = this._getOrReturnCtx(e3, i3), I(i3, { code: o.too_small, message: s3.message, inclusive: true, exact: false, minimum: s3.value, type: "date" }), t3.dirty()) : "max" === s3.kind ? e3.data.getTime() > s3.value && (i3 = this._getOrReturnCtx(e3, i3), I(i3, { code: o.too_big, message: s3.message, inclusive: true, exact: false, maximum: s3.value, type: "date" }), t3.dirty()) : A2.assertNever(s3);
            return { status: t3.value, value: new Date(e3.data.getTime()) };
          }
          _addCheck(e3) {
            return new U({ ...this._def, checks: [...this._def.checks, e3] });
          }
          min(e3, t3) {
            return this._addCheck({ kind: "min", value: e3.getTime(), message: b.toString(t3) });
          }
          max(e3, t3) {
            return this._addCheck({ kind: "max", value: e3.getTime(), message: b.toString(t3) });
          }
          get minDate() {
            let e3 = null;
            for (const t3 of this._def.checks)
              "min" === t3.kind && (null === e3 || t3.value > e3) && (e3 = t3.value);
            return null != e3 ? new Date(e3) : null;
          }
          get maxDate() {
            let e3 = null;
            for (const t3 of this._def.checks)
              "max" === t3.kind && (null === e3 || t3.value < e3) && (e3 = t3.value);
            return null != e3 ? new Date(e3) : null;
          }
        }
        U.create = (e3) => new U({ checks: [], coerce: (null == e3 ? void 0 : e3.coerce) || false, typeName: xe.ZodDate, ...x(e3) });
        class J extends T {
          _parse(e3) {
            if (this._getType(e3) !== r2.symbol) {
              const t3 = this._getOrReturnCtx(e3);
              return I(t3, { code: o.invalid_type, expected: r2.symbol, received: t3.parsedType }), C;
            }
            return B(e3.data);
          }
        }
        J.create = (e3) => new J({ typeName: xe.ZodSymbol, ...x(e3) });
        class q extends T {
          _parse(e3) {
            if (this._getType(e3) !== r2.undefined) {
              const t3 = this._getOrReturnCtx(e3);
              return I(t3, { code: o.invalid_type, expected: r2.undefined, received: t3.parsedType }), C;
            }
            return B(e3.data);
          }
        }
        q.create = (e3) => new q({ typeName: xe.ZodUndefined, ...x(e3) });
        class Z extends T {
          _parse(e3) {
            if (this._getType(e3) !== r2.null) {
              const t3 = this._getOrReturnCtx(e3);
              return I(t3, { code: o.invalid_type, expected: r2.null, received: t3.parsedType }), C;
            }
            return B(e3.data);
          }
        }
        Z.create = (e3) => new Z({ typeName: xe.ZodNull, ...x(e3) });
        class H extends T {
          constructor() {
            super(...arguments), this._any = true;
          }
          _parse(e3) {
            return B(e3.data);
          }
        }
        H.create = (e3) => new H({ typeName: xe.ZodAny, ...x(e3) });
        class Y extends T {
          constructor() {
            super(...arguments), this._unknown = true;
          }
          _parse(e3) {
            return B(e3.data);
          }
        }
        Y.create = (e3) => new Y({ typeName: xe.ZodUnknown, ...x(e3) });
        class K extends T {
          _parse(e3) {
            const t3 = this._getOrReturnCtx(e3);
            return I(t3, { code: o.invalid_type, expected: r2.never, received: t3.parsedType }), C;
          }
        }
        K.create = (e3) => new K({ typeName: xe.ZodNever, ...x(e3) });
        class V extends T {
          _parse(e3) {
            if (this._getType(e3) !== r2.undefined) {
              const t3 = this._getOrReturnCtx(e3);
              return I(t3, { code: o.invalid_type, expected: r2.void, received: t3.parsedType }), C;
            }
            return B(e3.data);
          }
        }
        V.create = (e3) => new V({ typeName: xe.ZodVoid, ...x(e3) });
        class W extends T {
          _parse(e3) {
            const { ctx: t3, status: i3 } = this._processInputParams(e3), A3 = this._def;
            if (t3.parsedType !== r2.array)
              return I(t3, { code: o.invalid_type, expected: r2.array, received: t3.parsedType }), C;
            if (null !== A3.exactLength) {
              const e4 = t3.data.length > A3.exactLength.value, s4 = t3.data.length < A3.exactLength.value;
              (e4 || s4) && (I(t3, { code: e4 ? o.too_big : o.too_small, minimum: s4 ? A3.exactLength.value : void 0, maximum: e4 ? A3.exactLength.value : void 0, type: "array", inclusive: true, exact: true, message: A3.exactLength.message }), i3.dirty());
            }
            if (null !== A3.minLength && t3.data.length < A3.minLength.value && (I(t3, { code: o.too_small, minimum: A3.minLength.value, type: "array", inclusive: true, exact: false, message: A3.minLength.message }), i3.dirty()), null !== A3.maxLength && t3.data.length > A3.maxLength.value && (I(t3, { code: o.too_big, maximum: A3.maxLength.value, type: "array", inclusive: true, exact: false, message: A3.maxLength.message }), i3.dirty()), t3.common.async)
              return Promise.all([...t3.data].map((e4, i4) => A3.type._parseAsync(new _(t3, e4, t3.path, i4)))).then((e4) => f.mergeArray(i3, e4));
            const s3 = [...t3.data].map((e4, i4) => A3.type._parseSync(new _(t3, e4, t3.path, i4)));
            return f.mergeArray(i3, s3);
          }
          get element() {
            return this._def.type;
          }
          min(e3, t3) {
            return new W({ ...this._def, minLength: { value: e3, message: b.toString(t3) } });
          }
          max(e3, t3) {
            return new W({ ...this._def, maxLength: { value: e3, message: b.toString(t3) } });
          }
          length(e3, t3) {
            return new W({ ...this._def, exactLength: { value: e3, message: b.toString(t3) } });
          }
          nonempty(e3) {
            return this.min(1, e3);
          }
        }
        function X(e3) {
          if (e3 instanceof $) {
            const t3 = {};
            for (const i3 in e3.shape) {
              const A3 = e3.shape[i3];
              t3[i3] = fe.create(X(A3));
            }
            return new $({ ...e3._def, shape: () => t3 });
          }
          return e3 instanceof W ? new W({ ...e3._def, type: X(e3.element) }) : e3 instanceof fe ? fe.create(X(e3.unwrap())) : e3 instanceof Ce ? Ce.create(X(e3.unwrap())) : e3 instanceof re ? re.create(e3.items.map((e4) => X(e4))) : e3;
        }
        W.create = (e3, t3) => new W({ type: e3, minLength: null, maxLength: null, exactLength: null, typeName: xe.ZodArray, ...x(t3) });
        class $ extends T {
          constructor() {
            super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
          }
          _getCached() {
            if (null !== this._cached)
              return this._cached;
            const e3 = this._def.shape(), t3 = A2.objectKeys(e3);
            return this._cached = { shape: e3, keys: t3 };
          }
          _parse(e3) {
            if (this._getType(e3) !== r2.object) {
              const t4 = this._getOrReturnCtx(e3);
              return I(t4, { code: o.invalid_type, expected: r2.object, received: t4.parsedType }), C;
            }
            const { status: t3, ctx: i3 } = this._processInputParams(e3), { shape: A3, keys: s3 } = this._getCached(), a2 = [];
            if (!(this._def.catchall instanceof K && "strip" === this._def.unknownKeys))
              for (const e4 in i3.data)
                s3.includes(e4) || a2.push(e4);
            const n2 = [];
            for (const e4 of s3) {
              const t4 = A3[e4], s4 = i3.data[e4];
              n2.push({ key: { status: "valid", value: e4 }, value: t4._parse(new _(i3, s4, i3.path, e4)), alwaysSet: e4 in i3.data });
            }
            if (this._def.catchall instanceof K) {
              const e4 = this._def.unknownKeys;
              if ("passthrough" === e4)
                for (const e5 of a2)
                  n2.push({ key: { status: "valid", value: e5 }, value: { status: "valid", value: i3.data[e5] } });
              else if ("strict" === e4)
                a2.length > 0 && (I(i3, { code: o.unrecognized_keys, keys: a2 }), t3.dirty());
              else if ("strip" !== e4)
                throw new Error("Internal ZodObject error: invalid unknownKeys value.");
            } else {
              const e4 = this._def.catchall;
              for (const t4 of a2) {
                const A4 = i3.data[t4];
                n2.push({ key: { status: "valid", value: t4 }, value: e4._parse(new _(i3, A4, i3.path, t4)), alwaysSet: t4 in i3.data });
              }
            }
            return i3.common.async ? Promise.resolve().then(async () => {
              const e4 = [];
              for (const t4 of n2) {
                const i4 = await t4.key;
                e4.push({ key: i4, value: await t4.value, alwaysSet: t4.alwaysSet });
              }
              return e4;
            }).then((e4) => f.mergeObjectSync(t3, e4)) : f.mergeObjectSync(t3, n2);
          }
          get shape() {
            return this._def.shape();
          }
          strict(e3) {
            return b.errToObj, new $({ ...this._def, unknownKeys: "strict", ...void 0 !== e3 ? { errorMap: (t3, i3) => {
              var A3, s3, r3, a2;
              const o2 = null !== (r3 = null === (s3 = (A3 = this._def).errorMap) || void 0 === s3 ? void 0 : s3.call(A3, t3, i3).message) && void 0 !== r3 ? r3 : i3.defaultError;
              return "unrecognized_keys" === t3.code ? { message: null !== (a2 = b.errToObj(e3).message) && void 0 !== a2 ? a2 : o2 } : { message: o2 };
            } } : {} });
          }
          strip() {
            return new $({ ...this._def, unknownKeys: "strip" });
          }
          passthrough() {
            return new $({ ...this._def, unknownKeys: "passthrough" });
          }
          extend(e3) {
            return new $({ ...this._def, shape: () => ({ ...this._def.shape(), ...e3 }) });
          }
          merge(e3) {
            return new $({ unknownKeys: e3._def.unknownKeys, catchall: e3._def.catchall, shape: () => ({ ...this._def.shape(), ...e3._def.shape() }), typeName: xe.ZodObject });
          }
          setKey(e3, t3) {
            return this.augment({ [e3]: t3 });
          }
          catchall(e3) {
            return new $({ ...this._def, catchall: e3 });
          }
          pick(e3) {
            const t3 = {};
            return A2.objectKeys(e3).forEach((i3) => {
              e3[i3] && this.shape[i3] && (t3[i3] = this.shape[i3]);
            }), new $({ ...this._def, shape: () => t3 });
          }
          omit(e3) {
            const t3 = {};
            return A2.objectKeys(this.shape).forEach((i3) => {
              e3[i3] || (t3[i3] = this.shape[i3]);
            }), new $({ ...this._def, shape: () => t3 });
          }
          deepPartial() {
            return X(this);
          }
          partial(e3) {
            const t3 = {};
            return A2.objectKeys(this.shape).forEach((i3) => {
              const A3 = this.shape[i3];
              e3 && !e3[i3] ? t3[i3] = A3 : t3[i3] = A3.optional();
            }), new $({ ...this._def, shape: () => t3 });
          }
          required(e3) {
            const t3 = {};
            return A2.objectKeys(this.shape).forEach((i3) => {
              if (e3 && !e3[i3])
                t3[i3] = this.shape[i3];
              else {
                let e4 = this.shape[i3];
                for (; e4 instanceof fe; )
                  e4 = e4._def.innerType;
                t3[i3] = e4;
              }
            }), new $({ ...this._def, shape: () => t3 });
          }
          keyof() {
            return ge(A2.objectKeys(this.shape));
          }
        }
        $.create = (e3, t3) => new $({ shape: () => e3, unknownKeys: "strip", catchall: K.create(), typeName: xe.ZodObject, ...x(t3) }), $.strictCreate = (e3, t3) => new $({ shape: () => e3, unknownKeys: "strict", catchall: K.create(), typeName: xe.ZodObject, ...x(t3) }), $.lazycreate = (e3, t3) => new $({ shape: e3, unknownKeys: "strip", catchall: K.create(), typeName: xe.ZodObject, ...x(t3) });
        class ee extends T {
          _parse(e3) {
            const { ctx: t3 } = this._processInputParams(e3), i3 = this._def.options;
            if (t3.common.async)
              return Promise.all(i3.map(async (e4) => {
                const i4 = { ...t3, common: { ...t3.common, issues: [] }, parent: null };
                return { result: await e4._parseAsync({ data: t3.data, path: t3.path, parent: i4 }), ctx: i4 };
              })).then(function(e4) {
                for (const t4 of e4)
                  if ("valid" === t4.result.status)
                    return t4.result;
                for (const i5 of e4)
                  if ("dirty" === i5.result.status)
                    return t3.common.issues.push(...i5.ctx.common.issues), i5.result;
                const i4 = e4.map((e5) => new l(e5.ctx.common.issues));
                return I(t3, { code: o.invalid_union, unionErrors: i4 }), C;
              });
            {
              let e4;
              const A3 = [];
              for (const s4 of i3) {
                const i4 = { ...t3, common: { ...t3.common, issues: [] }, parent: null }, r3 = s4._parseSync({ data: t3.data, path: t3.path, parent: i4 });
                if ("valid" === r3.status)
                  return r3;
                "dirty" !== r3.status || e4 || (e4 = { result: r3, ctx: i4 }), i4.common.issues.length && A3.push(i4.common.issues);
              }
              if (e4)
                return t3.common.issues.push(...e4.ctx.common.issues), e4.result;
              const s3 = A3.map((e5) => new l(e5));
              return I(t3, { code: o.invalid_union, unionErrors: s3 }), C;
            }
          }
          get options() {
            return this._def.options;
          }
        }
        ee.create = (e3, t3) => new ee({ options: e3, typeName: xe.ZodUnion, ...x(t3) });
        const te = (e3) => e3 instanceof de ? te(e3.schema) : e3 instanceof Ie ? te(e3.innerType()) : e3 instanceof ce ? [e3.value] : e3 instanceof he ? e3.options : e3 instanceof ue ? Object.keys(e3.enum) : e3 instanceof me ? te(e3._def.innerType) : e3 instanceof q ? [void 0] : e3 instanceof Z ? [null] : null;
        class ie extends T {
          _parse(e3) {
            const { ctx: t3 } = this._processInputParams(e3);
            if (t3.parsedType !== r2.object)
              return I(t3, { code: o.invalid_type, expected: r2.object, received: t3.parsedType }), C;
            const i3 = this.discriminator, A3 = t3.data[i3], s3 = this.optionsMap.get(A3);
            return s3 ? t3.common.async ? s3._parseAsync({ data: t3.data, path: t3.path, parent: t3 }) : s3._parseSync({ data: t3.data, path: t3.path, parent: t3 }) : (I(t3, { code: o.invalid_union_discriminator, options: Array.from(this.optionsMap.keys()), path: [i3] }), C);
          }
          get discriminator() {
            return this._def.discriminator;
          }
          get options() {
            return this._def.options;
          }
          get optionsMap() {
            return this._def.optionsMap;
          }
          static create(e3, t3, i3) {
            const A3 = /* @__PURE__ */ new Map();
            for (const i4 of t3) {
              const t4 = te(i4.shape[e3]);
              if (!t4)
                throw new Error(`A discriminator value for key \`${e3}\` could not be extracted from all schema options`);
              for (const s3 of t4) {
                if (A3.has(s3))
                  throw new Error(`Discriminator property ${String(e3)} has duplicate value ${String(s3)}`);
                A3.set(s3, i4);
              }
            }
            return new ie({ typeName: xe.ZodDiscriminatedUnion, discriminator: e3, options: t3, optionsMap: A3, ...x(i3) });
          }
        }
        function Ae(e3, t3) {
          const i3 = a(e3), s3 = a(t3);
          if (e3 === t3)
            return { valid: true, data: e3 };
          if (i3 === r2.object && s3 === r2.object) {
            const i4 = A2.objectKeys(t3), s4 = A2.objectKeys(e3).filter((e4) => -1 !== i4.indexOf(e4)), r3 = { ...e3, ...t3 };
            for (const i5 of s4) {
              const A3 = Ae(e3[i5], t3[i5]);
              if (!A3.valid)
                return { valid: false };
              r3[i5] = A3.data;
            }
            return { valid: true, data: r3 };
          }
          if (i3 === r2.array && s3 === r2.array) {
            if (e3.length !== t3.length)
              return { valid: false };
            const i4 = [];
            for (let A3 = 0; A3 < e3.length; A3++) {
              const s4 = Ae(e3[A3], t3[A3]);
              if (!s4.valid)
                return { valid: false };
              i4.push(s4.data);
            }
            return { valid: true, data: i4 };
          }
          return i3 === r2.date && s3 === r2.date && +e3 == +t3 ? { valid: true, data: e3 } : { valid: false };
        }
        class se extends T {
          _parse(e3) {
            const { status: t3, ctx: i3 } = this._processInputParams(e3), A3 = (e4, A4) => {
              if (E(e4) || E(A4))
                return C;
              const s3 = Ae(e4.value, A4.value);
              return s3.valid ? ((y(e4) || y(A4)) && t3.dirty(), { status: t3.value, value: s3.data }) : (I(i3, { code: o.invalid_intersection_types }), C);
            };
            return i3.common.async ? Promise.all([this._def.left._parseAsync({ data: i3.data, path: i3.path, parent: i3 }), this._def.right._parseAsync({ data: i3.data, path: i3.path, parent: i3 })]).then(([e4, t4]) => A3(e4, t4)) : A3(this._def.left._parseSync({ data: i3.data, path: i3.path, parent: i3 }), this._def.right._parseSync({ data: i3.data, path: i3.path, parent: i3 }));
          }
        }
        se.create = (e3, t3, i3) => new se({ left: e3, right: t3, typeName: xe.ZodIntersection, ...x(i3) });
        class re extends T {
          _parse(e3) {
            const { status: t3, ctx: i3 } = this._processInputParams(e3);
            if (i3.parsedType !== r2.array)
              return I(i3, { code: o.invalid_type, expected: r2.array, received: i3.parsedType }), C;
            if (i3.data.length < this._def.items.length)
              return I(i3, { code: o.too_small, minimum: this._def.items.length, inclusive: true, exact: false, type: "array" }), C;
            !this._def.rest && i3.data.length > this._def.items.length && (I(i3, { code: o.too_big, maximum: this._def.items.length, inclusive: true, exact: false, type: "array" }), t3.dirty());
            const A3 = [...i3.data].map((e4, t4) => {
              const A4 = this._def.items[t4] || this._def.rest;
              return A4 ? A4._parse(new _(i3, e4, i3.path, t4)) : null;
            }).filter((e4) => !!e4);
            return i3.common.async ? Promise.all(A3).then((e4) => f.mergeArray(t3, e4)) : f.mergeArray(t3, A3);
          }
          get items() {
            return this._def.items;
          }
          rest(e3) {
            return new re({ ...this._def, rest: e3 });
          }
        }
        re.create = (e3, t3) => {
          if (!Array.isArray(e3))
            throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
          return new re({ items: e3, typeName: xe.ZodTuple, rest: null, ...x(t3) });
        };
        class ae extends T {
          get keySchema() {
            return this._def.keyType;
          }
          get valueSchema() {
            return this._def.valueType;
          }
          _parse(e3) {
            const { status: t3, ctx: i3 } = this._processInputParams(e3);
            if (i3.parsedType !== r2.object)
              return I(i3, { code: o.invalid_type, expected: r2.object, received: i3.parsedType }), C;
            const A3 = [], s3 = this._def.keyType, a2 = this._def.valueType;
            for (const e4 in i3.data)
              A3.push({ key: s3._parse(new _(i3, e4, i3.path, e4)), value: a2._parse(new _(i3, i3.data[e4], i3.path, e4)) });
            return i3.common.async ? f.mergeObjectAsync(t3, A3) : f.mergeObjectSync(t3, A3);
          }
          get element() {
            return this._def.valueType;
          }
          static create(e3, t3, i3) {
            return new ae(t3 instanceof T ? { keyType: e3, valueType: t3, typeName: xe.ZodRecord, ...x(i3) } : { keyType: M.create(), valueType: e3, typeName: xe.ZodRecord, ...x(t3) });
          }
        }
        class oe extends T {
          get keySchema() {
            return this._def.keyType;
          }
          get valueSchema() {
            return this._def.valueType;
          }
          _parse(e3) {
            const { status: t3, ctx: i3 } = this._processInputParams(e3);
            if (i3.parsedType !== r2.map)
              return I(i3, { code: o.invalid_type, expected: r2.map, received: i3.parsedType }), C;
            const A3 = this._def.keyType, s3 = this._def.valueType, a2 = [...i3.data.entries()].map(([e4, t4], r3) => ({ key: A3._parse(new _(i3, e4, i3.path, [r3, "key"])), value: s3._parse(new _(i3, t4, i3.path, [r3, "value"])) }));
            if (i3.common.async) {
              const e4 = /* @__PURE__ */ new Map();
              return Promise.resolve().then(async () => {
                for (const i4 of a2) {
                  const A4 = await i4.key, s4 = await i4.value;
                  if ("aborted" === A4.status || "aborted" === s4.status)
                    return C;
                  "dirty" !== A4.status && "dirty" !== s4.status || t3.dirty(), e4.set(A4.value, s4.value);
                }
                return { status: t3.value, value: e4 };
              });
            }
            {
              const e4 = /* @__PURE__ */ new Map();
              for (const i4 of a2) {
                const A4 = i4.key, s4 = i4.value;
                if ("aborted" === A4.status || "aborted" === s4.status)
                  return C;
                "dirty" !== A4.status && "dirty" !== s4.status || t3.dirty(), e4.set(A4.value, s4.value);
              }
              return { status: t3.value, value: e4 };
            }
          }
        }
        oe.create = (e3, t3, i3) => new oe({ valueType: t3, keyType: e3, typeName: xe.ZodMap, ...x(i3) });
        class ne extends T {
          _parse(e3) {
            const { status: t3, ctx: i3 } = this._processInputParams(e3);
            if (i3.parsedType !== r2.set)
              return I(i3, { code: o.invalid_type, expected: r2.set, received: i3.parsedType }), C;
            const A3 = this._def;
            null !== A3.minSize && i3.data.size < A3.minSize.value && (I(i3, { code: o.too_small, minimum: A3.minSize.value, type: "set", inclusive: true, exact: false, message: A3.minSize.message }), t3.dirty()), null !== A3.maxSize && i3.data.size > A3.maxSize.value && (I(i3, { code: o.too_big, maximum: A3.maxSize.value, type: "set", inclusive: true, exact: false, message: A3.maxSize.message }), t3.dirty());
            const s3 = this._def.valueType;
            function a2(e4) {
              const i4 = /* @__PURE__ */ new Set();
              for (const A4 of e4) {
                if ("aborted" === A4.status)
                  return C;
                "dirty" === A4.status && t3.dirty(), i4.add(A4.value);
              }
              return { status: t3.value, value: i4 };
            }
            const n2 = [...i3.data.values()].map((e4, t4) => s3._parse(new _(i3, e4, i3.path, t4)));
            return i3.common.async ? Promise.all(n2).then((e4) => a2(e4)) : a2(n2);
          }
          min(e3, t3) {
            return new ne({ ...this._def, minSize: { value: e3, message: b.toString(t3) } });
          }
          max(e3, t3) {
            return new ne({ ...this._def, maxSize: { value: e3, message: b.toString(t3) } });
          }
          size(e3, t3) {
            return this.min(e3, t3).max(e3, t3);
          }
          nonempty(e3) {
            return this.min(1, e3);
          }
        }
        ne.create = (e3, t3) => new ne({ valueType: e3, minSize: null, maxSize: null, typeName: xe.ZodSet, ...x(t3) });
        class le extends T {
          constructor() {
            super(...arguments), this.validate = this.implement;
          }
          _parse(e3) {
            const { ctx: t3 } = this._processInputParams(e3);
            if (t3.parsedType !== r2.function)
              return I(t3, { code: o.invalid_type, expected: r2.function, received: t3.parsedType }), C;
            function i3(e4, i4) {
              return u({ data: e4, path: t3.path, errorMaps: [t3.common.contextualErrorMap, t3.schemaErrorMap, h(), d].filter((e5) => !!e5), issueData: { code: o.invalid_arguments, argumentsError: i4 } });
            }
            function A3(e4, i4) {
              return u({ data: e4, path: t3.path, errorMaps: [t3.common.contextualErrorMap, t3.schemaErrorMap, h(), d].filter((e5) => !!e5), issueData: { code: o.invalid_return_type, returnTypeError: i4 } });
            }
            const s3 = { errorMap: t3.common.contextualErrorMap }, a2 = t3.data;
            if (this._def.returns instanceof pe) {
              const e4 = this;
              return B(async function(...t4) {
                const r3 = new l([]), o2 = await e4._def.args.parseAsync(t4, s3).catch((e5) => {
                  throw r3.addIssue(i3(t4, e5)), r3;
                }), n2 = await Reflect.apply(a2, this, o2);
                return await e4._def.returns._def.type.parseAsync(n2, s3).catch((e5) => {
                  throw r3.addIssue(A3(n2, e5)), r3;
                });
              });
            }
            {
              const e4 = this;
              return B(function(...t4) {
                const r3 = e4._def.args.safeParse(t4, s3);
                if (!r3.success)
                  throw new l([i3(t4, r3.error)]);
                const o2 = Reflect.apply(a2, this, r3.data), n2 = e4._def.returns.safeParse(o2, s3);
                if (!n2.success)
                  throw new l([A3(o2, n2.error)]);
                return n2.data;
              });
            }
          }
          parameters() {
            return this._def.args;
          }
          returnType() {
            return this._def.returns;
          }
          args(...e3) {
            return new le({ ...this._def, args: re.create(e3).rest(Y.create()) });
          }
          returns(e3) {
            return new le({ ...this._def, returns: e3 });
          }
          implement(e3) {
            return this.parse(e3);
          }
          strictImplement(e3) {
            return this.parse(e3);
          }
          static create(e3, t3, i3) {
            return new le({ args: e3 || re.create([]).rest(Y.create()), returns: t3 || Y.create(), typeName: xe.ZodFunction, ...x(i3) });
          }
        }
        class de extends T {
          get schema() {
            return this._def.getter();
          }
          _parse(e3) {
            const { ctx: t3 } = this._processInputParams(e3);
            return this._def.getter()._parse({ data: t3.data, path: t3.path, parent: t3 });
          }
        }
        de.create = (e3, t3) => new de({ getter: e3, typeName: xe.ZodLazy, ...x(t3) });
        class ce extends T {
          _parse(e3) {
            if (e3.data !== this._def.value) {
              const t3 = this._getOrReturnCtx(e3);
              return I(t3, { received: t3.data, code: o.invalid_literal, expected: this._def.value }), C;
            }
            return { status: "valid", value: e3.data };
          }
          get value() {
            return this._def.value;
          }
        }
        function ge(e3, t3) {
          return new he({ values: e3, typeName: xe.ZodEnum, ...x(t3) });
        }
        ce.create = (e3, t3) => new ce({ value: e3, typeName: xe.ZodLiteral, ...x(t3) });
        class he extends T {
          _parse(e3) {
            if ("string" != typeof e3.data) {
              const t3 = this._getOrReturnCtx(e3), i3 = this._def.values;
              return I(t3, { expected: A2.joinValues(i3), received: t3.parsedType, code: o.invalid_type }), C;
            }
            if (-1 === this._def.values.indexOf(e3.data)) {
              const t3 = this._getOrReturnCtx(e3), i3 = this._def.values;
              return I(t3, { received: t3.data, code: o.invalid_enum_value, options: i3 }), C;
            }
            return B(e3.data);
          }
          get options() {
            return this._def.values;
          }
          get enum() {
            const e3 = {};
            for (const t3 of this._def.values)
              e3[t3] = t3;
            return e3;
          }
          get Values() {
            const e3 = {};
            for (const t3 of this._def.values)
              e3[t3] = t3;
            return e3;
          }
          get Enum() {
            const e3 = {};
            for (const t3 of this._def.values)
              e3[t3] = t3;
            return e3;
          }
          extract(e3) {
            return he.create(e3);
          }
          exclude(e3) {
            return he.create(this.options.filter((t3) => !e3.includes(t3)));
          }
        }
        he.create = ge;
        class ue extends T {
          _parse(e3) {
            const t3 = A2.getValidEnumValues(this._def.values), i3 = this._getOrReturnCtx(e3);
            if (i3.parsedType !== r2.string && i3.parsedType !== r2.number) {
              const e4 = A2.objectValues(t3);
              return I(i3, { expected: A2.joinValues(e4), received: i3.parsedType, code: o.invalid_type }), C;
            }
            if (-1 === t3.indexOf(e3.data)) {
              const e4 = A2.objectValues(t3);
              return I(i3, { received: i3.data, code: o.invalid_enum_value, options: e4 }), C;
            }
            return B(e3.data);
          }
          get enum() {
            return this._def.values;
          }
        }
        ue.create = (e3, t3) => new ue({ values: e3, typeName: xe.ZodNativeEnum, ...x(t3) });
        class pe extends T {
          unwrap() {
            return this._def.type;
          }
          _parse(e3) {
            const { ctx: t3 } = this._processInputParams(e3);
            if (t3.parsedType !== r2.promise && false === t3.common.async)
              return I(t3, { code: o.invalid_type, expected: r2.promise, received: t3.parsedType }), C;
            const i3 = t3.parsedType === r2.promise ? t3.data : Promise.resolve(t3.data);
            return B(i3.then((e4) => this._def.type.parseAsync(e4, { path: t3.path, errorMap: t3.common.contextualErrorMap })));
          }
        }
        pe.create = (e3, t3) => new pe({ type: e3, typeName: xe.ZodPromise, ...x(t3) });
        class Ie extends T {
          innerType() {
            return this._def.schema;
          }
          sourceType() {
            return this._def.schema._def.typeName === xe.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
          }
          _parse(e3) {
            const { status: t3, ctx: i3 } = this._processInputParams(e3), s3 = this._def.effect || null, r3 = { addIssue: (e4) => {
              I(i3, e4), e4.fatal ? t3.abort() : t3.dirty();
            }, get path() {
              return i3.path;
            } };
            if (r3.addIssue = r3.addIssue.bind(r3), "preprocess" === s3.type) {
              const e4 = s3.transform(i3.data, r3);
              return i3.common.issues.length ? { status: "dirty", value: i3.data } : i3.common.async ? Promise.resolve(e4).then((e5) => this._def.schema._parseAsync({ data: e5, path: i3.path, parent: i3 })) : this._def.schema._parseSync({ data: e4, path: i3.path, parent: i3 });
            }
            if ("refinement" === s3.type) {
              const e4 = (e5) => {
                const t4 = s3.refinement(e5, r3);
                if (i3.common.async)
                  return Promise.resolve(t4);
                if (t4 instanceof Promise)
                  throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                return e5;
              };
              if (false === i3.common.async) {
                const A3 = this._def.schema._parseSync({ data: i3.data, path: i3.path, parent: i3 });
                return "aborted" === A3.status ? C : ("dirty" === A3.status && t3.dirty(), e4(A3.value), { status: t3.value, value: A3.value });
              }
              return this._def.schema._parseAsync({ data: i3.data, path: i3.path, parent: i3 }).then((i4) => "aborted" === i4.status ? C : ("dirty" === i4.status && t3.dirty(), e4(i4.value).then(() => ({ status: t3.value, value: i4.value }))));
            }
            if ("transform" === s3.type) {
              if (false === i3.common.async) {
                const e4 = this._def.schema._parseSync({ data: i3.data, path: i3.path, parent: i3 });
                if (!Q(e4))
                  return e4;
                const A3 = s3.transform(e4.value, r3);
                if (A3 instanceof Promise)
                  throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
                return { status: t3.value, value: A3 };
              }
              return this._def.schema._parseAsync({ data: i3.data, path: i3.path, parent: i3 }).then((e4) => Q(e4) ? Promise.resolve(s3.transform(e4.value, r3)).then((e5) => ({ status: t3.value, value: e5 })) : e4);
            }
            A2.assertNever(s3);
          }
        }
        Ie.create = (e3, t3, i3) => new Ie({ schema: e3, typeName: xe.ZodEffects, effect: t3, ...x(i3) }), Ie.createWithPreprocess = (e3, t3, i3) => new Ie({ schema: t3, effect: { type: "preprocess", transform: e3 }, typeName: xe.ZodEffects, ...x(i3) });
        class fe extends T {
          _parse(e3) {
            return this._getType(e3) === r2.undefined ? B(void 0) : this._def.innerType._parse(e3);
          }
          unwrap() {
            return this._def.innerType;
          }
        }
        fe.create = (e3, t3) => new fe({ innerType: e3, typeName: xe.ZodOptional, ...x(t3) });
        class Ce extends T {
          _parse(e3) {
            return this._getType(e3) === r2.null ? B(null) : this._def.innerType._parse(e3);
          }
          unwrap() {
            return this._def.innerType;
          }
        }
        Ce.create = (e3, t3) => new Ce({ innerType: e3, typeName: xe.ZodNullable, ...x(t3) });
        class me extends T {
          _parse(e3) {
            const { ctx: t3 } = this._processInputParams(e3);
            let i3 = t3.data;
            return t3.parsedType === r2.undefined && (i3 = this._def.defaultValue()), this._def.innerType._parse({ data: i3, path: t3.path, parent: t3 });
          }
          removeDefault() {
            return this._def.innerType;
          }
        }
        me.create = (e3, t3) => new me({ innerType: e3, typeName: xe.ZodDefault, defaultValue: "function" == typeof t3.default ? t3.default : () => t3.default, ...x(t3) });
        class Be extends T {
          _parse(e3) {
            const { ctx: t3 } = this._processInputParams(e3), i3 = { ...t3, common: { ...t3.common, issues: [] } }, A3 = this._def.innerType._parse({ data: i3.data, path: i3.path, parent: { ...i3 } });
            return w(A3) ? A3.then((e4) => ({ status: "valid", value: "valid" === e4.status ? e4.value : this._def.catchValue({ get error() {
              return new l(i3.common.issues);
            }, input: i3.data }) })) : { status: "valid", value: "valid" === A3.status ? A3.value : this._def.catchValue({ get error() {
              return new l(i3.common.issues);
            }, input: i3.data }) };
          }
          removeCatch() {
            return this._def.innerType;
          }
        }
        Be.create = (e3, t3) => new Be({ innerType: e3, typeName: xe.ZodCatch, catchValue: "function" == typeof t3.catch ? t3.catch : () => t3.catch, ...x(t3) });
        class Ee extends T {
          _parse(e3) {
            if (this._getType(e3) !== r2.nan) {
              const t3 = this._getOrReturnCtx(e3);
              return I(t3, { code: o.invalid_type, expected: r2.nan, received: t3.parsedType }), C;
            }
            return { status: "valid", value: e3.data };
          }
        }
        Ee.create = (e3) => new Ee({ typeName: xe.ZodNaN, ...x(e3) });
        const ye = Symbol("zod_brand");
        class Qe extends T {
          _parse(e3) {
            const { ctx: t3 } = this._processInputParams(e3), i3 = t3.data;
            return this._def.type._parse({ data: i3, path: t3.path, parent: t3 });
          }
          unwrap() {
            return this._def.type;
          }
        }
        class we extends T {
          _parse(e3) {
            const { status: t3, ctx: i3 } = this._processInputParams(e3);
            if (i3.common.async)
              return (async () => {
                const e4 = await this._def.in._parseAsync({ data: i3.data, path: i3.path, parent: i3 });
                return "aborted" === e4.status ? C : "dirty" === e4.status ? (t3.dirty(), m(e4.value)) : this._def.out._parseAsync({ data: e4.value, path: i3.path, parent: i3 });
              })();
            {
              const e4 = this._def.in._parseSync({ data: i3.data, path: i3.path, parent: i3 });
              return "aborted" === e4.status ? C : "dirty" === e4.status ? (t3.dirty(), { status: "dirty", value: e4.value }) : this._def.out._parseSync({ data: e4.value, path: i3.path, parent: i3 });
            }
          }
          static create(e3, t3) {
            return new we({ in: e3, out: t3, typeName: xe.ZodPipeline });
          }
        }
        class be extends T {
          _parse(e3) {
            const t3 = this._def.innerType._parse(e3);
            return Q(t3) && (t3.value = Object.freeze(t3.value)), t3;
          }
        }
        be.create = (e3, t3) => new be({ innerType: e3, typeName: xe.ZodReadonly, ...x(t3) });
        const _e = (e3, t3 = {}, i3) => e3 ? H.create().superRefine((A3, s3) => {
          var r3, a2;
          if (!e3(A3)) {
            const e4 = "function" == typeof t3 ? t3(A3) : "string" == typeof t3 ? { message: t3 } : t3, o2 = null === (a2 = null !== (r3 = e4.fatal) && void 0 !== r3 ? r3 : i3) || void 0 === a2 || a2, n2 = "string" == typeof e4 ? { message: e4 } : e4;
            s3.addIssue({ code: "custom", ...n2, fatal: o2 });
          }
        }) : H.create(), ve = { object: $.lazycreate };
        var xe;
        !function(e3) {
          e3.ZodString = "ZodString", e3.ZodNumber = "ZodNumber", e3.ZodNaN = "ZodNaN", e3.ZodBigInt = "ZodBigInt", e3.ZodBoolean = "ZodBoolean", e3.ZodDate = "ZodDate", e3.ZodSymbol = "ZodSymbol", e3.ZodUndefined = "ZodUndefined", e3.ZodNull = "ZodNull", e3.ZodAny = "ZodAny", e3.ZodUnknown = "ZodUnknown", e3.ZodNever = "ZodNever", e3.ZodVoid = "ZodVoid", e3.ZodArray = "ZodArray", e3.ZodObject = "ZodObject", e3.ZodUnion = "ZodUnion", e3.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e3.ZodIntersection = "ZodIntersection", e3.ZodTuple = "ZodTuple", e3.ZodRecord = "ZodRecord", e3.ZodMap = "ZodMap", e3.ZodSet = "ZodSet", e3.ZodFunction = "ZodFunction", e3.ZodLazy = "ZodLazy", e3.ZodLiteral = "ZodLiteral", e3.ZodEnum = "ZodEnum", e3.ZodEffects = "ZodEffects", e3.ZodNativeEnum = "ZodNativeEnum", e3.ZodOptional = "ZodOptional", e3.ZodNullable = "ZodNullable", e3.ZodDefault = "ZodDefault", e3.ZodCatch = "ZodCatch", e3.ZodPromise = "ZodPromise", e3.ZodBranded = "ZodBranded", e3.ZodPipeline = "ZodPipeline", e3.ZodReadonly = "ZodReadonly";
        }(xe || (xe = {}));
        const Te = (e3, t3 = { message: `Input not instance of ${e3.name}` }) => _e((t4) => t4 instanceof e3, t3), ke = M.create, De = O.create, Le = Ee.create, Ne = z.create, Fe = P.create, Se = U.create, Ge = J.create, je = q.create, Me = Z.create, Re = H.create, Oe = Y.create, ze = K.create, Pe = V.create, Ue = W.create, Je = $.create, qe = $.strictCreate, Ze = ee.create, He = ie.create, Ye = se.create, Ke = re.create, Ve = ae.create, We = oe.create, Xe = ne.create, $e = le.create, et = de.create, tt = ce.create, it = he.create, At = ue.create, st = pe.create, rt = Ie.create, at = fe.create, ot = Ce.create, nt = Ie.createWithPreprocess, lt = we.create, dt = () => ke().optional(), ct = () => De().optional(), gt = () => Fe().optional(), ht = { string: (e3) => M.create({ ...e3, coerce: true }), number: (e3) => O.create({ ...e3, coerce: true }), boolean: (e3) => P.create({ ...e3, coerce: true }), bigint: (e3) => z.create({ ...e3, coerce: true }), date: (e3) => U.create({ ...e3, coerce: true }) }, ut = C;
        var pt = Object.freeze({ __proto__: null, defaultErrorMap: d, setErrorMap: g, getErrorMap: h, makeIssue: u, EMPTY_PATH: p, addIssueToContext: I, ParseStatus: f, INVALID: C, DIRTY: m, OK: B, isAborted: E, isDirty: y, isValid: Q, isAsync: w, get util() {
          return A2;
        }, get objectUtil() {
          return s2;
        }, ZodParsedType: r2, getParsedType: a, ZodType: T, ZodString: M, ZodNumber: O, ZodBigInt: z, ZodBoolean: P, ZodDate: U, ZodSymbol: J, ZodUndefined: q, ZodNull: Z, ZodAny: H, ZodUnknown: Y, ZodNever: K, ZodVoid: V, ZodArray: W, ZodObject: $, ZodUnion: ee, ZodDiscriminatedUnion: ie, ZodIntersection: se, ZodTuple: re, ZodRecord: ae, ZodMap: oe, ZodSet: ne, ZodFunction: le, ZodLazy: de, ZodLiteral: ce, ZodEnum: he, ZodNativeEnum: ue, ZodPromise: pe, ZodEffects: Ie, ZodTransformer: Ie, ZodOptional: fe, ZodNullable: Ce, ZodDefault: me, ZodCatch: Be, ZodNaN: Ee, BRAND: ye, ZodBranded: Qe, ZodPipeline: we, ZodReadonly: be, custom: _e, Schema: T, ZodSchema: T, late: ve, get ZodFirstPartyTypeKind() {
          return xe;
        }, coerce: ht, any: Re, array: Ue, bigint: Ne, boolean: Fe, date: Se, discriminatedUnion: He, effect: rt, enum: it, function: $e, instanceof: Te, intersection: Ye, lazy: et, literal: tt, map: We, nan: Le, nativeEnum: At, never: ze, null: Me, nullable: ot, number: De, object: Je, oboolean: gt, onumber: ct, optional: at, ostring: dt, pipeline: lt, preprocess: nt, promise: st, record: Ve, set: Xe, strictObject: qe, string: ke, symbol: Ge, transformer: rt, tuple: Ke, undefined: je, union: Ze, unknown: Oe, void: Pe, NEVER: ut, ZodIssueCode: o, quotelessJson: n, ZodError: l });
      }, "./node_modules/zstddec/dist/zstddec.modern.js": (e2, t2, i2) => {
        "use strict";
        let A2, s2, r2;
        i2.r(t2), i2.d(t2, { ZSTDDecoder: () => o });
        const a = { env: { emscripten_notify_memory_growth: function(e3) {
          r2 = new Uint8Array(s2.exports.memory.buffer);
        } } };
        class o {
          init() {
            return A2 || (A2 = "undefined" != typeof fetch ? fetch("data:application/wasm;base64," + n).then((e3) => e3.arrayBuffer()).then((e3) => WebAssembly.instantiate(e3, a)).then(this._init) : WebAssembly.instantiate(Buffer.from(n, "base64"), a).then(this._init), A2);
          }
          _init(e3) {
            s2 = e3.instance, a.env.emscripten_notify_memory_growth(0);
          }
          decode(e3, t3 = 0) {
            if (!s2)
              throw new Error("ZSTDDecoder: Await .init() before decoding.");
            const i3 = e3.byteLength, A3 = s2.exports.malloc(i3);
            r2.set(e3, A3), t3 = t3 || Number(s2.exports.ZSTD_findDecompressedSize(A3, i3));
            const a2 = s2.exports.malloc(t3), o2 = s2.exports.ZSTD_decompress(a2, t3, A3, i3), n2 = r2.slice(a2, a2 + o2);
            return s2.exports.free(A3), s2.exports.free(a2), n2;
          }
        }
        const n = "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IAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQh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ASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigC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C0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdB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IAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY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wOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEE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";
      } }, A = {};
      function s(e2) {
        var t2 = A[e2];
        if (void 0 !== t2)
          return t2.exports;
        var r2 = A[e2] = { exports: {} };
        return i[e2](r2, r2.exports, s), r2.exports;
      }
      s.n = (e2) => {
        var t2 = e2 && e2.__esModule ? () => e2.default : () => e2;
        return s.d(t2, { a: t2 }), t2;
      }, s.d = (e2, t2) => {
        for (var i2 in t2)
          s.o(t2, i2) && !s.o(e2, i2) && Object.defineProperty(e2, i2, { enumerable: true, get: t2[i2] });
      }, s.o = (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2), s.r = (e2) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
      };
      var r = {};
      return (() => {
        "use strict";
        s.r(r), s.d(r, { Decoder: () => t2.Decoder, Deprecated: () => m, Ellipse: () => l.Ellipse, ExcaliburTiledProperties: () => i2.ExcaliburTiledProperties, FLIPPED_DIAGONALLY_FLAG: () => o.FLIPPED_DIAGONALLY_FLAG, FLIPPED_HORIZONTALLY_FLAG: () => o.FLIPPED_HORIZONTALLY_FLAG, FLIPPED_VERTICALLY_FLAG: () => o.FLIPPED_VERTICALLY_FLAG, FetchLoader: () => A2.FetchLoader, InsertedTile: () => l.InsertedTile, LoaderCache: () => n.LoaderCache, PluginObject: () => l.PluginObject, Point: () => l.Point, Polygon: () => l.Polygon, Polyline: () => l.Polyline, Rectangle: () => l.Rectangle, Template: () => h.Template, TemplateObject: () => l.TemplateObject, TemplateResource: () => g.TemplateResource, Text: () => l.Text, Tile: () => C.Tile, TiledDataComponent: () => u.TiledDataComponent, TiledLayerDataComponent: () => p.TiledLayerDataComponent, TiledMap: () => e2.TiledMap, TiledParser: () => e2.TiledParser, TiledResource: () => I.TiledResource, TiledTemplate: () => e2.TiledTemplate, TiledText: () => e2.TiledText, TiledTile: () => e2.TiledTile, TiledTileLayer: () => e2.TiledTileLayer, TiledTileLayerInfinite: () => e2.TiledTileLayerInfinite, TiledTileset: () => e2.TiledTileset, TiledTilesetFile: () => e2.TiledTilesetFile, Tileset: () => C.Tileset, TilesetResource: () => f.TilesetResource, byClassCaseInsensitive: () => a.byClassCaseInsensitive, byNameCaseInsensitive: () => a.byNameCaseInsensitive, byPropertyCaseInsensitive: () => a.byPropertyCaseInsensitive, filenameFromPath: () => d.filenameFromPath, getCanonicalGid: () => o.getCanonicalGid, isCSV: () => e2.isCSV, isFlippedDiagonally: () => o.isFlippedDiagonally, isFlippedHorizontally: () => o.isFlippedHorizontally, isFlippedVertically: () => o.isFlippedVertically, isInfiniteLayer: () => e2.isInfiniteLayer, isTiledTilesetCollectionOfImages: () => e2.isTiledTilesetCollectionOfImages, isTiledTilesetEmbedded: () => e2.isTiledTilesetEmbedded, isTiledTilesetExternal: () => e2.isTiledTilesetExternal, isTiledTilesetSingleImage: () => e2.isTiledTilesetSingleImage, mapPath: () => d.mapPath, mapProps: () => c.mapProps, needsDecoding: () => e2.needsDecoding, parseObject: () => l.parseObject, parseObjects: () => l.parseObjects, pathInMap: () => d.pathInMap, pathRelativeToBase: () => d.pathRelativeToBase });
        var e2 = s("./src/parser/tiled-parser.ts"), t2 = s("./src/resource/decoder.ts"), i2 = s("./src/resource/excalibur-properties.ts"), A2 = s("./src/resource/file-loader.ts"), a = s("./src/resource/filter-util.ts"), o = s("./src/resource/gid-util.ts"), n = (s("./src/resource/layer.ts"), s("./src/resource/loader-cache.ts")), l = s("./src/resource/objects.ts"), d = s("./src/resource/path-util.ts"), c = s("./src/resource/properties.ts"), g = s("./src/resource/template-resource.ts"), h = s("./src/resource/template.ts"), u = s("./src/resource/tiled-data-component.ts"), p = s("./src/resource/tiled-layer-component.ts"), I = s("./src/resource/tiled-resource.ts"), f = s("./src/resource/tileset-resource.ts"), C = s("./src/resource/tileset.ts"), m = s("./src/deprecated.ts");
      })(), r;
    })());
  }
});
export default require_excalibur_tiled_min();
/*! Bundled license information:

@excaliburjs/plugin-tiled/dist/excalibur-tiled.min.js:
  (*! For license information please see excalibur-tiled.min.js.LICENSE.txt *)
*/
//# sourceMappingURL=@excaliburjs_plugin-tiled.js.map
